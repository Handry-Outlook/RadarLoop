<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta charset="utf-8">
  <title>RadarLoop UK</title>
  <link rel="icon" type="image/png"
    href="https://raw.githubusercontent.com/Handry-Outlook/Convective-Outlook/main/Handry_outlook_icon_pride_small.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />

  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.min.js"></script>

  <script>
    console.log("--- Plugin Diagnostic ---");
    console.log("L exists:", typeof L);
    // If L exists, check if L.vectorGrid was created
    if (typeof L !== 'undefined' && typeof L.vectorGrid === 'undefined') {
      console.warn("L.vectorGrid is missing! Checking for Leaflet version conflict...");
    }
    console.log("L.vectorGrid type:", typeof L.vectorGrid);
  </script>

  <style>
    .smooth-raster {
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: pixelated;
      transform: translateZ(0);
      will-change: transform;
      transition: opacity 0.05s ease;
    }

    .smooth-raster.no-transition {
      transition: none;
    }

    .draw-toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .draw-toolbar button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .draw-toolbar button:hover {
      background: #2563eb;
    }

    .draw-toolbar select {
      padding: 6px;
      border-radius: 4px;
      font-size: 0.9em;
    }

    #polygon-controls {
      background: #ffffff;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode #polygon-controls {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .leaflet-draw {
      z-index: 1003;
    }

    .leaflet-layer-pixelated {
      /* Prevents the browser from smoothly interpolating pixels when scaling up */
      image-rendering: -webkit-optimize-contrast;
      /* For Chrome/Safari */
      image-rendering: -moz-crisp-edges;
      /* For Firefox */
      image-rendering: pixelated;
      /* Standard (and works in most modern browsers) */
    }

    .leaflet-draw-toolbar {
      display: none !important;
      /* Hide default Leaflet.draw toolbar */
    }

    .polygon-popup input,
    .polygon-popup select,
    .polygon-popup button {
      margin: 5px 0;
      padding: 5px;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 768px) {
      .draw-toolbar {
        flex-direction: column;
        align-items: flex-start;
      }

      #top-bar .draw-toolbar {
        display: none;
      }

      #control-panel .draw-toolbar {
        display: flex;
      }
    }

    @media (min-width: 769px) {
      #control-panel .draw-toolbar {
        display: none;
      }

      #top-bar .draw-toolbar {
        display: flex;
      }
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      background: #f4f7fa;
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode {
      background: #1a1a1a;
      color: #e0e0e0;
    }

    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #283673;
      padding: 10px 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 1002;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
      transition: background 0.3s ease;
    }

    /* Center the whole title group */
    #title-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      /* Space between logo and text */
      flex: 1;
      /* Takes middle space */
      pointer-events: none;
      /* Doesn't block underlying clicks */
      opacity: 0;
      /* Hidden on mobile by default */
      transition: opacity 0.3s ease;
    }

    #app-logo {
      height: 42px;
      /* Adjust to match your logo's design */
      width: auto;
      object-fit: contain;
    }

    #app-title {
      margin: 0;
      color: #ffffff;
      font-weight: 600;
      font-size: 1.5em;
      white-space: nowrap;
      /* Prevents text wrapping */
    }

    /* Show only on desktop */
    @media (min-width: 769px) {
      #title-group {
        opacity: 1;
      }
    }

    /* Optional: Slightly smaller on medium screens */
    @media (max-width: 1200px) {
      #app-logo {
        height: 36px;
      }

      #app-title {
        font-size: 1.3em;
      }
    }

    #top-bar>div {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    body.dark-mode #top-bar {
      background: #2a2a2a;
    }

    #top-bar h2 {
      margin: 0;
      color: #ffffff;
      font-weight: 600;
      font-size: 1.2em;
      flex-shrink: 0;
    }

    #top-bar div {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      flex-wrap: nowrap;
      max-width: 50%;
    }

    #top-bar button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      flex-shrink: 0;
      margin-right: 5px;
    }

    #top-bar button:hover {
      background: #2563eb;
    }

    .logo {
      width: 80px;
      pointer-events: none;
      z-index: 1001;
    }

    .leaflet-layer.satellite-layer {
      z-index: 140 !important;
      /* Added transition to help with fade-in/out */
      transition: opacity 0.3s ease-in-out;
    }

    @media (min-width: 769px) {
      .logo {
        position: absolute;
        bottom: 20px;
        right: 15px;
      }
    }

    @media (max-width: 768px) {
      .logo {
        position: absolute;
        top: 70px;
        left: 10px;
      }
    }

    #map,
    #map-3d {
      position: fixed;
      top: 60;
      left: 0;
      width: 100%;
      height: calc(100vh - 60px);
      z-index: 1;
      border-radius: 8px;
    }

    #map-3d {
      display: none;
    }

    #control-panel {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 106;
      padding: 10px;
      transition: background 0.3s ease, color 0.3s ease;
      z-index: 1003;
      overflow-x: hidden;
      direction: rtl
    }

    #control-panel::-webkit-scrollbar {
      width: 8px;
      /* Thin scrollbar for WebKit browsers */
    }

    /* Ensure control panel handles overflow correctly */
    #control-panel {
      padding: 8px;
      /* Consistent with previous compact design */
      width: 280px;
      /* Slightly narrower */
      max-height: calc(100vh - 80px);
      /* Limit height to viewport minus top bar */
      overflow-y: auto;
      /* Vertical scrollbar for overflow */
      overflow-x: hidden;
      /* Prevent horizontal overflow */
      box-sizing: border-box;
      /* Ensure padding is included in width */
    }

    /* Compact section styling */
    .section {
      margin-bottom: 10px;
      padding-bottom: 8px;
    }

    /* Compact labels to constrain sliders */
    .control-panel label {
      font-size: 0.75em;
      margin-bottom: 6px;
      width: 100%;
      /* Ensure label takes full width of container */
      box-sizing: border-box;
      /* Include padding in width */
    }

    /* Constrain sliders to prevent overflow */
    .control-panel input[type="range"] {
      width: 100%;
      /* Full width of parent label */
      max-width: 240px;
      /* Limit slider width to fit within control panel */
      height: 6px;
      /* Compact height */
      background: #d1d5db;
      border-radius: 3px;
      margin: 2px 0;
      /* Reduced margin to minimize vertical space */
      padding: 0;
      /* Remove any padding */
      box-sizing: border-box;
      /* Ensure width includes all components */
    }

    /* Smaller slider thumbs */
    .control-panel input[type="range"]::-webkit-slider-thumb {
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -3px;
      /* Adjust thumb position to align with track */
    }

    .control-panel input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Dark mode slider styling */
    body.dark-mode .control-panel input[type="range"] {
      background: #555;
    }

    body.dark-mode .control-panel input[type="range"]::-webkit-slider-thumb {
      background: #4b9bff;
      /* Match dark mode button color */
    }

    body.dark-mode .control-panel input[type="range"]::-moz-range-thumb {
      background: #4b9bff;
    }

    /* Ensure other inputs and buttons remain compact */
    .control-panel input,
    .control-panel select,
    .control-panel button {
      padding: 4px;
      font-size: 0.75em;
      border-radius: 3px;
      width: 100%;
      /* Ensure full width within container */
      max-width: 240px;
      /* Consistent with slider width */
      box-sizing: border-box;
    }

    /* Compact checkboxes */
    .control-panel input[type="checkbox"] {
      transform: scale(0.8);
      margin-top: 2px;
      width: auto;
      /* Override max-width for checkboxes */
    }

    /* Ensure draw-toolbar elements are compact */
    .draw-toolbar button,
    .draw-toolbar select {
      padding: 4px 8px;
      font-size: 0.75em;
      border-radius: 3px;
      max-width: 240px;
      /* Constrain to fit within control panel */
    }

    /* Thin scrollbar */
    #control-panel::-webkit-scrollbar {
      width: 6px;
    }

    #control-panel::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 3px;
    }

    #control-panel::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    #control-panel::-webkit-scrollbar-thumb {
      background: #555;
      /* Dark mode thumb */
      border-radius: 4px;
    }

    #control-panel::-webkit-scrollbar-thumb:hover {
      background: #777;
      /* Lighter on hover */
    }

    #control-panel>* {
      direction: ltr;
      /* Reset content direction to normal */
    }

    body.dark-mode #control-panel {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    @media (min-width: 769px) {
      #control-panel {
        position: fixed;
        top: 60px;
        left: 20px;
        width: 300px;
        height: calc(100% - 80px);
        overflow-y: auto;
      }

      #map,
      #map-3d {
        left: 340px;
        width: calc(100% - 340px);
      }
    }

    @media (max-width: 768px) {
      #control-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        overflow-y: auto;
      }

      #control-panel.open {
        display: block;
      }

      #settings-button {
        position: fixed;
        top: 80px;
        right: 30px;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 1.2em;
        cursor: pointer;
        z-index: 1004;
      }

      #settings-button:hover {
        background: #2563eb;
      }

      #fullscreen-button,
      .fullscreen-toggle {
        display: none;
      }
    }

    .section {
      margin-bottom: 15px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 10px;
    }

    body.dark-mode .section {
      border-bottom: 1px solid #444;
    }

    .section h4 {
      margin: 0 0 10px;
      color: #1a2a44;
      font-weight: 600;
      font-size: 0.9em;
    }

    body.dark-mode .section h4 {
      color: #e0e0e0;
    }

    .control-panel label {
      display: flex;
      flex-direction: column;
      font-size: 0.8em;
      color: #1a2a44;
      font-weight: 500;
      margin-bottom: 8px;
      position: relative;
    }

    body.dark-mode .control-panel label {
      color: #e0e0e0;
    }

    .control-panel label span.tooltip {
      display: none;
      position: absolute;
      top: -30px;
      left: 0;
      background: #333;
      color: white;
      padding: 5px;
      border-radius: 4px;
      font-size: 0.7em;
      white-space: nowrap;
    }

    body.dark-mode .control-panel label span.tooltip {
      background: #555;
    }

    .control-panel label:hover span.tooltip {
      display: block;
    }

    .control-panel input,
    .control-panel select,
    .control-panel button {
      margin-top: 3px;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8em;
      background: #fff;
      color: #1a2a44;
      transition: background 0.3s ease, color 0.3s ease, border 0.3s ease;
    }

    body.dark-mode .control-panel input,
    body.dark-mode .control-panel select,
    body.dark-mode .control-panel button {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .control-panel input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }

    body.dark-mode .control-panel input[type="range"] {
      background: #555;
    }

    .control-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-panel input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-panel input[type="checkbox"] {
      margin-top: 3px;
      accent-color: #3b82f6;
    }

    .control-panel button,
    #remove-filter {
      background: #3b82f6;
      color: white;
      border: none;
      cursor: pointer;
    }

    .control-panel button:hover,
    #remove-filter:hover {
      background: #2563eb;
    }

    #expert-controls {
      display: none;
      padding: 10px;
      background: #f9fafb;
      border-radius: 6px;
      transition: background 0.3s ease;
    }

    body.dark-mode #expert-controls {
      background: #333;
    }

    .time-slider-container {
      position: fixed;
      bottom: 20px;
      background: #ffffff;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-sizing: border-box;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode .time-slider-container {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    @media (min-width: 769px) {
      .time-slider-container {
        left: 340px;
        width: calc((100% - 340px) * 0.8);
        left: calc(340px + ((100% - 340px) - ((100% - 340px) * 0.8)) / 2);
      }
    }

    @media (max-width: 768px) {
      .time-slider-container #history-time {
        font-size: 0.7em;
      }

      .time-slider-container {
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
      }
    }

    .time-slider-container .animator {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .time-slider-container button {
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
    }

    .time-slider-container button:hover {
      background: #2563eb;
    }

    .slider {
      width: 100%;
      -webkit-appearance: none;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }

    body.dark-mode .slider {
      background: #555;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .time-slider-container .status-info {
      font-size: 0.75em;
      color: #1a2a44;
      margin: 0;
    }

    body.dark-mode .time-slider-container .status-info {
      color: #e0e0e0;
    }

    .status-info-container {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 4px;
    }

    .legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      font-size: 0.75em;
      color: #1a2a44;
      max-width: 200px;
      /* Increased from 125px to make the legend wider */
      min-width: 150px;
      /* Increased from 110px for consistency with wider design */
      max-height: 300px;
      /* Set maximum height to limit vertical size */
      overflow-y: auto;
      /* Enable vertical scrolling when content exceeds max-height */
      position: absolute;
      top: 10px;
      /* Consistent 10px margin from top */
      right: 10px;
      /* Consistent 10px margin from right */
      z-index: 1010;
      /* High z-index to stay above map elements */
      transition: background 0.3s ease, color 0.3s ease;
    }

    /* Optional: Style the scrollbar for better aesthetics (works in WebKit browsers like Chrome/Safari) */
    .legend::-webkit-scrollbar {
      width: 8px;
      /* Width of the scrollbar */
    }

    .legend::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      /* Light track background */
      border-radius: 4px;
    }

    .legend::-webkit-scrollbar-thumb {
      background: rgba(26, 42, 68, 0.5);
      /* Match color scheme (#1a2a44 with opacity) */
      border-radius: 4px;
    }

    .legend::-webkit-scrollbar-thumb:hover {
      background: rgba(26, 42, 68, 0.8);
      /* Darker on hover */
    }

    .fullscreen .legend {
      right: 10px;
      /* Ensure 10px margin */
      top: 10px;
    }

    body.three-d-mode .legend {
      right: 10px;
      /* Ensure 10px margin */
      top: 10px;
    }

    @media (min-width: 769px) {
      .legend {
        right: calc(10px + 340px);
        /* Adjust for map offset */
      }
    }

    body.dark-mode .legend {
      background: rgba(40, 40, 40, 0.95);
      color: #e0e0e0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }

    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 8px;
      vertical-align: middle;
    }

    .gradient-bar {
      height: 10px;
      width: 100%;
    }

    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 1555;
      max-width: 90%;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode .modal {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    #tutorial-modal {
      max-height: 80vh;
      overflow-y: auto;
      width: 70%;
      max-width: 70vh;
      padding: 20px;
    }

    @media (max-width: 768px) {
      #tutorial-modal {
        width: 70%;
        max-height: 85vh;
        padding: 15px;
      }
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1004;
    }

    .hidden {
      display: none;
    }

    #fullscreen-button {
      position: fixed;
      bottom: 20px;
      right: 10px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 1004;
    }

    .user-location-marker {
      background-color: #3b82f6;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
      }
    }

    .fullscreen #map,
    .fullscreen #map-3d {
      width: 100vw;
      height: 1calc(100vh - 60px);
      left: 0;
      overflow: hidden
    }

    .fullscreen #control-panel {
      display: none;
    }

    .fullscreen .time-slider-container {
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
    }

    #map {
      position: absolute;
      top: 60px;
      bottom: 0;
      width: 100%;
      z-index: 1;
      transition: opacity 0.3s ease;
    }

    #map3D {
      position: absolute;
      top: 60px;
      bottom: 0;
      width: 100%;
      z-index: 2;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    body.three-d-mode #map {
      opacity: 0;
      /* Hide 2D map but keep it functional */
      pointer-events: none;
      /* Prevent interactions except for popups */
      height: 0;
      /* Minimize impact on layout */
      overflow: hidden;
    }

    body.three-d-mode #map3D {
      opacity: 1;
      /* Show 3D map */
    }

    .mapboxgl-ctrl-group {
      z-index: 1100 !important;
      /* Ensure mapbox-gl-draw controls are above top bar */
      margin-top: 70px !important;
      /* Move controls below top bar */
    }

    #expert-controls button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      margin-top: 5px;
      width: 100%;
      transition: background 0.3s ease;
    }

    #expert-controls button:hover {
      background: #2563eb;
    }

    body.dark-mode #expert-controls button {
      background: #4b9bff;
      color: #e0e0e0;
    }

    body.dark-mode #expert-controls button:hover {
      background: #3578d6;
    }

    .modal h3 {
      margin-top: 0;
      font-size: 1.1em;
      color: #1a2a44;
    }

    body.dark-mode .modal h3 {
      color: #e0e0e0;
    }

    .modal p {
      font-size: 0.9em;
      color: #1a2a44;
      margin: 10px 0;
    }

    body.dark-mode .modal p {
      color: #e0e0e0;
    }

    .modal label {
      display: block;
      font-size: 0.8em;
      color: #1a2a44;
      margin: 8px 0;
    }

    body.dark-mode .modal label {
      color: #e0e0e0;
    }

    .modal input[type="text"],
    .modal input[type="datetime-local"],
    .modal input[type="checkbox"] {
      width: 100%;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8em;
      background: #fff;
      color: #1a2a44;
      box-sizing: border-box;
      margin-top: 3px;
    }

    body.dark-mode .modal input[type="text"],
    body.dark-mode .modal input[type="datetime-local"],
    body.dark-mode .modal input[type="checkbox"] {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .modal input[type="checkbox"] {
      width: auto;
      accent-color: #3b82f6;
    }

    .modal button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      margin: 5px 5px 0 0;
    }

    .modal button:hover {
      background: #2563eb;
    }

    body.dark-mode .modal button {
      background: #4b9bff;
    }

    body.dark-mode .modal button:hover {
      background: #3578d6;
    }

    /* Adjust 3D map position in normal mode */
    #map-3d {
      position: absolute;
      top: 60px;
      /* Match 2D map offset to avoid top bar overlap */
      left: 0;
      width: 100%;
      height: calc(100vh - 60px);
      /* Adjust height to fit viewport minus top bar */
      z-index: 2;
      display: none;
      /* Preserve existing behavior */
      overflow: hidden;
    }

    /* Desktop mode with control panel */
    @media (min-width: 769px) {
      #map-3d {
        left: 340px;
        /* Match 2D map offset for control panel */
        width: calc(100% - 340px);
        height: calc(100vh - 60px);
        /* Maintain height */
      }
    }

    /* Fullscreen mode */
    .fullscreen #map-3d {
      top: 0;
      /* No offset needed in fullscreen */
      left: 0;
      width: 100vw;
      height: 100vh;
      /* Full viewport height */
      overflow: hidden;
    }

    /* Ensure 3D mode visibility */
    body.three-d-mode #map-3d {
      display: block;
      /* Show 3D map */
      opacity: 1;
    }
  </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M5QDT7XR39"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'G-M5QDT7XR39');
</script>

<body class="dark-mode">
  <div id="top-bar">
    <div class="draw-toolbar">
      <button onclick="toggleDrawing()">Enable Drawing</button>
      <select id="risk-level-select">
        <option value="Low risk">Low risk</option>
        <option value="Slight risk">Slight risk</option>
        <option value="Enhanced risk">Enhanced risk</option>
        <option value="Moderate risk">Moderate risk</option>
        <option value="High risk">High risk</option>
        <option value="Severe risk">Severe risk</option>
      </select>
      <button onclick="exportToKML()">Export KML</button>
    </div>
    <!-- NEW: Centered logo + title group -->

    <div class="right-controls">
      <button onclick="toggleDarkMode()">‚òÄÔ∏è Light Mode</button>
      <button onclick="toggleLegend()">Toggle Legend</button>
      <button onclick="showTutorial()">Help</button>
      <button onclick="showUserLocation()">üìç</button>
      <button class="fullscreen-toggle" onclick="toggleFullScreen()">‚õ∂</button>
    </div>
  </div>
  <div id="control-panel" class="control-panel">

    <div class="section">
      <h4>üó∫Ô∏è Map Style</h4>
      <label>Map Style: <select id="map-style" onchange="switchBaseMap(this.value)">
          <option value="mapbox-traffic-night">Mapbox Traffic Night</option>
          <option value="mapbox-traffic-day">Mapbox Traffic Day</option>
          <option value="custom">Mapbox Classic</option>
          <option value="mapbox-satellite">Mapbox Satellite</option>
          <option value="mapbox-outdoors">Mapbox Outdoors</option>
          <option value="mapbox-dark">Mapbox Dark</option>
          <option value="mapbox-light">Mapbox Light</option>
          <option value="mapbox-streets-satellite">Mapbox Streets-Satellite</option>
          <option value="mapbox-navigation">Mapbox Navigation</option>
          <option value="mapbox-navigation-night">Mapbox Navigation Night</option>
          <option value="osm">OpenStreetMap</option>
          <option value="opentopo">OpenTopoMap</option>
          <option value="esri">Esri World Imagery</option>
          <option value="maptiler-streets">MapTiler Streets</option>
          <option value="maptiler-outdoor">MapTiler Outdoor</option>
          <option value="maptiler-light">MapTiler Light</option>
          <option value="maptiler-dark">MapTiler Dark</option>
        </select><span class="tooltip">Choose map background</span></label>

      <div class="section"></div>
      <h4>‚õàÔ∏è Weather Layers</h4>

      <label>Radar Layer:
        <select id="radarLayer" onchange="handleRadarChange();">
          <option value="uk-precip-intensity">UK High Resolution Rainfall Intensity (Smoothed)</option>
          <option value="uk-precip-intensity-pixelated">UK High Resolution Rainfall Intensity (Pixelated)</option>
          <option value="uk-precip-intensity-accessible">UK High Resolution Rainfall Intensity (Accessible)</option>
          <option value="uk-precip-type">UK High Resolution Precipitation Type</option>
          <option value="europe-precip-intensity">Europe Low Resolution Rainfall Intensity</option>
          <option value="europe-precip-type">Europe Low Resolution Precipitation Type</option>
          <option value="none">None</option>
        </select>
        <span class="tooltip">Select radar data layer</span>
      </label>
      <label>Satellite Imagery:
        <input type="checkbox" checked id="satelliteToggle" onchange="satelliteVisibilityHandler();">
        <span class="tooltip">Show global satellite imagery in 10 minute intervals</span>
      </label>

      <label>Lightning Layer: <input type="checkbox" id="lightning-layer-toggle" checked
          onchange="toggleLightningLayer()"><span class="tooltip">Show lightning strikes</span></label>
      <label>Lightning Color by Age: <input type="checkbox" id="color-mode" checked
          onchange="updateStrikeColors()"><span class="tooltip">Color strikes by age</span></label>

      <label>Lightning Heatmap: <input type="checkbox" id="heatmap-toggle" onchange="toggleHeatmap()"><span
          class="tooltip">Show
          2D heatmap</span></label>
      <label>Lightning counter: <input type="checkbox" id="number-overlay-toggle"
          onchange="updateOverlay(currentFiltered)"><span class="tooltip">Show strike counts</span></label>


      <div class="section"></div>
      <h4>‚ú® Layer Opacity & Detail</h4>
      <label>Radar Opacity: <input type="range" id="radarOpacity" min="0" max="1" step="0.1" value="0.9"></label>
      <label>Satellite Opacity: <input type="range" id="satelliteOpacity" min="0" max="1" step="0.1"
          value="0.5"></label>
      <label>Heatmap Blur: <input type="range" id="blur-slider" min="1" max="50" value="30"
          onchange="updateHeatmap(currentFiltered)"><span class="tooltip">Adjust heatmap spread</span></label>
      <label>Number Resolution: <input type="range" id="density-slider" min="1" max="100" value="50"
          onchange="updateOverlay(currentFiltered)"><span class="tooltip">Adjust overlay grid size</span></label>
    </div>
    <div class="section">
      <h4>‚ûï Extras & Nowcasting</h4>
      <label>Sound: <input type="checkbox" id="sound-toggle" onchange="toggleSound()"><span class="tooltip">Play thunder
          sound</span></label>
      <label>Nowcast: <input type="checkbox" id="nowcast-toggle" checked onchange="toggleAllNowcast()"><span
          class="tooltip">Show lightning predictions</span></label>

      <label>Nowcast Confidence: <input type="range" id="min-nowcast-confidence" min="0" max="1" step="0.01" value="0.1"
          onchange="is3DMode ? update3DView() : toggleNowcast()"><span class="tooltip">Minimum confidence for nowcast
          cones to be displayed</span></label>
    </div>
    <div class="section">
      <h4>‚è≥ Time Filter</h4>
      <label>Start Time: <input type="datetime-local" id="start-time"><span class="tooltip">Filter strikes from this
          time</span></label>
      <label>End Time: <input type="datetime-local" id="end-time"><span class="tooltip">Filter strikes up to this
          time</span></label>
      <button onclick="applyFilter()">Apply Filter</button>
      <button id="remove-filter" onclick="removeTimeFilter()" style="display: none;">Remove Filter</button>
      <label>Auto Time Filter: <input type="checkbox" id="auto-time-filter" checked><span class="tooltip">Auto-adjust
          time based on uploaded files</span></label>
      <label>Lightning Lifespan: <input type="number" id="lightning-lifespan" value="3" min="0.1" step="0.1"> hours<span
          class="tooltip">Show strikes within this period</span></label>
      <label>Slider's Max History: <input type="number" id="max-history-hours" value="6" min="1" step="1"
          onchange="updateHistorySliderMax()"> hours<span class="tooltip">Max hours back for slider</span></label>
    </div>

    <div class="section">
      <h4>üó∫Ô∏è Polygon Drawing</h4>
      <label>Enable Polygons: <input type="checkbox" id="drawn-polygons-toggle" checked
          onchange="toggleDrawnPolygons()"><span class="tooltip">Show/hide drawn polygons</span></label>
      <label>Opacity: <input type="range" id="polygon-opacity" min="0" max="1" step="0.1" value="0.3"
          onchange="updateAllPolygonsOpacity()"><span class="tooltip">Adjust polygon fill opacity</span></label>
      <label>Outline Thickness: <input type="range" id="polygon-weight" min="1" max="10" step="1" value="2"
          onchange="updateAllPolygonsWeight()"><span class="tooltip">Adjust polygon outline thickness</span></label>
      <div class="draw-toolbar">
        <button onclick="toggleDrawing()">Enable Drawing</button>
        <select id="risk-level-select">
          <option value="Low risk">Low risk</option>
          <option value="Slight risk">Slight risk</option>
          <option value="Enhanced risk">Enhanced risk</option>
          <option value="Moderate risk">Moderate risk</option>
          <option value="High risk">High risk</option>
          <option value="Severe risk">Severe risk</option>
        </select>
        <button onclick="exportToKML()">Export KML</button>
      </div>
    </div>

    <div class="section">
      <h4>‚öôÔ∏è Automation</h4>
      <label>Auto-refresh: <select id="refresh-interval" onchange="setRefreshInterval()">
          <option value="0">Off</option>
          <option value="0.0167">1 seconds (This might slow down your device)</option>
          <option value="0.167" selected>10 seconds</option>
          <option value="0.5">30 seconds</option>
          <option value="1">1 minute</option>
          <option value="5">5 minutes</option>
          <option value="10">10 minutes</option>
        </select><span class="tooltip">Set data refresh interval</span></label>
      <label>Auto-set Latest: <input type="checkbox" id="auto-latest" checked onchange="toggleAutoLatest()"><span
          class="tooltip">Keep time at latest</span></label>
      <label><button id="view-mode" onclick="toggleViewMode()">Enable All Strikes</button><span class="tooltip">Show all
          strikes in range</span></label>
    </div>



    <div class="section">
      <h4>üßë‚Äçüíª Expert Mode</h4>
      <label>Enable: <input type="checkbox" id="expert-mode" onchange="toggleExpertMode()"><span class="tooltip">Show
          advanced options</span></label>
      <div id="expert-controls">
        <button onclick="showRectangleExportModal()">Export Strikes As PNG</button>
        <label>KML Layer: <input type="checkbox" id="kml-layer-toggle" checked onchange="toggleKMLLayer()"></label>
        <label>KML File: <input type="file" id="kml-file" accept=".kml" onchange="importKML(this)"></label>
        <label>PNG Layer: <input type="checkbox" id="png-layer-toggle" checked onchange="togglePNGLayer()"></label>
        <label>PNG File: <input type="file" id="png-file" accept=".png" onchange="importPNG(this)"></label>
        <label>PNG Opacity: <input type="range" id="png-opacity-slider" min="0" max="1" step="0.1" value="0.8"
            onchange="updatePNGOpacity()"></label>
        <label>KML Z-Index: <input type="number" id="kml-zindex" value="1" min="0" onchange="updateZIndex()"></label>
        <label>PNG Z-Index: <input type="number" id="png-zindex" value="1400" min="0" onchange="updateZIndex()"></label>
        <label>Lightning Z-Index: <input type="number" id="lightning-zindex" value="1000" min="0"
            onchange="updateZIndex()"></label>
        <label>Heatmap Z-Index: <input type="number" id="heatmap-zindex" value="70" min="0"
            onchange="updateZIndex()"></label>
        <label>Numbers Z-Index: <input type="number" id="numbers-zindex" value="1200" min="0"
            onchange="updateZIndex()"></label>
      </div>
    </div>

    <div class="section">
      <h4>üîó Useful Links</h4>
      <a href="https://handry-outlook.github.io/Convective-Outlook/lightning_strikes_chart.html"
        target="_blank"><button>Strikes Chart</button></a>
      <a href="https://handry-outlook.github.io/Convective-Outlook/interactive_map.html" target="_blank"><button>Radar &
          Forecast</button></a>
    </div>
  </div>
  <div id="map"></div>
  <div id="map-3d"></div>
  <div class="time-slider-container">
    <label><input type="range" id="history-slider" class="slider" min="0" max="360" value="360"
        oninput="updateHistory()"> <span id="history-label">Now</span></label>
    <p id="history-time"></p>
    <div class="animator">
      <button onclick="playAnimation()">‚ñ∂Ô∏è Play</button>
      <button onclick="stopAnimation()">‚èπÔ∏è Stop</button>
      <label>Speed: <input type="range" id="speed-slider" min="1" max="30" step="5" value="15"
          oninput="updateSpeedTextbox()"></label>
      <label>Min/Sec: <input type="number" id="playback-minutes" min="1" max="30" step="5" value="15"
          oninput="updateSpeedSlider()"></label>
    </div>
    <p id="time-range" class="status-info"></p>
    <div class="status-info-container">
      <p id="last-update" class="status-info"></p>
      <p id="current-time" class="status-info"></p>
    </div>
  </div>
  <button id="settings-button" onclick="toggleControls()">‚öôÔ∏è</button>
  <div id="3d-draw-modal" class="modal" style="display: none;">
    <p>Drawing is only available in 2D mode. Would you like to switch to 2D mode to draw?</p>
    <button onclick="switchTo2DForDrawing()">Switch to 2D</button>
    <button onclick="close3DDrawModal()">Cancel</button>
  </div>
  <div id="tutorial-modal" class="modal" style="display: none;">
    <h3>Tutorial</h3>
    <div id="normal-tutorial">
      <h4>Normal Mode</h4>
      <p>Use the "Start Time" and "End Time" inputs to filter lightning strikes by time, then click "Apply Filter".
        Toggle layers like "Lightning Layer", "Heatmap", and "Overlay Numbers" to visualize data. Use the slider below
        the map to view strikes within the "Lightning Lifespan" (e.g., 3 hours) from the selected time, up to the "Max
        History" hours back (left) to now (right). Adjust the "Lightning Lifespan" to control the time window of
        displayed strikes. Click "Play" to animate strikes from oldest to newest, adjust speed with the slider or
        "Minutes per Second" input (e.g., 1 = 1 minute of strikes per second), and stop to pause.</p>
      <p>Enable "Sound" to play a thunder sound for each new strike within the map's view.</p>
      <p>Enable "3D Mode" to view the map as a 3D globe with terrain using Mapbox's Handry Outlook style, occupying the
        full map container. In 3D mode, the "Heatmap" checkbox controls a 2D heatmap, and the "3D Heatmap" checkbox
        enables a 3D terrain-like surface. Both can be enabled simultaneously. Adjust "3D Heatmap Resolution" and "3D
        Heatmap Tower Height" sliders (visible only in 3D mode) for the 3D heatmap, and "Heatmap Blur" for the 2D
        heatmap. Overlay numbers, KML, and PNG layers are also supported in 3D mode.</p>
      <p>Enable "Nowcast" to display predicted lightning movement based on recent strike clusters. Nowcast shows circles
        at cluster centers and cones indicating the predicted direction of movement, colored by confidence (purple for
        very high, red for high, orange for moderate, yellow for low). This feature works in both 2D and 3D modes and
        updates dynamically when applying filters.</p>
    </div>
    <div id="expert-tutorial">
      <h4>Expert Mode</h4>
      <p>Enable "Expert Mode" to access KML and PNG uploads. Upload a KML file to overlay risk zones, or a PNG file for
        custom imagery. Toggle these layers on/off and adjust settings like "PNG Opacity" or layer z-indices to
        customize their display order in both 2D and 3D modes.</p>
      <p>For KML files, ensure polygon names match risk levels: 'Low risk', 'Slight risk', 'Enhanced risk', 'Moderate
        risk', 'High risk' for correct colors.</p>
      <p>For PNG files, the filename should include the region name (e.g., 'England', 'Wales') to set image bounds.</p>
      <p>You can also export lightning map as a png file by entering a set of coorindates or drag an area on the map by
        clicking 'Export Strikes As PNG'.</p>
    </div>
    <button onclick="closeTutorial()">Close</button>
  </div>
  <div id="modal" class="modal" style="display: none;">
    <p>Do you want to adjust the time filter based on the file's timestamp?</p>
    <button onclick="confirmAutoTimeFilter(true)">Yes</button>
    <button onclick="confirmAutoTimeFilter(false)">No</button>
  </div>
  <div id="overlay" class="overlay" style="display: none;"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0"></script>
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
  <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
  <script>
    const mapboxAccessToken = 'pk.eyJ1IjoibWV0ZW9ncm91cC1tYXBib3giLCJhIjoiY2pudWJyMWVhMDQ0bjNxdXFsNWJ5M2ZtbSJ9.ANOKYyv5s0VFVbnesnGGUQ';
    const maptilerApiKey = 'd6FiSbcpDtzJ4g4e0oD4';

    const risk_colors = {
      'Low risk': '#5aac91',
      'Slight risk': '#ffff00',
      'Enhanced risk': '#ffa500',
      'Moderate risk': '#ff0000',
      'High risk': '#800080',
      'Severe risk': '#000000' // Added Severe risk with black color
    };

    const region_bounds = {
      "England": [[47.7, -20.4], [57.075, 10.55]],
      "Wales": [[51.4, -5.3], [53.4, -2.8]],
      "Scotland": [[54.6, -7.5], [60.8, -0.7]],
      "Northern Ireland": [[49.98, -20.2], [56.25, 1.175]],
      "Ireland and Northern Ireland": [[49.98, -21.65], [56.25, 1.075]],
      "UK": [[47.8, -31.2], [61.3, 16.6]]
    };
    let is3DMode = false;
    let map, map3D;
    let baseLayers = {
      opentopo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {

        attribution: 'Map data: ¬© OpenTopoMap (CC-BY-SA)'
      }),
      custom: L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {

        attribution: '¬© OpenStreetMap'
      }),
      esri: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {

        attribution: 'Tiles ¬© Esri'
      }),
      'maptiler-streets': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.STREETS,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-outdoor': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.OUTDOOR,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-dark': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.DARK,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-light': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.LIGHT,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'mapbox-satellite': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-outdoors': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-dark': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/dark-v11/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-navigation': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-day-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-light': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/light-v11/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-streets-satellite': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-navigation-night': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-night-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-traffic-day': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/traffic-day-v2/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-traffic-night': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/traffic-night-v2/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-contrast': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/high-contrast-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      })
    };

    map = L.map('map', { layers: [baseLayers['mapbox-traffic-night']], zoomControl: false }).setView([53.5, -4.5], 6);

    map3D = new mapboxgl.Map({
      container: 'map-3d',
      style: 'mapbox://styles/handry-outlook/cm9457ty1009d01sk37353ux2',
      center: [-4.5, 53.5],
      zoom: 5,
      projection: 'globe',
      accessToken: mapboxAccessToken
    });

    map3D.on('load', () => {
      map3D.addSource('mapbox-dem', {
        'type': 'raster-dem',
        'url': 'mapbox://mapbox.terrain-rgb',
        'tileSize': 512,
        'maxzoom': 14
      });
      map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 12 });
      map3D.resize(); // Ensure 3D map is sized correctly
    });
    map.invalidateSize(); // Ensure 2D map is sized correctly

    const timeSliderContainer = document.querySelector('.time-slider-container');
    const logo = document.createElement('img');
    logo.src = 'https://raw.githubusercontent.com/Handry-Outlook/Lightning-Strike-Visualiser-/refs/heads/main/RadarLoop%20Logo.png';
    logo.className = 'logo';

    logo.style.pointerEvents = 'none';
    logo.style.zIndex = '1001'; // Ensure logo is above other elements
    document.body.appendChild(logo); // Append to body instead of map container
    // Append logo to the map container for mobile positioning


    const legendControl = L.control({ position: 'topright' });
    legendControl.onAdd = function (map) {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '<h4>Legend</h4>';
      div.style.display = 'none'; // Initially hidden

      return div;
    };
    legendControl.addTo(map);

    let strikeData = [];
    let strikeLayer = L.layerGroup().addTo(map);
    let heatmapLayer = null;
    let numberOverlay = null;
    let numberOverlay3D = [];
    let animationInterval = null;
    let currentFiltered = [];
    let animationStart, animationEnd;
    let kmlLayer = null;
    let kmlGeoJSON = null;
    let pngLayer = null;
    let pngImage = null;
    let pngBounds = null;
    let isPlaying = false;
    let strikeCircles = [];
    let pendingFile = null;
    let pendingFileType = null;
    let isFullScreen = false;
    let refreshTimer = null;
    let lastUpdateTime = null;
    let isAdjustingHistory = false;
    let lastFilterMode = 'slider';
    let customFilterStart = null;
    let customFilterEnd = null;
    let showAllStrikes = false;
    let strikeLayer3D = [];
    let heatmapLayer3D = null;
    let lastRenderedStrikes = new Set();
    let thunderAudio = new Audio('https://handry-outlook.github.io/Lightning-Strike-Visualiser-/mouse-click-117076-%5BAudioTrimmer.com%5D.mp3');
    thunderAudio.preload = 'auto';
    let soundEnabled = false;
    let lightningEffectEnabled = false;
    let lastSoundTime = 0;
    const SOUND_COOLDOWN = 50;
    let nowcastLayer = L.layerGroup();
    let nowcastLayer3D = [];
    let currentNowcasts = [];

    let minNowcastConfidence = 0.8;
    let userLocationMarker = null;
    let isLegendVisible = false;
    let lastDrawnRectangle = null; //
    let drawnItems = L.featureGroup().addTo(map);
    let drawControl;
    let drawControl3D;
    let drawnItems3D = [];
    let isDrawingEnabled = false;
    let editingLayerId = null;
    let previousNowcasts = [];

    let isFilterApplied = false;
    var polygonNowcastLayer = L.layerGroup();

    const currentTime = new Date();
    // ==========================================
    // 1. GLOBAL VARIABLE DEFINITIONS (Fixed)
    // ==========================================

    function handleSatelliteToggle() {
      const isEnabled = document.getElementById('satelliteToggle').checked;
      const currentTimestamp = getCurrentSliderTimestamp();

      // Force reset tracking vars so next plot thinks it's new
      lastSatelliteTimestamp = null;
      lastRequestedSatelliteTimestamp = null;

      if (!isEnabled) {
        // Instant off
        if (satelliteLayer && map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
          satelliteLayer = null;
        }
      }

      // ALWAYS force a full refresh at current time ‚Äî bypass debounce
      updateRadarLayer(currentTimestamp);  // This calls plotSatelliteLayer() internally

      updateLegend();
    }
    function satelliteToggleHandler() {
      const isEnabled = document.getElementById('satelliteToggle').checked;
      const timeSlider = document.getElementById('history-slider');

      // Get the current timestamp using the slider logic or Date.now() if no slider
      let timestamp = Date.now();
      if (timeSlider) {
        // Find the most recently calculated timestamp to avoid recalculating the slider
        // In a real setup, getCurrentSliderTimestamp() should return this value.
        // For now, we'll try to trigger the map update at the last known time.
        // We call the existing radarLayerTypeHandler to get the timestamp and trigger the map update.
        radarLayerTypeHandler(); // This calls the debounced triggerMapUpdate(timestamp)
      } else {
        // If no slider, just update at the current time, but force it to run immediately.
        triggerMapUpdate.call(null, timestamp, true); // Pass 'true' to force immediate execution
      }

      if (!isEnabled) {
        // --- INSTANT OFF: Always remove the layer immediately on uncheck ---
        if (satelliteLayer && map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
          satelliteLayer = null;
        }
        lastSatelliteTimestamp = null;
        lastRequestedSatelliteTimestamp = null;
      }

      updateLegend();
    }
    function handleRadarChange() {
      const radarType = document.getElementById('radarLayer').value;

      if (radarType === 'none') {
        // Instantly remove radar
        if (radarLayer && map.hasLayer(radarLayer)) {
          map.removeLayer(radarLayer);
          radarLayer = null;
        }
        lastRadarTimestamp = null;
        lastRadarType = null;
      } else {
        // Instantly update radar at current time
        const currentTimestamp = getCurrentSliderTimestamp();
        updateRadarLayer(currentTimestamp);
      }

      updateLegend();
    }
    const radarOptions = {
      'uk-precip-intensity': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-intensity-uk-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null
      },
      'uk-precip-type': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-type-uk-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null
      },
      'europe-precip-intensity': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-intensity-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 15 * 60 * 1000,
        type: 'vector-tile',
        bounds: null
      },
      'europe-precip-type': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-type-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 15 * 60 * 1000,
        type: 'vector-tile',
        bounds: null
      },
      'uk-precip-intensity-pixelated': {
        url: 'https://maps.consumer-digital.api.metoffice.gov.uk/wms_ob/single/high-res/rainfall_radar/${iso}.png',
        interval: 5 * 60 * 1000,
        type: 'image',
        bounds: [[44.02, -25], [64, 16]]
      },
      'uk-precip-intensity-accessible': {
        url: 'https://maps.consumer-digital.api.metoffice.gov.uk/wms_ob/single/high-res/rainfall_radar_accessible/${iso}.png',
        interval: 5 * 60 * 1000,
        type: 'image',
        bounds: [[44.02, -25], [64, 16]]
      }
    };

    // DIRECT URL: Using direct satellite URL 
    const satelliteOptions = {
      url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.mg.global-composite_data_ir.WeatherPro/${iso}/${iso}/{z}/{x}/{y}.png',
      interval: 10 * 60 * 1000,
      type: 'tile-layer'
    };


    // --- GLOBAL STATE VARIABLES ---
    let radarLayer = null;
    let satelliteLayer = null;
    let isPlotting = false;
    let lastRadarTimestamp = null;
    let lastRadarType = null;
    let lastSatelliteTimestamp = null;

    let isSatelliteAnimating = false;
    let lastRequestedSatelliteTimestamp = null;
    let isRadarAnimating = false;

    const sixDaysInMs = 7 * 24 * 60 * 60 * 1000;
    let lastValidTileUrls = {};
    const radarValidationCache = new Map();


    // ==========================================
    // 2. HELPER FUNCTIONS
    // ==========================================

    // --- REVISED DEBOUNCE FUNCTION (Allows immediate execution) ---
    function debounce(func, delay) {
      let timeoutId;
      return function (/* timestamp */ ...args) {
        const context = this;
        const forceExecute = args.length > 1 && args[1] === true; // Check for our new 'force' argument

        clearTimeout(timeoutId);

        if (forceExecute) {
          // Execute immediately and clear any planned execution
          func.apply(context, [args[0]]); // Pass only the timestamp
          timeoutId = null;
        } else {
          // Standard debounced execution
          timeoutId = setTimeout(() => {
            func.apply(context, args);
          }, delay);
        }
      };
    }


    // RENAMED and UPDATED for two sliders
    function updateLegend() {
      const radarOpacity = parseFloat(document.getElementById('radarOpacity')?.value || 0.8);
      const satelliteOpacity = parseFloat(document.getElementById('satelliteOpacity')?.value || 0.8);

      document.getElementById('opacity-value-radar').textContent = `Radar Opacity: ${radarOpacity.toFixed(1)}`;
      document.getElementById('opacity-value-satellite').textContent = `Satellite Opacity: ${satelliteOpacity.toFixed(1)}`;
    }

    // ==========================================
    // 3. IMAGE/TILE FETCHING LOGIC (Unchanged)
    // ==========================================

    const recentTimeThreshold = 15 * 60 * 1000;

    async function fetchTileUrl(timestamp, layerConfig, isPrefetch = false) {
      const radarType = layerConfig === satelliteOptions ? 'satellite' : Object.keys(radarOptions).find(key => radarOptions[key] === layerConfig);

      if (layerConfig.type === 'tile-layer') {
        const date = new Date(timestamp);
        const formatISO = (d) => d.toISOString().replace(/\.\d{3}Z$/, 'Z');
        return layerConfig.url.replace(/\${iso}/g, formatISO(date));
      }

      const cacheKey = `${radarType}_${timestamp}`;
      if (Date.now() - timestamp < recentTimeThreshold) {
        radarValidationCache.delete(cacheKey);
      }
      if (radarValidationCache.has(cacheKey)) {
        return radarValidationCache.get(cacheKey);
      }

      const cacheAndReturn = (result) => {
        if (Date.now() - timestamp >= recentTimeThreshold) {
          radarValidationCache.set(cacheKey, result);
        }
        return result;
      };

      if (typeof timestamp !== 'number' || isNaN(timestamp)) {
        return cacheAndReturn(lastValidTileUrls[radarType] || null);
      }

      const date = new Date(timestamp);
      const interval = layerConfig.interval || 5 * 60 * 1000;

      date.setMinutes(Math.floor(date.getMinutes() / (interval / 60 / 1000)) * (interval / 60 / 1000));
      date.setSeconds(0);
      date.setMilliseconds(0);

      let minTime = new Date(Date.now() - sixDaysInMs);
      let maxTime = new Date(Date.now());

      const formatISO = (d) => d.toISOString().replace(/\.\d{3}Z$/, 'Z');
      let currentTime = new Date(date);
      const maxAttempts = layerConfig.type === 'image' ? 4 : 288;

      if (layerConfig.type === 'image') {
        for (let attempt = 0; attempt < maxAttempts && currentTime >= minTime; attempt++) {
          const url = layerConfig.url.replace(/\${iso}/g, formatISO(currentTime));
          const img = new Image();
          img.src = url;

          const isValid = await new Promise((resolve) => {
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            setTimeout(() => resolve(false), 5000);
          });

          if (isValid) {
            lastValidTileUrls[radarType] = url;
            return cacheAndReturn(url);
          }
          currentTime.setMinutes(currentTime.getMinutes() - (interval / 60 / 1000));
        }
        return cacheAndReturn(lastValidTileUrls[radarType] || null);
      } else {
        // Tile Logic (Vector Tiles)
        async function validateTile(checkTime) {
          if (checkTime < minTime || checkTime > maxTime) return null;
          const iso = formatISO(checkTime);
          const tileUrl = layerConfig.url.replace(/\${iso}/g, iso);

          const checkUrl = tileUrl.replace('{z}/{x}/{y}', '0/0/0');

          for (let retry = 0; retry < 2; retry++) {
            try {
              const response = await fetch(checkUrl, { method: 'GET' });

              if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                if (arrayBuffer.byteLength > 0) {
                  return tileUrl.replace(/\${iso}/g, iso);
                }
              }
            } catch (error) {
              // Ignore error
            }
          }
          return null;
        }

        for (let i = 0; i < maxAttempts; i++) {
          const checkTime = new Date(currentTime.getTime() - i * interval);
          const tileUrl = await validateTile(checkTime);
          if (tileUrl) {
            lastValidTileUrls[radarType] = tileUrl;
            return cacheAndReturn(tileUrl);
          }
        }

        if (lastValidTileUrls[radarType]) {
          return cacheAndReturn(lastValidTileUrls[radarType]);
        }

        return cacheAndReturn(null);
      }
    }

    // ==========================================
    // 4. MAIN UPDATE FUNCTIONS
    // ==========================================

    // UPDATED: Reads the specific satellite opacity value
    async function plotSatelliteLayer(timestamp) {
      const isEnabled = document.getElementById('satelliteToggle')?.checked;
      const layerToDispose = satelliteLayer;

      const interval = satelliteOptions.interval;
      const roundedDate = new Date(timestamp);
      roundedDate.setMinutes(Math.floor(roundedDate.getMinutes() / (interval / 60 / 1000)) * (interval / 60 / 1000));
      roundedDate.setSeconds(0);
      roundedDate.setMilliseconds(0);
      const roundedTimestampMs = roundedDate.getTime();

      lastRequestedSatelliteTimestamp = roundedTimestampMs;

      if (!isEnabled) {
        if (satelliteLayer && map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
          satelliteLayer = null;
        }
        lastSatelliteTimestamp = null;
        lastRequestedSatelliteTimestamp = null;
        return;
      }

      if (lastSatelliteTimestamp === roundedTimestampMs && satelliteLayer) return;

      if (isSatelliteAnimating) {
        return;
      }

      isSatelliteAnimating = true;
      let newSatelliteLayer = null;

      try {
        const finalUrl = await fetchTileUrl(roundedTimestampMs, satelliteOptions);

        if (!finalUrl) {
          return;
        }

        // --- CHANGE 1: Use satelliteOpacity for initial opacity ---
        const currentSatelliteOpacity = parseFloat(document.getElementById('satelliteOpacity')?.value || 0.8);
        const SATELLITE_Z_INDEX = 140;

        newSatelliteLayer = L.tileLayer(finalUrl, {
          opacity: 0, // Start invisible 
          zIndex: SATELLITE_Z_INDEX,
          attribution: 'DTN Meteoguard',
          tms: true,
          tileSize: 256,
          className: 'satellite-layer'
        });

        newSatelliteLayer.addTo(map);

        const layerLoadedPromise = new Promise(resolve => {
          const timeout = setTimeout(() => {
            resolve(true);
          }, 1000);

          newSatelliteLayer.once('load', () => {
            clearTimeout(timeout);
            resolve(true);
          });
          newSatelliteLayer.once('error', () => {
            clearTimeout(timeout);
            resolve(false);
          });
        });

        const success = await layerLoadedPromise;

        if (roundedTimestampMs === lastRequestedSatelliteTimestamp) {
          if (success) {
            if (layerToDispose && map.hasLayer(layerToDispose)) {
              map.removeLayer(layerToDispose);
            }

            satelliteLayer = newSatelliteLayer;
            // --- CHANGE 2: Apply the current satellite opacity ---
            satelliteLayer.setOpacity(currentSatelliteOpacity);
            lastSatelliteTimestamp = roundedTimestampMs;
          } else {
            if (newSatelliteLayer && map.hasLayer(newSatelliteLayer)) {
              map.removeLayer(newSatelliteLayer);
            }
          }
        } else {
          if (newSatelliteLayer && map.hasLayer(newSatelliteLayer)) {
            map.removeLayer(newSatelliteLayer);
          }
        }

      } catch (error) {
        console.error("Critical error during satellite layer creation:", error);
        if (newSatelliteLayer && map.hasLayer(newSatelliteLayer)) {
          map.removeLayer(newSatelliteLayer);
        }
      } finally {
        isSatelliteAnimating = false;
      }
    }


    async function updateRadarLayer(timestamp) {
      if (isPlotting) return;

      const radarType = document.getElementById('radarLayer').value;
      const PROCESSING_DELAY_MS = 5 * 60 * 1000;

      let targetTimestamp = timestamp;
      const timeSlider = document.getElementById('history-slider');

      if (timeSlider && timeSlider.value === timeSlider.max) {
        targetTimestamp = Date.now() - PROCESSING_DELAY_MS;
      }

      await plotSatelliteLayer(targetTimestamp);

      if (radarType === 'none') {
        if (radarLayer) {
          map.removeLayer(radarLayer);
          radarLayer = null;
        }
        lastRadarTimestamp = null;
        updateLegend();
        return;
      }

      const layerConfig = radarOptions[radarType];
      const interval = layerConfig.interval;

      const roundedDate = new Date(targetTimestamp);
      roundedDate.setMinutes(Math.floor(roundedDate.getMinutes() / (interval / 60 / 1000)) * (interval / 60 / 1000));
      roundedDate.setSeconds(0);
      roundedDate.setMilliseconds(0);
      const roundedTimestampMs = roundedDate.getTime();

      if (lastRadarTimestamp === roundedTimestampMs && lastRadarType === radarType) return;

      if (isRadarAnimating) return;
      isRadarAnimating = true;

      isPlotting = true;

      try {
        const radarUrls = await Promise.all([
          fetchTileUrl(roundedTimestampMs, layerConfig).catch(() => null),
          fetchTileUrl(roundedTimestampMs - interval, layerConfig, true).catch(() => null),
          fetchTileUrl(roundedTimestampMs - 2 * interval, layerConfig, true).catch(() => null)
        ]);

        const [currentRadarUrl, previousRadarUrl1, previousRadarUrl2] = radarUrls;

        let finalUrl = currentRadarUrl;
        let finalTimestamp = roundedTimestampMs;

        if (!finalUrl) {
          if (previousRadarUrl1) {
            finalUrl = previousRadarUrl1;
            finalTimestamp = roundedTimestampMs - interval;
          } else if (previousRadarUrl2) {
            finalUrl = previousRadarUrl2;
            finalTimestamp = roundedTimestampMs - 2 * interval;
          } else if (lastValidTileUrls[radarType]) {
            finalUrl = lastValidTileUrls[radarType];
            finalTimestamp = lastRadarTimestamp;
          } else {
            if (radarLayer) { map.removeLayer(radarLayer); radarLayer = null; }
            updateLegend();
            return;
          }
        }

        await plotMainRadarLayer(finalUrl, radarType, finalTimestamp);

      } catch (error) {
        console.error("UpdateRadarLayer failed:", error);
      } finally {
        isPlotting = false;
        isRadarAnimating = false;
      }
      updateLegend();
    }


    // ====================================================================
    // 5. PLOTTING FUNCTION for MAIN RADAR (Runs on top of satellite)
    // ====================================================================

    // UPDATED: Reads the specific radar opacity value
    async function plotMainRadarLayer(radarUrl, radarType, timestamp) {
      // --- CHANGE 3: Use radarOpacity for initial opacity ---
      const currentRadarOpacity = parseFloat(document.getElementById('radarOpacity')?.value || 0.8);
      let newRadarLayer = null;
      const options = radarOptions[radarType];

      const RADAR_Z_INDEX = 150;
      const layerToDispose = radarLayer;

      try {
        if (options.type === 'image') {
          newRadarLayer = L.imageOverlay(radarUrl, options.bounds, {
            opacity: 0, // Start invisible
            zIndex: RADAR_Z_INDEX,
            attribution: 'Met Office',
            className: 'smooth-raster'
          });

        } else if (options.type === 'vector-tile') {
          try {
            // Vector layers must be created with the correct opacity in the style definitions
            newRadarLayer = L.vectorGrid.protobuf(radarUrl, {
              vectorTileLayerStyles: {
                'default': { fill: true, opacity: currentRadarOpacity, fillOpacity: currentRadarOpacity, weight: 0, color: 'inherit' },
                [radarType]: { fill: true, opacity: currentRadarOpacity, fillOpacity: currentRadarOpacity, weight: 0, color: 'inherit' },
                'features': { fill: true, opacity: currentRadarOpacity, fillOpacity: currentRadarOpacity, weight: 0, color: 'inherit' }
              },
              rendererFactory: L.canvas.tile,
              zIndex: RADAR_Z_INDEX,
              interactive: false,
            });
            newRadarLayer.on('error', (e) => console.error('Vector tile layer error:', e));

          } catch (error) {
            // Fallback to L.tileLayer
            newRadarLayer = L.tileLayer(radarUrl, {
              opacity: currentRadarOpacity, zIndex: RADAR_Z_INDEX, attribution: 'DTN Meteoguard'
            });
          }
        }

        if (!newRadarLayer) return;

        newRadarLayer.addTo(map);

        const layerLoadedPromise = new Promise(resolve => {
          const timeout = setTimeout(() => { resolve(true); }, 500);

          newRadarLayer.once('load', () => {
            clearTimeout(timeout);
            resolve(true);
          });
          newRadarLayer.once('error', (e) => {
            clearTimeout(timeout);
            resolve(false);
          });
        });

        const success = await layerLoadedPromise;

        if (success) {
          if (layerToDispose && map.hasLayer(layerToDispose)) {
            map.removeLayer(layerToDispose);
          }

          radarLayer = newRadarLayer;

          // --- CHANGE 4: Apply the opacity for raster types after swap ---
          if (options.type === 'image') {
            const imgElement = radarLayer.getElement();
            if (imgElement) imgElement.style.opacity = currentRadarOpacity;
          } else if (radarLayer.setOpacity) {
            // For fallback L.tileLayer
            radarLayer.setOpacity(currentRadarOpacity);
          }

          lastValidTileUrls[radarType] = radarUrl;
          lastRadarTimestamp = timestamp || lastRadarTimestamp;
          lastRadarType = radarType;
        } else {
          if (newRadarLayer && map.hasLayer(newRadarLayer)) {
            map.removeLayer(newRadarLayer);
          }
        }


      } catch (error) {
        console.error("Critical plotting error during layer creation/swap:", error);
        if (newRadarLayer && map.hasLayer(newRadarLayer)) {
          map.removeLayer(newRadarLayer);
        }
      }
    }

    // ==========================================
    // 6. UTILITY AND EVENT HANDLERS
    // ==========================================

    function clearRadarLayers() {
      if (radarLayer) {
        map.removeLayer(radarLayer);
        radarLayer = null;
      }
      lastRadarTimestamp = null;
      lastRadarType = null;
    }

    // RENAMED and UPDATED: Handler for BOTH Opacity Sliders
    function updateLayerOpacities() {
      const radarOpacity = parseFloat(document.getElementById('radarOpacity')?.value || 0.8);
      const satelliteOpacity = parseFloat(document.getElementById('satelliteOpacity')?.value || 0.8);

      // Apply radar layer opacity
      if (radarLayer) {
        if (radarLayer.setOpacity) {
          radarLayer.setOpacity(radarOpacity);
        } else if (radarLayer.getElement) {
          const imgElement = radarLayer.getElement();
          if (imgElement) imgElement.style.opacity = radarOpacity;
        }
        // Note: L.vectorGrid.protobuf does not support setOpacity. Changes are applied on layer recreation.
      }

      // Apply satellite layer opacity
      if (satelliteLayer) {
        satelliteLayer.setOpacity(satelliteOpacity);
      }

      updateLegend();
    }

    // Debounced function that actually calls the heavy updateRadarLayer
    const triggerMapUpdate = debounce((timestamp) => {
      const radarTypeElement = document.getElementById('radarLayer');
      const isRadarEnabled = radarTypeElement.value !== 'none';
      const isSatelliteEnabled = document.getElementById('satelliteToggle')?.checked;

      // CASE 1: Nothing enabled ‚Üí remove everything
      if (!isRadarEnabled && !isSatelliteEnabled) {
        clearRadarLayers(); // removes radar
        if (satelliteLayer && map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
          satelliteLayer = null;
          lastSatelliteTimestamp = null;
        }
        updateLegend();
        return;
      }

      // CASE 2: At least one layer enabled ‚Üí update normally
      // This will respect the satellite toggle inside plotSatelliteLayer
      updateRadarLayer(timestamp);

      updateLegend();
    }, 100);

    function handleTimeSliderChange(event) {
      const historySlider = event.target;
      const rawValue = historySlider.value;
      const sliderMax = parseInt(historySlider.getAttribute('max') || 100, 10);
      const sliderValue = parseFloat(rawValue);

      const maxHistoryHours = 6;
      const maxHistoryMs = maxHistoryHours * 60 * 60 * 1000;
      const normalizedValue = (sliderMax - sliderValue) / sliderMax;
      const timestamp = Date.now() - normalizedValue * maxHistoryMs;

      const timeDisplay = document.getElementById('history-time');
      if (timeDisplay) {
        timeDisplay.innerText = new Date(timestamp).toLocaleString('en-GB', {
          timeZone: 'Europe/London',
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }) + ' BST';
      }

      triggerMapUpdate(timestamp);
    }

    function radarLayerTypeHandler() {
      const timeSlider = document.getElementById('history-slider');
      if (timeSlider) {
        handleTimeSliderChange({ target: timeSlider });
      } else {
        triggerMapUpdate(Date.now());
      }
    }

    // --- Updated Event Handler (Replace your existing satelliteVisibilityHandler) ---
    function satelliteVisibilityHandler() {
      const isEnabled = document.getElementById('satelliteToggle').checked;
      const currentTimestamp = getCurrentSliderTimestamp(); // Assuming this is defined globally

      if (!isEnabled) {
        // --- INSTANT OFF ---
        if (satelliteLayer && map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
          satelliteLayer = null;
        }
        lastSatelliteTimestamp = null;
        lastRequestedSatelliteTimestamp = null;
        updateLegend(); // Update opacity text/legend instantly
        return; // Don't proceed to plot or trigger the debounced update
      }

      // --- INSTANT ON (Bypass debounce for immediate visual feedback) ---
      // Force a full refresh at current time - this calls plotSatelliteLayer() immediately.
      // Note: We should call plotSatelliteLayer directly, not updateRadarLayer.
      // Since plotSatelliteLayer requires a timestamp and fetch logic, 
      // we need to call the final plotting function directly.

      // Force reset tracking vars so next plot thinks it's new
      lastSatelliteTimestamp = null;
      lastRequestedSatelliteTimestamp = null;

      // Get the current time on the slider
      const timeSlider = document.getElementById('history-slider');
      let timestamp = Date.now();
      if (timeSlider) {
        // Recalculate timestamp from slider logic for accuracy
        const maxHistoryHours = 6; // Use the value defined elsewhere
        const maxHistoryMs = maxHistoryHours * 60 * 60 * 1000;
        const sliderMax = parseInt(timeSlider.getAttribute('max') || 100, 10);
        const normalizedValue = (sliderMax - parseFloat(timeSlider.value)) / sliderMax;
        timestamp = Date.now() - normalizedValue * maxHistoryMs;
      }

      // Call the plot function directly and non-debounced
      plotSatelliteLayer(timestamp);

      updateLegend();

      // OPTIONAL: Still trigger the debounced update for radar/other layers if needed, 
      // but only after the sat layer is confirmed to be rendering immediately.
      // triggerMapUpdate(timestamp); 
    }


    // --- INITIALIZATION AND EVENT ATTACHMENT ---
    document.addEventListener('DOMContentLoaded', () => {
      const timeSlider = document.getElementById('history-slider');
      const radarOpacitySlider = document.getElementById('radarOpacity');
      const satelliteOpacitySlider = document.getElementById('satelliteOpacity');
      const radarLayerType = document.getElementById('radarLayer');
      const satelliteToggle = document.getElementById('satelliteToggle');

      if (timeSlider) {
        timeSlider.addEventListener('input', handleTimeSliderChange);
      }

      // Attach handler to BOTH new opacity sliders
      if (radarOpacitySlider) {
        radarOpacitySlider.addEventListener('input', updateLayerOpacities);
      }
      if (satelliteOpacitySlider) {
        satelliteOpacitySlider.addEventListener('input', updateLayerOpacities);
      }

      if (radarLayerType) {
        radarLayerType.addEventListener('change', radarLayerTypeHandler);
      }
      if (satelliteToggle) {
        // Replace the original 'onchange="updateOverlay(currentFiltered)"' logic
        // with the new, non-debounced handler logic.
        satelliteToggle.addEventListener('change', satelliteToggleHandler);
      }
      // Initial Load - Set up the UI and trigger the first map update
      updateLegend(); // Initialize opacity text display
      if (timeSlider) {
        handleTimeSliderChange({ target: timeSlider });
      } else {
        triggerMapUpdate(Date.now());
      }
    });





















    // Function to move legend between 2D and 3D map containers
    function updateLegendContainer() {
      const legendElement = document.querySelector('.legend');
      if (!legendElement) return;

      if (is3DMode) {
        // Move legend to 3D map container
        const map3DContainer = document.getElementById('map-3d');
        map3DContainer.appendChild(legendElement);
        legendElement.style.position = 'absolute';
        legendElement.style.top = '10px';
        legendElement.style.right = '10px';
        legendElement.style.zIndex = '1010';
      } else {
        // Move legend back to 2D map container
        const mapContainer = document.getElementById('map');
        mapContainer.appendChild(legendElement);
        legendElement.style.position = 'absolute';
        legendElement.style.top = '10px';
        legendElement.style.right = '10px';
        legendElement.style.zIndex = '1010';
      }

      // Ensure legend visibility matches toggle state
      legendElement.style.display = isLegendVisible ? 'block' : 'none';
    }

    // Update toggleLegend to sync visibility
    function toggleLegend() {
      isLegendVisible = !isLegendVisible;
      const legendElement = document.querySelector('.legend');
      if (legendElement) {
        legendElement.style.display = isLegendVisible ? 'block' : 'none';
      }
      updateLegendContainer(); // Ensure correct container
    }

    // Modify toggle3DMode to update legend container
    function toggle3DMode() {
      is3DMode = !is3DMode;
      document.body.classList.toggle('three-d-mode', is3DMode);
      if (is3DMode) {
        document.getElementById('map').style.opacity = '0';
        document.getElementById('map').style.pointerEvents = 'none';
        document.getElementById('map-3d').style.display = 'block';
        document.getElementById('map-3d').style.opacity = '1';
        map3D.resize();
        update3DView();
      } else {
        document.getElementById('map').style.opacity = '1';
        document.getElementById('map').style.pointerEvents = 'auto';
        document.getElementById('map-3d').style.display = 'none';
        document.getElementById('map-3d').style.opacity = '0';
        map.invalidateSize();
      }
      updateLegendContainer(); // Move legend to correct container
      updateZIndex();
      updateLegend();
    }
    function initializeRectangleExport() {
      // Add Export Rectangle Strikes button
      const exportButton = document.createElement('button');
      exportButton.textContent = 'Export Rectangle Strikes';
      exportButton.onclick = showRectangleExportModal;
      const expertControls = document.getElementById('expert-controls');
      if (expertControls && !expertControls.querySelector('button[onclick="showRectangleExportModal()"]')) {
        expertControls.appendChild(exportButton);
      }

      // Rectangle drawing for 2D mode
      map.on(L.Draw.Event.CREATED, function (e) {
        if (e.layerType === 'rectangle') {
          const layer = e.layer;
          const bounds = layer.getBounds();
          const coords = [
            [bounds.getSouthWest().lat, bounds.getSouthWest().lng],
            [bounds.getSouthEast().lat, bounds.getSouthEast().lng],
            [bounds.getNorthEast().lat, bounds.getNorthEast().lng],
            [bounds.getNorthWest().lat, bounds.getNorthWest().lng]
          ];
          lastDrawnRectangle = layer; // Store the rectangle layer
          drawnItems.addLayer(layer);
          console.log('Rectangle Coords:', coords);
          console.log('lastDrawnRectangle set:', lastDrawnRectangle);
          showTimeFilterModalForExport(coords);
        }
      });

      // Handle rectangle deletion
      map.on(L.Draw.Event.DELETED, function (e) {
        if (lastDrawnRectangle && !drawnItems.hasLayer(lastDrawnRectangle)) {
          console.log('lastDrawnRectangle cleared due to deletion');
          lastDrawnRectangle = null;
        }
      });

      // Initialize drawControl
      drawControl = new L.Control.Draw({
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            drawError: { color: '#b00b00', timeout: 1000 },
            shapeOptions: { color: risk_colors['Low risk'], weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          rectangle: {
            shapeOptions: { color: '#3b82f6', weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          polyline: false,
          circle: false,
          marker: false,
          circlemarker: false
        },
        edit: {
          featureGroup: drawnItems,
          remove: true
        }
      });
      map.addControl(drawControl);
    }

    function showRectangleExportModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
    <h3>Export Lightning Strikes</h3>
    <p>Choose how to define the rectangle area:</p>
    <button onclick="drawRectangleOnMap()">Draw on Map</button>
    <p>Or enter bounding coordinates:</p>
    <label>North (lat): <input type="text" id="north-coord" placeholder="e.g., 53.0"></label>
    <label>South (lat): <input type="text" id="south-coord" placeholder="e.g., 51.0"></label>
    <label>East (lng): <input type="text" id="east-coord" placeholder="e.g., 1.0"></label>
    <label>West (lng): <input type="text" id="west-coord" placeholder="e.g., -1.0"></label>
    <button onclick="validateCoordinates()">Next</button>
    <button onclick="closeModal()">Cancel</button>
  `;
      document.body.appendChild(modal);
      document.getElementById('overlay').style.display = 'block';
    }

    function drawRectangleOnMap() {
      closeModal();
      // Clear any existing rectangles
      if (lastDrawnRectangle) {
        drawnItems.removeLayer(lastDrawnRectangle);
        lastDrawnRectangle = null;
        console.log('Cleared existing rectangle');
      }
      if (drawControl && drawControl._toolbars.draw._modes.rectangle) {
        drawControl._toolbars.draw._modes.rectangle.handler.enable();
      } else {
        alert('Drawing is not available. Please ensure Expert Mode is enabled.');
      }
    }

    function validateCoordinates() {
      const north = parseFloat(document.getElementById('north-coord').value);
      const south = parseFloat(document.getElementById('south-coord').value);
      const east = parseFloat(document.getElementById('east-coord').value);
      const west = parseFloat(document.getElementById('west-coord').value);

      if (isNaN(north) || isNaN(south) || isNaN(east) || isNaN(west)) {
        alert('Please enter valid numeric coordinates.');
        return;
      }

      if (north <= south || east <= west) {
        alert('North must be greater than South, and East must be greater than West.');
        return;
      }

      const coords = [
        [south, west], // SW
        [south, east], // SE
        [north, east], // NE
        [north, west]  // NW
      ];
      console.log('Coordinate Input Coords:', coords);
      closeModal();
      showTimeFilterModalForExport(coords);
    }

    function showTimeFilterModalForExport(coords) {
      document.querySelectorAll('.modal').forEach(modal => modal.remove());

      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
    <h3>Time Filter & Color Options</h3>
    <label>Start Time: <input type="datetime-local" id="export-start-time"></label>
    <label>End Time: <input type="datetime-local" id="export-end-time"></label>
    <label>Color by Age: <input type="checkbox" id="export-color-mode" checked="checked"></label>
    <button id="export-png-button">Export PNG</button>
    <button onclick="closeModal()">Cancel</button>
  `;
      document.body.appendChild(modal);
      document.getElementById('overlay').style.display = 'block';

      const exportButton = document.getElementById('export-png-button');
      if (exportButton) {
        console.log('Export PNG button found, attaching listener');
        exportButton.addEventListener('click', () => {
          console.log('Export PNG button clicked, coords:', coords);
          const startInput = document.getElementById('export-start-time');
          const endInput = document.getElementById('export-end-time');
          console.log('Start Input Element:', startInput);
          console.log('End Input Element:', endInput);
          console.log('Start Time Value:', startInput?.value);
          console.log('End Time Value:', endInput?.value);
          exportStrikesToPNG(coords);
        });
      } else {
        console.error('Export PNG button not found');
        alert('Error: Export button not found. Please try again.');
      }

      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      if (startInput) {
        startInput.addEventListener('change', (e) => {
          console.log('Start Time Changed:', e.target.value);
        });
      }
      if (endInput) {
        endInput.addEventListener('change', (e) => {
          console.log('End Time Changed:', e.target.value);
        });
      }
    }

    function exportStrikesToPNG(coords) {
      console.log('exportStrikesToPNG called with coords:', coords);

      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      const startTimeInput = startInput?.value;
      const endTimeInput = endInput?.value;
      const colorMode = document.getElementById('export-color-mode')?.checked;

      console.log('Start Time Input:', startTimeInput);
      console.log('End Time Input:', endTimeInput);
      console.log('Color Mode:', colorMode);

      if (!startTimeInput || !endTimeInput) {
        console.error('Time inputs are empty:', startTimeInput, endTimeInput);
        alert('Please select both start and end times.');
        closeModal();
        return;
      }

      const startTime = new Date(startTimeInput);
      const endTime = new Date(endTimeInput);

      if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
        console.error('Invalid time inputs:', startTimeInput, endTimeInput);
        alert('Please select valid start and end times.');
        closeModal();
        return;
      }

      if (endTime <= startTime) {
        console.error('End time is not after start time:', startTime, endTime);
        alert('End time must be after start time.');
        closeModal();
        return;
      }

      if (!coords || !Array.isArray(coords) || coords.length !== 4 || coords.some(coord => !Array.isArray(coord) || coord.length !== 2)) {
        console.error('Invalid coords format:', coords);
        alert('Error: Invalid rectangle coordinates. Please try again.');
        closeModal();
        return;
      }

      let bounds;
      try {
        bounds = L.latLngBounds(coords);
      } catch (error) {
        console.error('Failed to create bounds:', error, coords);
        alert('Error: Invalid rectangle bounds. Please try again.');
        closeModal();
        return;
      }

      // Calculate pixel dimensions of the selected area
      let width, height;
      if (lastDrawnRectangle) {
        // For drawn rectangle, use pixel coordinates directly
        const rectangleBounds = lastDrawnRectangle.getBounds();
        const topLeft = map.latLngToContainerPoint(rectangleBounds.getNorthWest());
        const bottomRight = map.latLngToContainerPoint(rectangleBounds.getSouthEast());
        width = Math.abs(bottomRight.x - topLeft.x);
        height = Math.abs(bottomRight.y - topLeft.y);
      } else {
        // For manually entered coordinates, project bounds to pixel coordinates
        const topLeft = map.latLngToContainerPoint(bounds.getNorthWest());
        const bottomRight = map.latLngToContainerPoint(bounds.getSouthEast());
        width = Math.abs(bottomRight.x - topLeft.x);
        height = Math.abs(bottomRight.y - topLeft.y);
      }

      // Ensure dimensions are positive and reasonable
      if (width <= 0 || height <= 0 || width > 10000 || height > 10000) {
        console.error('Invalid canvas dimensions:', width, height);
        alert('Error: Invalid area dimensions. Please select a valid area.');
        closeModal();
        return;
      }

      // Round dimensions to integers for canvas
      width = Math.round(width);
      height = Math.round(height);
      console.log('Calculated pixel dimensions:', { width, height });

      // Create a canvas with the exact pixel dimensions
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Set background (transparent)
      ctx.fillStyle = 'rgba(255, 255, 255, 0)';
      ctx.fillRect(0, 0, width, height);

      // Filter strikes within the time range and bounds
      const filteredStrikes = strikeData.filter(s => {
        const strikeTime = new Date(s.time);
        const withinTime = strikeTime >= startTime && strikeTime <= endTime;
        const withinBounds = bounds.contains([s.coordinates[1], s.coordinates[0]]);
        return withinTime && withinBounds;
      });

      console.log('Filtered strikes:', filteredStrikes.length);

      // Map geographic coordinates to canvas coordinates
      filteredStrikes.forEach(s => {
        const lat = s.coordinates[1];
        const lng = s.coordinates[0];

        // Convert lat/lng to pixel coordinates relative to the bounds
        const point = map.latLngToContainerPoint([lat, lng]);
        const topLeft = map.latLngToContainerPoint(bounds.getNorthWest());

        // Translate to canvas coordinates (origin at top-left of canvas)
        const x = point.x - topLeft.x;
        const y = point.y - topLeft.y;

        // Calculate color based on age if enabled
        let color = 'black';
        if (colorMode) {
          const ageFraction = (endTime - new Date(s.time)) / ((endTime - startTime) || 1);
          color = getColorFromAge(ageFraction);
        }

        // Draw strike as a circle
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI); // 5-pixel radius
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Convert canvas to PNG and trigger download
      const dataUrl = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = `lightning_strikes_${startTime.toISOString()}_${endTime.toISOString()}.png`;
      link.click();

      console.log('PNG exported with dimensions:', width, 'x', height);

      // Remove the drawn rectangle if it exists
      if (lastDrawnRectangle) {
        drawnItems.removeLayer(lastDrawnRectangle);
        console.log('Removed lastDrawnRectangle from map');
        lastDrawnRectangle = null;
      }

      closeModal();
    }
    function closeModal() {
      document.querySelectorAll('.modal').forEach(modal => modal.remove());
      document.getElementById('overlay').style.display = 'none';
      if (drawControl && drawControl._toolbars.draw._modes.rectangle.handler) {
        drawControl._toolbars.draw._modes.rectangle.handler.disable();
      }
    }

    // Initialize rectangle export functionality
    initializeRectangleExport();
    // Initialize Leaflet.draw for 2D mode
    function initializeDrawControl() {
      // Initialize drawnItems if not already defined
      if (!drawnItems) {
        drawnItems = L.featureGroup().addTo(map);
      }

      // Remove existing drawControl if it exists to prevent conflicts
      if (drawControl) {
        map.removeControl(drawControl);
      }

      drawControl = new L.Control.Draw({
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            drawError: { color: '#b00b00', timeout: 1000 },
            shapeOptions: { color: risk_colors['Low risk'], weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          rectangle: {
            shapeOptions: { color: '#3b82f6', weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          polyline: false,
          circle: false,
          marker: false,
          circlemarker: false
        },
        edit: {
          featureGroup: drawnItems,
          remove: true
        }
      });
      map.addControl(drawControl);

      map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        if (e.layerType === 'polygon') {
          const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
          layer.feature = { type: 'Feature', properties: { name: riskLevel, source: 'leaflet' } };
          layer.setStyle({
            color: risk_colors[riskLevel],
            fillColor: risk_colors[riskLevel] === risk_colors['Severe risk'] ? 'transparent' : risk_colors[riskLevel],
            fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
            weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
          });
          layer._leaflet_id = layer._leaflet_id || `leaflet-${Date.now()}`;
          drawnItems.addLayer(layer);
          addPolygonPopup(layer);
          if (is3DMode) syncPolygonsTo3D();
          updateLegend();
          console.log('Created 2D polygon:', layer._leaflet_id, layer.toGeoJSON());
        } else if (e.layerType === 'rectangle') {
          const bounds = layer.getBounds();
          const coords = [
            [bounds.getSouthWest().lat, bounds.getSouthWest().lng],
            [bounds.getSouthEast().lat, bounds.getSouthEast().lng],
            [bounds.getNorthEast().lat, bounds.getNorthEast().lng],
            [bounds.getNorthWest().lat, bounds.getNorthWest().lng]
          ];
          drawnItems.addLayer(layer);
          showTimeFilterModalForExport(coords);
        }
      });

      map.on(L.Draw.Event.EDITED, function (e) {
        e.layers.eachLayer(layer => {
          if (layer && is3DMode) syncPolygonsTo3D();
          updatePolygonPopup(layer);
        });
        updateLegend();
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
        editingLayerId = null;
      });

      map.on(L.Draw.Event.DELETED, function (e) {
        if (is3DMode) syncPolygonsTo3D();
        updateLegend();
        editingLayerId = null;
      });

      // Add Export Rectangle Strikes button to expert-controls
      const exportButton = document.createElement('button');
      exportButton.textContent = 'Export Rectangle Strikes';
      exportButton.onclick = showRectangleExportModal;
      const expertControls = document.getElementById('expert-controls');
      if (expertControls && !expertControls.querySelector('button[onclick="showRectangleExportModal()"]')) {
        expertControls.appendChild(exportButton);
      }
    }

    function initializeDrawControl3D() {
      // No drawing in 3D mode
    }
    // Initialize Mapbox GL Draw for 3D mode
    function initializeDrawControl3D2() {
      drawControl3D = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
          polygon: true,
          trash: true
        },
        styles: [
          {
            id: 'gl-draw-polygon-fill-inactive',
            type: 'fill',
            paint: {
              'fill-color': '#5aac91',
              'fill-opacity': 0.3
            }
          },
          {
            id: 'gl-draw-polygon-stroke-inactive',
            type: 'line',
            paint: {
              'line-color': '#5aac91',
              'line-width': 2,

            }
          },
          {
            id: 'gl-draw-polygon-fill-active',
            type: 'fill',
            paint: {
              'fill-color': '#5aac91',
              'fill-opacity': 0.5
            }
          },
          {
            id: 'gl-draw-polygon-stroke-active',
            type: 'line',
            paint: {
              'line-color': '#5aac91',
              'line-width': 3
            }
          },
          {
            id: 'gl-draw-vertex-inactive',
            type: 'circle',
            paint: {
              'circle-radius': 5,
              'circle-color': '#fff',
              'circle-stroke-color': '#5aac91',
              'circle-stroke-width': 2,
              'circle-opacity': 0, // Set to 0 to hide inactive vertices
              'circle-stroke-opacity': 0
            }
          },
          {
            id: 'gl-draw-vertex-active',
            type: 'circle',
            paint: {
              'circle-radius': 7,
              'circle-color': '#5aac91'
            }
          }
        ]
      });
      map3D.addControl(drawControl3D, 'top-right');

      map3D.on('draw.create', function (e) {
        const geojson = e.features[0];
        const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
        geojson.properties = { name: riskLevel, source: 'mapbox' };
        const isSevere = riskLevel === 'Severe risk';
        const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
        map3D.addSource(layerId, { type: 'geojson', data: geojson });
        map3D.addLayer({
          id: layerId,
          type: 'fill',
          source: layerId,
          paint: {
            'fill-color': risk_colors[riskLevel],
            'fill-opacity': isSevere ? 0 : parseFloat(document.getElementById('polygon-opacity')?.value || 0.3)
          }
        });
        map3D.addLayer({
          id: `${layerId}-outline`,
          type: 'line',
          source: layerId,
          paint: {
            'line-color': risk_colors[riskLevel],
            'line-width': parseFloat(document.getElementById('polygon-weight')?.value || 2),
            'line-opacity': 1
          }
        });
        drawnItems3D.push({
          id: layerId,
          outlineId: `${layerId}-outline`,
          source: layerId
        });
        const leafletLayer = L.geoJSON(geojson, {
          style: {
            color: risk_colors[riskLevel],
            fillColor: isSevere ? 'transparent' : risk_colors[riskLevel],
            fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
            weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
          }
        });
        leafletLayer.feature = geojson;
        leafletLayer._leaflet_id = layerId;
        drawnItems.addLayer(leafletLayer);
        addPolygonPopup(leafletLayer);
        updateLegend();
        console.log('Created 3D polygon:', layerId, geojson);
      });

      map3D.on('draw.update', function (e) {
        const geojson = e.features[0];
        const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
        const leafletLayer = drawnItems.getLayer(layerId);
        if (leafletLayer) {
          leafletLayer.clearLayers();
          leafletLayer.addData(geojson);
          updatePolygonPopup(leafletLayer);
          if (is3DMode) syncPolygonsTo3D();
          updateLegend();
          console.log('Updated 3D polygon:', layerId, geojson);
        }
      });

      map3D.on('draw.delete', function (e) {
        e.features.forEach(feature => {
          const layerId = `drawn-polygon-${feature.id || Date.now()}`;
          const leafletLayer = drawnItems.getLayer(layerId);
          if (leafletLayer) {
            drawnItems.removeLayer(leafletLayer);
          }
          const item = drawnItems3D.find(d => d.id === layerId);
          if (item) {
            if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
            if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
            if (map3D.getSource(item.source)) map3D.removeSource(item.source);
            drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
          }
        });
        updateLegend();
        editingLayerId = null;
        console.log('Deleted 3D polygon(s)');
      });

      // Handle clicks on 3D map polygons to open Leaflet popups
      map3D.on('click', function (e) {
        if (isDrawingEnabled && drawControl3D.getMode() === 'draw_polygon') return; // Ignore clicks during active drawing
        const features = map3D.queryRenderedFeatures(e.point, {
          layers: drawnItems3D.map(item => item.id)
        });
        if (features.length > 0) {
          const layerId = features[0].layer.id;
          const leafletLayer = drawnItems.getLayer(layerId);
          if (leafletLayer && leafletLayer.getPopup()) {
            console.log('Clicked 3D polygon:', layerId);
            // Temporarily enable 2D map for popup rendering
            map.getContainer().style.opacity = '0';
            map.getContainer().style.height = '100%';
            map.getContainer().style.overflow = 'visible';
            leafletLayer.openPopup([e.lngLat.lat, e.lngLat.lng]);
            // Revert 2D map after popup interaction
            setTimeout(() => {
              map.getContainer().style.opacity = '0';
              map.getContainer().style.height = '0';
              map.getContainer().style.overflow = 'hidden';
            }, 100);
          } else {
            console.warn('No Leaflet layer or popup found for:', layerId);
          }
          // Prevent accidental edit mode activation
          if (drawControl3D.getMode() !== 'draw_polygon') {
            drawControl3D.changeMode('simple_select');
          }
        }
      });

    }

    // Toggle 3D mode
    function toggle3DMode() {
      is3DMode = !is3DMode;
      const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
      if (button) {
        button.textContent = is3DMode ? 'Switch to 2D' : 'Switch to 3D';
      }
      document.body.classList.toggle('three-d-mode', is3DMode);
      if (is3DMode) {
        map3D.resize();
        syncPolygonsTo3D();
        if (isDrawingEnabled) {
          isDrawingEnabled = false;
          const drawButton = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
          if (drawButton) {
            drawButton.textContent = 'Enable Drawing';
          }
          console.log('Drawing disabled when switching to 3D mode');
        }
      } else {
        map.getContainer().style.display = 'block';
        map.getContainer().style.opacity = '1';
        map.getContainer().style.height = 'auto';
        map.getContainer().style.overflow = 'visible';
        clear3DPolygons();
        map3D.getContainer().style.opacity = '0';
      }
      updateLegend();
      console.log('Toggled to', is3DMode ? '3D' : '2D', 'mode, synced polygons');
    }

    // Toggle drawing mode
    function toggleDrawing() {
      if (is3DMode) {
        // Show modal prompting to switch to 2D mode
        document.getElementById('3d-draw-modal').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        return;
      }

      isDrawingEnabled = !isDrawingEnabled;
      const button = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
      if (button) {
        button.textContent = isDrawingEnabled ? 'Disable Drawing' : 'Enable Drawing';
      }
      if (isDrawingEnabled) {
        drawControl._toolbars.draw._modes.polygon.handler.enable();
      } else {
        drawControl._toolbars.draw._modes.polygon.handler.disable();
        // Disable any active edit mode to prevent vertex interaction
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
        editingLayerId = null;
      }
      console.log('Drawing', isDrawingEnabled ? 'enabled' : 'disabled', 'in 2D mode');
    }
    function switchTo2DForDrawing() {
      is3DMode = false;
      document.body.classList.remove('three-d-mode');
      map.getContainer().style.display = 'block';
      map.getContainer().style.opacity = '1';
      map.getContainer().style.height = 'auto';
      map.getContainer().style.overflow = 'visible';
      map3D.getContainer().style.opacity = '0';
      clear3DPolygons();
      const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
      if (button) {
        button.textContent = 'Switch to 3D';
      }
      close3DDrawModal();
      toggleDrawing(); // Enable drawing after switching to 2D
      console.log('Switched to 2D mode for drawing');
    }

    function close3DDrawModal() {
      document.getElementById('3d-draw-modal').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }
    // Sync 2D polygons to 3D
    function syncPolygonsTo3D() {
      clear3DPolygons();
      console.log('Syncing polygons to 3D, drawnItems layers:', drawnItems.getLayers().length);
      drawnItems.eachLayer(layer => {
        if (!layer || !document.getElementById('drawn-polygons-toggle')?.checked) {
          console.log('Skipping layer:', layer?._leaflet_id, 'toggle:', document.getElementById('drawn-polygons-toggle')?.checked);
          return;
        }
        const geojson = layer.toGeoJSON();
        geojson.properties = {
          name: layer.feature?.properties?.name || 'Low risk',
          source: layer.feature?.properties?.source || 'leaflet'
        };
        const isSevere = geojson.properties.name === 'Severe risk';
        const layerId = layer._leaflet_id || `drawn-polygon-${Date.now()}`;
        if (!layer._leaflet_id) {
          layer._leaflet_id = layerId;
        }
        console.log('Syncing layer:', layerId, 'GeoJSON:', geojson);
        try {
          map3D.addSource(layerId, { type: 'geojson', data: geojson });
          map3D.addLayer({
            id: layerId,
            type: 'fill',
            source: layerId,
            paint: {
              'fill-color': layer.options.color || '#5aac91',
              'fill-opacity': isSevere ? 0 : (layer.options.fillOpacity || 0.3)
            }
          });
          map3D.addLayer({
            id: `${layerId}-outline`,
            type: 'line',
            source: layerId,
            paint: {
              'line-color': layer.options.color || '#5aac91',
              'line-width': layer.options.weight || 2,
              'line-opacity': 1
            }
          });
          drawnItems3D.push({
            id: layerId,
            outlineId: `${layerId}-outline`,
            source: layerId
          });
        } catch (error) {
          console.error('Error syncing layer:', layerId, error);
        }
      });
      map3D.resize();
      console.log('Synced', drawnItems3D.length, 'polygons to 3D');
    }

    // Clear 3D polygons
    function clear3DPolygons() {
      console.log('Clearing 3D polygons:', drawnItems3D.length);
      drawnItems3D.forEach(item => {
        if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
        if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
        if (map3D.getSource(item.source)) map3D.removeSource(item.source);
      });
      drawnItems3D = [];
    }

    // Add or update popup for polygon customization
    function addPolygonPopup(layer) {
      if (!layer || !layer._leaflet_id) {
        console.error('Invalid layer or missing _leaflet_id:', layer);
        return;
      }
      const popupContent = document.createElement('div');
      popupContent.className = 'polygon-popup';
      const riskLevel = layer.feature?.properties?.name || 'Low risk';
      const isEditing = editingLayerId === layer._leaflet_id;
      popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
      const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
      const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
      const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
      const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

      if (riskSelect) {
        riskSelect.replaceWith(riskSelect.cloneNode(true));
        const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
        newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
      }
      if (colorInput) {
        colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
      }
      if (editButton) {
        editButton.onclick = () => {
          if (editingLayerId === layer._leaflet_id) {
            cancelPolygonEdit(layer._leaflet_id);
          } else {
            startEditPolygon(layer._leaflet_id);
          }
        };
      }
      if (applyButton) {
        applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
      }
      if (deleteButton) {
        deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
      }

      layer.bindPopup(popupContent);
      console.log('Added popup for layer:', layer._leaflet_id);
    }

    // Update existing popup content without rebinding
    function updatePolygonPopup(layer) {
      if (!layer || !layer._leaflet_id || !layer.getPopup()) {
        console.error('Cannot update popup for layer:', layer);
        return;
      }
      const popupContent = layer.getPopup().getContent();
      const riskLevel = layer.feature?.properties?.name || 'Low risk';
      const isEditing = editingLayerId === layer._leaflet_id;
      popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
      const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
      const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
      const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
      const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

      if (riskSelect) {
        riskSelect.replaceWith(riskSelect.cloneNode(true));
        const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
        newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
      }
      if (colorInput) {
        colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
      }
      if (editButton) {
        editButton.onclick = () => {
          if (editingLayerId === layer._leaflet_id) {
            cancelPolygonEdit(layer._leaflet_id);
          } else {
            startEditPolygon(layer._leaflet_id);
          }
        };
      }
      if (applyButton) {
        applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
      }
      if (deleteButton) {
        deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
      }
      console.log('Updated popup for layer:', layer._leaflet_id);
    }

    // Update polygon risk level
    function updatePolygonRisk(select, layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      const risk = select.value;
      layer.feature = layer.feature || { type: 'Feature', properties: {} };
      layer.feature.properties.name = risk;
      const isSevere = risk === 'Severe risk';
      layer.setStyle({
        color: risk_colors[risk],
        fillColor: isSevere ? 'transparent' : risk_colors[risk],
        fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
        weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      updatePolygonPopup(layer);
      console.log('Updated risk level for layer:', layerId, 'to', risk);
    }

    // Update polygon color
    function updatePolygonColor(input, layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      const color = input.value;
      layer.setStyle({
        color,
        fillColor: layer.feature?.properties?.name === 'Severe risk' ? 'transparent' : color
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      updatePolygonPopup(layer);
      console.log('Updated color for layer:', layerId, 'to', color);
    }

    // Start editing polygon shape
    function startEditPolygon(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('direct_select', { featureId: layerId.replace('drawn-polygon-', '') });
          editingLayerId = layerId;
          updatePolygonPopup(layer);
          layer.openPopup();
        } else {
          console.error('3D draw control not initialized');
        }
      } else {
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.enable();
          if (layer.editing) {
            layer.editing.enable();
          } else {
            console.warn('Layer editing not supported for this layer:', layer);
          }
          editingLayerId = layerId;
          updatePolygonPopup(layer);
          layer.openPopup();
        } else {
          console.error('Edit toolbar not initialized');
        }
      }
      console.log('Started editing layer:', layerId);
    }

    // Save edited polygon shape
    function savePolygonEdit(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('simple_select');
          const geojson = layer.toGeoJSON();
          const sourceId = layerId;
          if (map3D.getSource(sourceId)) {
            map3D.getSource(sourceId).setData(geojson);
          }
        }
      } else {
        if (layer.editing) {
          layer.editing.disable();
        }
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.save();
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      editingLayerId = null;
      updatePolygonPopup(layer);
      layer.openPopup();
      console.log('Saved edits for layer:', layerId);
    }

    // Cancel editing polygon shape
    function cancelPolygonEdit(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('simple_select');
        }
      } else {
        if (layer.editing) {
          layer.editing.disable();
        }
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.revertLayers();
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      editingLayerId = null;
      updatePolygonPopup(layer);
      layer.openPopup();
      console.log('Canceled edits for layer:', layerId);
    }

    // Delete polygon
    function deletePolygon(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      drawnItems.removeLayer(layer);
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        const item = drawnItems3D.find(d => d.id === layerId);
        if (item) {
          if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
          if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
          if (map3D.getSource(item.source)) map3D.removeSource(item.source);
          drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      editingLayerId = null;
      console.log('Deleted layer:', layerId);
    }

    // Update all polygons' opacity
    function updateAllPolygonsOpacity() {
      const opacity = parseFloat(document.getElementById('polygon-opacity')?.value || 0.3);
      drawnItems.eachLayer(layer => {
        if (layer) {
          layer.setStyle({ fillOpacity: layer.feature?.properties?.name === 'Severe risk' ? 0 : opacity });
        }
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      console.log('Updated opacity for all polygons:', opacity);
    }

    // Update all polygons' outline weight
    function updateAllPolygonsWeight() {
      const weight = parseFloat(document.getElementById('polygon-weight')?.value || 2);
      drawnItems.eachLayer(layer => {
        if (layer) {
          layer.setStyle({ weight });
        }
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      console.log('Updated weight for all polygons:', weight);
    }

    // Export drawn polygons to KML
    function exportToKML() {
      const kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>Drawn Polygons</name>`;
      let kmlBody = '';
      drawnItems.eachLayer(layer => {
        if (!layer || !layer.toGeoJSON || !layer.options?.color) return;
        const geojson = layer.toGeoJSON();
        const coordinates = geojson.geometry.coordinates[0]?.map(coord => `${coord[0]},${coord[1]},0`).join(' ') || '';
        const risk = layer.feature?.properties?.name || 'Low risk';
        kmlBody += `
        <Placemark>
          <name>${risk}</name>
          <Style>
            <LineStyle>
              <color>ff${layer.options.color.replace('#', '')}</color>
              <width>${layer.options.weight || 2}</width>
            </LineStyle>
            <PolyStyle>
              <color>${risk === 'Severe risk' ? '00' : '7f'}${layer.options.color.replace('#', '')}</color>
            </PolyStyle>
          </Style>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>${coordinates}</coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>`;
      });
      const kmlFooter = `
</Document>
</kml>`;
      const kmlContent = kmlHeader + kmlBody + kmlFooter;
      const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawn_polygons.kml';
      a.click();
      URL.revokeObjectURL(url);
      console.log('Exported polygons to KML');
    }







    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');

      const isDark = document.body.classList.contains('dark-mode');
      const mapStyleSelect = document.getElementById('map-style');

      if (isDark) {
        // Switch to a good dark base map
        mapStyleSelect.value = 'mapbox-traffic-night'; // or 'mapbox-dark' or 'maptiler-dark'
        switchBaseMap('mapbox-traffic-night');

        // Update button text
        event.target.textContent = '‚òÄÔ∏è Light Mode';
      } else {
        // Switch to a good light base map
        mapStyleSelect.value = 'mapbox-traffic-day'; // or 'mapbox-light' or 'maptiler-light'
        switchBaseMap('mapbox-traffic-day');

        // Update button text
        event.target.textContent = 'üåô Dark Mode';
      }
    }

    function toggleControls() {
      const controlPanel = document.getElementById('control-panel');
      controlPanel.classList.toggle('open');
    }
    function updateTerrainExaggeration() {
      if (is3DMode) {
        const exaggeration = parseFloat(document.getElementById('terrain-exaggeration-slider').value);
        map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        map3D.resize();
      }
    }
    function showUserLocation() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          // Remove existing marker if present
          if (userLocationMarker) {
            if (is3DMode) {
              userLocationMarker.remove();
            } else {
              map.removeLayer(userLocationMarker);
            }
            userLocationMarker = null;
          }
          // Add new marker
          if (is3DMode) {
            const el = document.createElement('div');
            el.className = 'user-location-marker';
            userLocationMarker = new mapboxgl.Marker(el)
              .setLngLat([longitude, latitude])
              .addTo(map3D);
            map3D.jumpTo({ center: [longitude, latitude], zoom: 10 });
            map3D.resize();
          } else {
            userLocationMarker = L.circleMarker([latitude, longitude], {
              radius: 6,
              color: '#3b82f6',
              fillColor: '#3b82f6',
              fillOpacity: 1,
              className: 'user-location-marker'
            }).addTo(map);
            map.setView([latitude, longitude], 10);
            map.invalidateSize();
          }
        },
        (error) => {
          alert('Unable to retrieve location: ' + error.message);
        }
      );
    }
    function toggleSound() {
      soundEnabled = document.getElementById('sound-toggle').checked;
    }

    function toggleLightningEffect() {
      lightningEffectEnabled = document.getElementById('lightning-effect-toggle').checked;
    }

    function playThunderSound() {
      if (!soundEnabled) return;
      const now = Date.now();
      if (now - lastSoundTime < SOUND_COOLDOWN) return;
      thunderAudio.currentTime = 0;
      thunderAudio.play().catch(error => console.error('Error playing sound:', error));
      lastSoundTime = now;
    }

    function addLightningFlash2D(lat, lng) {
      if (!lightningEffectEnabled || !map || !map.getPanes().overlayPane) return;

      // Ensure map size is valid
      map.invalidateSize();

      // Convert [latitude, longitude] to container coordinates
      const point = map.latLngToContainerPoint([lat, lng]);
      if (!point || isNaN(point.x) || isNaN(point.y)) {
        console.warn(`Invalid container point for lat=${lat}, lng=${lng}:`, point);
        return;
      }

      // Calculate base size based on zoom level to maintain consistent appearance
      const zoom = map.getZoom();
      const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

      const flash = document.createElement('div');
      flash.className = 'lightning-flash-2d';
      flash.style.width = `${baseSize}px`;
      flash.style.height = `${baseSize}px`;
      flash.style.left = `${point.x - baseSize / 2}px`; // Center the flash
      flash.style.top = `${point.y - baseSize / 2}px`; // Center the flash
      flash.style.zIndex = '1000';
      flash.style.transformOrigin = 'center'; // Ensure scaling is centered
      map.getPanes().overlayPane.appendChild(flash);
      setTimeout(() => flash.remove(), 2500);
    }

    function addLightningFlash3D(lng, lat) {
      if (!lightningEffectEnabled || !map3D) return;

      // Ensure map is resized
      map3D.resize();

      // Calculate size based on zoom level
      const zoom = map3D.getZoom();
      const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

      const el = document.createElement('div');
      el.className = 'lightning-flash-3d';
      el.style.width = `${baseSize}px`;
      el.style.height = `${baseSize}px`;
      el.style.transform = 'translate(-50%, -50%)'; // Center the flash
      el.style.transformOrigin = 'center'; // Ensure scaling is centered
      const marker = new mapboxgl.Marker({
        element: el,
        anchor: 'center'
      })
        .setLngLat([lng, lat])
        .addTo(map3D);
      setTimeout(() => marker.remove(), 2500);
    }

    function toggle3DMode() {
      is3DMode = document.getElementById('3d-mode-toggle').checked;
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');
      mapDiv.style.display = is3DMode ? 'none' : 'block';
      map3DDiv.style.display = is3DMode ? 'block' : 'none';
      document.getElementById('heatmap-3d-toggle').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('heatmap-frequency-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('heatmap-height-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('terrain-exaggeration-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';

      if (userLocationMarker) {
        if (is3DMode) {
          if (map.hasLayer(userLocationMarker)) map.removeLayer(userLocationMarker);
        } else {
          if (userLocationMarker.remove) userLocationMarker.remove();
        }
        userLocationMarker = null;
      }

      if (is3DMode) {
        map3D.jumpTo({ center: [-4.5, 53.5], zoom: 5 });
        map3D.resize();
        update3DView();
        toggleKMLLayer();
        togglePNGLayer();
        syncPolygonsTo3D();
        updateOverlay(currentFiltered);
        toggleNowcast();
        updateLegend();
        updateTerrainExaggeration();
      } else {
        map.invalidateSize();
        map.addLayer(drawnItems);
        clear3DPolygons();
        updateHistory();
        updateLegend();
      }
    }


    function update3DView() {
      // Clear existing layers
      strikeLayer3D.forEach(marker => marker.remove());
      strikeLayer3D = [];
      if (map3D.getLayer('heatmap-3d')) map3D.removeLayer('heatmap-3d');
      if (map3D.getSource('heatmap-3d')) map3D.removeSource('heatmap-3d');
      if (map3D.getLayer('heatmap-2d')) map3D.removeLayer('heatmap-2d');
      if (map3D.getSource('heatmap-2d')) map3D.removeSource('heatmap-2d');
      if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
      if (map3D.getSource('png-source')) map3D.removeSource('png-source');
      if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
      if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
      if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
      nowcastLayer3D.forEach(layer => {
        if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
        if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
      });
      nowcastLayer3D = [];
      map3D.resize();
      const currentBounds = map3D.getBounds();
      const newStrikes = new Set();

      // Get user-defined lifespan and slider position
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value) || 3;
      const slider = document.getElementById('history-slider');
      let sliderValue = parseInt(slider.value);
      const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;

      // Determine time range based on filter mode
      let startTime, endTime;
      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        const filterStart = new Date(customFilterStart);
        const filterEnd = new Date(customFilterEnd);
        if (isNaN(filterStart) || isNaN(filterEnd)) {
          console.error('Invalid custom filter dates');
          return;
        }
        const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
        const sliderMax = Math.max(totalMinutes, lifespanHours * 60);
        sliderValue = Math.min(sliderValue, sliderMax);
        slider.max = sliderMax;
        slider.min = 0;
        slider.value = sliderValue;
        endTime = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
        startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
      } else {
        const now = new Date();
        sliderValue = sliderValue || maxMinutes;
        slider.max = maxMinutes;
        slider.min = 0;
        endTime = new Date(now.getTime() - (maxMinutes - sliderValue) * 60 * 1000);
        startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
      }

      // Update animation times
      animationStart = startTime;
      animationEnd = endTime;

      // Filter strikes within the lifespan
      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(endTime.getTime() - maxMinutes * 60 * 1000) && s.time <= endTime;
        }
        return s.time >= startTime && s.time <= endTime;
      });

      // Add PNG layer
      if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
        map3D.addSource('png-source', {
          type: 'image',
          url: pngImage,
          coordinates: [
            [pngBounds[0][1], pngBounds[1][0]],
            [pngBounds[1][1], pngBounds[1][0]],
            [pngBounds[1][1], pngBounds[0][0]],
            [pngBounds[0][1], pngBounds[0][0]]
          ]
        });
        map3D.addLayer({
          id: 'png-layer',
          type: 'raster',
          source: 'png-source',
          paint: {
            'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
          }
        });
      }

      // Add KML layer
      if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
        map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
        map3D.addLayer({
          id: 'kml-layer',
          type: 'fill',
          source: 'kml-source',
          paint: {
            'fill-color': [
              'match',
              ['get', 'name'],
              'Low risk', risk_colors['Low risk'],
              'Slight risk', risk_colors['Slight risk'],
              'Enhanced risk', risk_colors['Enhanced risk'],
              'Moderate risk', risk_colors['Moderate risk'],
              'High risk', risk_colors['High risk'],
              'transparent'
            ],
            'fill-opacity': [
              'match',
              ['get', 'name'],
              'Low risk', 0.3,
              'Slight risk', 0.3,
              'Enhanced risk', 0.3,
              'Moderate risk', 0.3,
              'High risk', 0.3,
              0
            ]
          }
        });
        map3D.addLayer({
          id: 'kml-layer-outline',
          type: 'line',
          source: 'kml-source',
          paint: {
            'line-color': [
              'match',
              ['get', 'name'],
              'Low risk', risk_colors['Low risk'],
              'Slight risk', risk_colors['Slight risk'],
              'Enhanced risk', risk_colors['Enhanced risk'],
              'Moderate risk', risk_colors['Moderate risk'],
              'High risk', risk_colors['High risk'],
              risk_colors['Severe risk']
            ],
            'line-width': 2,
            'line-opacity': 1
          }
        });
      }

      // Add nowcast layers
      minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);
      if (document.getElementById('nowcast-toggle').checked) {
        currentNowcasts = calculateLightningNowcast(currentFiltered);
        currentNowcasts.forEach((cluster, index) => {
          if (cluster.confidenceScore >= minNowcastConfidence) {
            const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
              cluster.confidenceScore > 0.8 ? 'red' :
                cluster.confidenceScore > 0.7 ? 'orange' : 'green';
            const radiusKm = cluster.confidenceScore * 5 + 5;
            const coneRadiusKm = cluster.confidenceScore * 30 + 30;
            const radiusDeg = radiusKm / 111;

            // Add nowcast circle
            map3D.addSource(`nowcast-circle-${index}`, {
              type: 'geojson',
              data: {
                type: 'Feature',
                geometry: {
                  type: 'Point',
                  coordinates: [cluster.baseLon, cluster.baseLat]
                },
                properties: { radius: radiusDeg }
              }
            });
            map3D.addLayer({
              id: `nowcast-circle-${index}`,
              type: 'circle',
              source: `nowcast-circle-${index}`,
              paint: {
                'circle-radius': [
                  'interpolate',
                  ['linear'],
                  ['zoom'],
                  5, (radiusKm * 1000) / 1000,
                  10, (radiusKm * 1000) / 250
                ],
                'circle-color': confidenceColor,
                'circle-opacity': 0.5,
                'circle-stroke-color': confidenceColor,
                'circle-stroke-width': 2,
                'circle-stroke-opacity': 0.8
              }
            });
            nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

            // Add nowcast cone
            const cone = turf.sector(
              [cluster.baseLon, cluster.baseLat],
              coneRadiusKm,
              cluster.directionDeg - 15,
              cluster.directionDeg + 15,
              { units: 'kilometers' }
            );
            map3D.addSource(`nowcast-cone-${index}`, {
              type: 'geojson',
              data: cone
            });
            map3D.addLayer({
              id: `nowcast-cone-${index}`,
              type: 'fill',
              source: `nowcast-cone-${index}`,
              paint: {
                'fill-color': confidenceColor,
                'fill-opacity': 0.5
              }
            });
            nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
          }
        });
      }

      // Add lightning layer
      if (document.getElementById('lightning-layer-toggle').checked) {
        currentFiltered.forEach(s => {
          const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
          newStrikes.add(strikeKey);
          const isNewStrike = !lastRenderedStrikes.has(strikeKey);
          const inBounds = currentBounds.contains([s.coordinates[0], s.coordinates[1]]);
          const ageFraction = (endTime - s.time) / (lifespanHours * 3600 * 1000);

          const el = document.createElement('div');
          el.className = 'marker';
          el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
          el.style.width = '10px';
          el.style.height = '10px';
          el.style.borderRadius = '50%';
          const marker = new mapboxgl.Marker(el)
            .setLngLat([s.coordinates[0], s.coordinates[1]])
            .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
            .addTo(map3D);
          strikeLayer3D.push(marker);
          if (isNewStrike && inBounds) {
            playThunderSound();
            addLightningFlash3D(s.coordinates[0], s.coordinates[1]);
          }
        });
      }

      lastRenderedStrikes = newStrikes;

      // Render 2D and 3D heatmaps
      const heatmap2DEnabled = document.getElementById('heatmap-toggle').checked;
      const heatmap3DEnabled = document.getElementById('heatmap-3d-toggle').checked;
      const blur = parseInt(document.getElementById('blur-slider').value);

      if (heatmap2DEnabled) {
        const heatmapData = {
          type: 'FeatureCollection',
          features: currentFiltered.map(s => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [s.coordinates[0], s.coordinates[1]]
            },
            properties: { intensity: 1 }
          }))
        };
        map3D.addSource('heatmap-2d', {
          type: 'geojson',
          data: heatmapData
        });
        map3D.addLayer({
          id: 'heatmap-2d',
          type: 'heatmap',
          source: 'heatmap-2d',
          paint: {
            'heatmap-weight': ['get', 'intensity'],
            'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 1, 9, 3],
            'heatmap-color': [
              'interpolate',
              ['linear'],
              ['heatmap-density'],
              0, 'rgba(0, 18, 25, 0)',
              0.1, '#001219',
              0.2, '#0A9396',
              0.3, '#94D2BD',
              0.4, '#E9D8A6',
              0.5, '#c89578',
              0.6, '#EE9B00',
              0.7, '#CA6702',
              0.8, '#BB3E03',
              0.9, '#AE2012',
              1, '#9B2226'
            ],
            'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, blur, 9, blur * 2],
            'heatmap-opacity': ['interpolate', ['linear'], ['zoom'], 7, 1, 9, 0.7]
          }
        });
      }

      if (heatmap3DEnabled) {
        const frequency = parseInt(document.getElementById('heatmap-frequency-slider').value);
        const maxHeight = parseInt(document.getElementById('heatmap-height-slider').value);
        const gridData = generateHeatmapGrid(currentFiltered, frequency);
        map3D.addSource('heatmap-3d', {
          type: 'geojson',
          data: gridData
        });
        map3D.addLayer({
          id: 'heatmap-3d',
          type: 'fill-extrusion',
          source: 'heatmap-3d',
          paint: {
            'fill-extrusion-color': [
              'interpolate',
              ['linear'],
              ['get', 'intensity'],
              0, '#001219',
              0.1, '#001219',
              0.2, '#0A9396',
              0.3, '#94D2BD',
              0.4, '#E9D8A6',
              0.5, '#c89578',
              0.6, '#EE9B00',
              0.7, '#CA6702',
              0.8, '#BB3E03',
              0.9, '#AE2012',
              1, '#9B2226'
            ],
            'fill-extrusion-height': ['*', ['get', 'intensity'], maxHeight],
            'fill-extrusion-base': 0,
            'fill-extrusion-opacity': 0.7
          }
        });
      }

      updateOverlay(currentFiltered);
      updateLegend();
    }
    function generateHeatmapGrid(data, frequency) {
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;
      const latStep = (maxLat - minLat) / frequency;
      const lngStep = (maxLng - minLng) / frequency;
      const grid = [];

      for (let i = 0; i < frequency; i++) {
        for (let j = 0; j < frequency; j++) {
          const count = data.reduce((sum, s) => {
            const lat = s.coordinates[1];
            const lng = s.coordinates[0];
            const cellLatMin = minLat + i * latStep;
            const cellLatMax = cellLatMin + latStep;
            const cellLngMin = minLng + j * lngStep;
            const cellLngMax = cellLngMin + lngStep;
            return sum + (lat >= cellLatMin && lat < cellLatMax && lng >= cellLngMin && lng < cellLngMax ? 1 : 0);
          }, 0);
          if (count > 0) {
            const intensity = Math.min(count / 10, 1);
            grid.push({
              type: 'Feature',
              properties: { intensity },
              geometry: {
                type: 'Polygon',
                coordinates: [[
                  [minLng + j * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + i * latStep]
                ]]
              }
            });
          }
        }
      }

      return {
        type: 'FeatureCollection',
        features: grid
      };
    }

    function toggleExpertMode() {
      const expertControls = document.getElementById('expert-controls');
      const isExpertMode = document.getElementById('expert-mode').checked;
      expertControls.style.display = isExpertMode ? 'grid' : 'none';
      if (isExpertMode) {
        // Add KML and PNG layers if they exist and checkboxes are checked
        toggleKMLLayer();
        togglePNGLayer();
      } else {
        // Remove KML and PNG layers when Expert Mode is disabled
        if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
        if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
        if (is3DMode) {
          if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
          if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
          if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
          if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        }
      }
      updateZIndex();
      updateLegend();
    }

    function showTutorial() {
      document.getElementById('tutorial-modal').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
    }

    function closeTutorial() {
      document.getElementById('tutorial-modal').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }

    function updateHistorySliderMax() {
      if (lastFilterMode === 'slider') {
        const maxHours = parseInt(document.getElementById('max-history-hours').value) || 6;
        document.getElementById('history-slider').max = maxHours * 60;
        document.getElementById('history-slider').value = maxHours * 60;
        updateHistory();
      }
    }

    function formatTimeAgo(minutesBack) {
      if (minutesBack === 0) return 'Now';
      const hours = Math.floor(minutesBack / 60);
      const minutes = minutesBack % 60;
      let result = '';
      if (hours > 0) result += `${hours}h `;
      if (minutes > 0 || hours === 0) result += `${minutes}m`;
      return result.trim() + ' ago';
    }

    function updateHistory() {
      isAdjustingHistory = true;
      const slider = document.getElementById('history-slider');
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      let start, end, sliderMax, sliderValue, minutesBack;

      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        const filterStart = new Date(customFilterStart);
        const filterEnd = new Date(customFilterEnd);

        if (isNaN(filterStart) || isNaN(filterEnd)) {
          console.error('Invalid custom date/time format.');
          isAdjustingHistory = false;
          return;
        }

        const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
        sliderMax = Math.max(totalMinutes, lifespanHours * 60);
        sliderValue = parseInt(slider.value) || sliderMax;
        minutesBack = sliderMax - sliderValue;

        end = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = sliderMax;
        slider.min = 0;
        slider.value = sliderValue;
        if (!is3DMode) {
          map.invalidateSize();
        }
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      } else {
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;
        sliderMax = maxMinutes;
        sliderValue = parseInt(slider.value) || maxMinutes;
        minutesBack = maxMinutes - sliderValue;

        const now = new Date();
        end = new Date(now.getTime() - minutesBack * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = maxMinutes;
        slider.min = 0;
        slider.value = sliderValue;

        //document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        //document.getElementById('end-time').value = end.toISOString().slice(0, 16);
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
        document.getElementById('remove-filter').style.display = 'none';
      }

      animationStart = start;
      animationEnd = end;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ?
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      updateZIndex();
      updateLegend();
      updateRadarLayer(end.getTime());

      if (is3DMode) update3DView();

      setTimeout(() => { isAdjustingHistory = false; }, 1000);
    }

    function removeTimeFilter() {
      lastFilterMode = 'slider';
      customFilterStart = null;
      customFilterEnd = null;
      document.getElementById('remove-filter').style.display = 'none';
      document.getElementById('auto-latest').checked = true;
      toggleAutoLatest();
    }

    function setRefreshInterval() {
      if (refreshTimer) clearInterval(refreshTimer);
      const interval = parseFloat(document.getElementById('refresh-interval').value);
      if (interval > 0) {
        refreshTimer = setInterval(fetchData, interval * 60 * 1000);
      }
    }

    function toggleAutoLatest() {
      if (document.getElementById('auto-latest').checked) {
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const now = new Date();
        const start = new Date(now.getTime() - lifespanHours * 3600 * 1000);
        document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        document.getElementById('end-time').value = now.toISOString().slice(0, 16);
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;
        document.getElementById('history-slider').value = maxMinutes;
        document.getElementById('history-label').innerText = 'Now';
        lastFilterMode = 'slider';
        customFilterStart = null;
        customFilterEnd = null;
        document.getElementById('remove-filter').style.display = 'none';
        updateHistory();
      }
    }

    function updateClock() {
      const now = new Date();
      document.getElementById('current-time').innerText = `Current time: ${now.toLocaleString()}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    function parseDateFromFilename(filename) {
      const regex = /(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})__(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})|(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})\s+-\s+(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})/;
      const match = filename.match(regex);
      if (!match) return null;

      let startDate, endDate;
      if (match[1]) {
        startDate = new Date(`${match[3]}-${match[2]}-${match[1]}T${match[4]}:${match[5]}:00Z`);
        endDate = new Date(`${match[8]}-${match[7]}-${match[6]}T${match[9]}:${match[10]}:00Z`);
      } else {
        startDate = new Date(`${match[13]}-${match[12]}-${match[11]}T${match[14]}:${match[15]}:00Z`);
        endDate = new Date(`${match[18]}-${match[17]}-${match[16]}T${match[19]}:${match[20]}:00Z`);
      }

      return { startDate, endDate };
    }

    function showTimeFilterModal(file, type) {
      pendingFile = file;
      pendingFileType = type;
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'block';
      overlay.style.display = 'block';
    }

    function confirmAutoTimeFilter(confirm) {
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'none';
      overlay.style.display = 'none';

      if (!pendingFile || !pendingFileType) return;

      if (confirm && document.getElementById('auto-time-filter').checked) {
        const dates = parseDateFromFilename(pendingFile.name);
        if (dates && !isNaN(dates.startDate) && !isNaN(dates.endDate)) {
          document.getElementById('start-time').value = dates.startDate.toISOString().slice(0, 16);
          document.getElementById('end-time').value = dates.endDate.toISOString().slice(0, 16);
          lastFilterMode = 'inputs';
          applyFilter();
        }
      }

      if (pendingFileType === 'kml') importKML({ files: [pendingFile] });
      else if (pendingFileType === 'png') importPNG({ files: [pendingFile] });

      pendingFile = null;
      pendingFileType = null;
    }

    async function fetchData() {
      const githubUrl1 = 'https://raw.githubusercontent.com/HandryOutlook/lightning_data_new/refs/heads/main/lightning_data.json';
      const githubUrl2 = 'https://raw.githubusercontent.com/HandryOutlook/lightning_data_new/refs/heads/main/lightning_data_2025_autumn.json';
      const metOfficeBaseUrl = 'https://data.consumer-digital.api.metoffice.gov.uk/v1/lightning';

      try {
        // Fetch the main Met Office URL to get chunks and strikes
        const mainResponse = await fetch(metOfficeBaseUrl).then(res => res.json()).catch(() => null);
        if (!mainResponse) {
          console.error('Failed to fetch main Met Office URL');
          throw new Error('No data from main Met Office URL');
        }

        // Extract strikes from the base URL
        const baseStrikes = mainResponse?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];

        // Extract chunks and generate chunk URLs
        const chunkUrls = mainResponse?.chunks?.map(chunk =>
          `${metOfficeBaseUrl}?last-minutes=1&chunk=${chunk.chunk}`
        ) || [];
        if (!mainResponse.chunks) {
          console.warn('No chunks data found in main Met Office URL response');
        }

        // Fetch both GitHub URLs and all chunk URLs in parallel
        const fetchPromises = [
          fetch(githubUrl1).then(res => res.json()).catch(() => null),
          fetch(githubUrl2).then(res => res.json()).catch(() => null),
          ...chunkUrls.map(url => fetch(url).then(res => res.json()).catch(() => null))
        ];

        const responses = await Promise.all(fetchPromises);

        // Process GitHub strikes from both URLs
        const githubStrikes1 = responses[0]?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];
        const githubStrikes2 = responses[1]?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];

        // Combine strikes from all Met Office chunk responses (skip the first two responses, which are GitHub)
        const chunkStrikes = responses.slice(2).flatMap(response =>
          response?.lightning_strikes?.map(s => ({
            ...s,
            time: new Date(s.strike_time)
          })) || []
        );

        // Combine all strikes (both GitHub URLs, base URL, and chunk URLs)
        const allStrikes = [...githubStrikes1, ...githubStrikes2, ...baseStrikes, ...chunkStrikes];

        // Deduplicate strikes
        const seen = new Map();
        strikeData = allStrikes.filter(s => {
          const key = `${s.strike_time}_${s.coordinates[0]}_${s.coordinates[1]}`;
          if (!seen.has(key)) {
            seen.set(key, true);
            return true;
          }
          return false;
        });

        // Update last update time in the UI
        lastUpdateTime = new Date();
        document.getElementById('last-update').innerText = `Last update: ${lastUpdateTime.toLocaleString()}`;

        // Apply filters based on the last filter mode
        if (lastFilterMode === 'slider') {
          updateHistory(); // Calls updateNowcast()
        } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
          applyFilter(); // Calls updateNowcast()
        }
      } catch (error) {
        console.error('Error fetching lightning data:', error);
        strikeData = [];
        if (lastFilterMode === 'slider') {
          updateHistory();
        } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
          applyFilter();
        }
      }
    }

    function getColorFromAge(ageFraction) {

      if (ageFraction < 0.2) return '#ffd700'; // Newest
      if (ageFraction < 0.4) return '#ff69b4';
      if (ageFraction < 0.6) return '#ff00ff';
      if (ageFraction < 0.8) return '#800080';
      return '#4b0082'; // Oldest
    }

    function updateLegend() {
      const legendDiv = document.querySelector('.legend');
      legendDiv.innerHTML = '';
      const colorMode = document.getElementById('color-mode').checked;
      const heatmap2DEnabled = document.getElementById('heatmap-toggle').checked;
      const heatmap3DEnabled = is3DMode && document.getElementById('heatmap-3d-toggle').checked;
      const lightningEnabled = document.getElementById('lightning-layer-toggle').checked;
      const kmlEnabled = document.getElementById('kml-layer-toggle')?.checked;
      const pngEnabled = document.getElementById('png-layer-toggle')?.checked;
      const nowcastEnabled = document.getElementById('nowcast-toggle').checked;

      // Fix: Get radar type from select value and check if enabled
      const radarSelect = document.getElementById('radarLayer');
      const radarEnabled = radarSelect && radarSelect.value !== 'none';
      const radarType = radarSelect ? radarSelect.value : null;

      if (lightningEnabled) {
        legendDiv.innerHTML += '<h4>Lightning Strikes</h4>';
        if (colorMode) {
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: #ffd700"></div>Newest</div>
        <div><div class="color-box" style="background: #ff69b4"></div></div>
        <div><div class="color-box" style="background: #ff00ff"></div></div>
        <div><div class="color-box" style="background: #800080"></div></div>
        <div><div class="color-box" style="background: #4b0082"></div>Oldest</div>
      `;
        } else {
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: black"></div>Strikes</div>
      `;
        }
      }

      if (heatmap2DEnabled) {
        legendDiv.innerHTML += `
      <h4>2D Heatmap</h4>
      <div style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #c89578, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226); margin-top: 4px" class="gradient-bar"></div>
      <div style="display: flex; justify-content: space-between; margin-top: 4px">
        <span>Low</span><span>High</span>
      </div>
    `;
      }

      if (heatmap3DEnabled) {
        legendDiv.innerHTML += `
      <h4>3D Heatmap</h4>
      <div style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #c89578, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226); margin-top: 4px" class="gradient-bar"></div>
      <div style="display: flex; justify-content: space-between; margin-top: 4px">
        <span>Low</span><span>High</span>
      </div>
    `;
      }

      if (kmlEnabled && kmlLayer) {
        legendDiv.innerHTML += '<h4>Risk Levels</h4>';
        Object.entries(risk_colors).forEach(([name, color]) => {
          const isSevere = name === 'Severe risk';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: ${isSevere ? 'none' : color}; border: 2px solid ${color};"></div>${name}</div>
      `;
        });
      }

      if (nowcastEnabled) {
        legendDiv.innerHTML += '<h4>Nowcast Confidence </h4>';
        legendDiv.innerHTML += `
      <div style="display: flex; align-items: center;">
          <div class="color-gradient" style="
              width: 100px; 
              height: 20px; 
              background: linear-gradient(to right, #FF8C00, #CC0000); 
              opacity: 1.0; 
              border: 1px solid #333;
          "></div>
          
    `;
      }

      // Fix: Proper radar legend structure with all conditions inside radarEnabled check
      if (radarEnabled && radarType) {
        if (radarType === 'uk-precip-intensity-pixelated') {
          legendDiv.innerHTML += '<h4>Rainfall Intensity</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: #b30000"></div>>32mm/h</div>
        <div><div class="color-box" style="background: #fe0000"></div>16-32mm/h</div>
        <div><div class="color-box" style="background: #fe9800"></div>8-16mm/h</div>
        <div><div class="color-box" style="background: #00a300"></div>2-4mm/h</div>
        <div><div class="color-box" style="background: #0cbcfe"></div>1-2mm/h</div>
        <div><div class="color-box" style="background: #3265fe"></div>0.5-1mm/h</div>
        <div><div class="color-box" style="background: #0000fe"></div><0.5mm/h</div>
      `;
        } else if (radarType === 'uk-precip-type') {
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Freezing Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(252, 133, 145)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 88, 103)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>7 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(34, 145, 176)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(8, 98, 138)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Rain and Snow (Sleet)</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets and Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
      `;

        } else if (radarType === 'europe-precip-type') {
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Freezing Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(252, 133, 145)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 88, 103)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>7 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(34, 145, 176)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(8, 98, 138)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Rain and Snow (Sleet)</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets and Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
      `;
        } else {
          // Default for other radar types (e.g., smooth Europe radar)
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
        }
      }

      // Show or hide based on isLegendVisible and content
      legendDiv.style.display = (isLegendVisible && legendDiv.innerHTML) ? 'block' : 'none';

      if (is3DMode) {
        let map3DLegend = document.getElementById('map3d-legend');
        if (!map3DLegend) {
          map3DLegend = document.createElement('div');
          map3DLegend.id = 'map3d-legend';
          map3DLegend.className = 'legend';
          map3DLegend.style.position = 'absolute';
          map3DLegend.style.top = '100px';
          map3DLegend.style.right = '10px';
          map3DLegend.style.zIndex = '1002';
          document.getElementById('map-3d').appendChild(map3DLegend);
        }
        map3DLegend.innerHTML = legendDiv.innerHTML;
        map3DLegend.style.display = (isLegendVisible && legendDiv.innerHTML) ? 'block' : 'none';
      } else {
        const map3DLegend = document.getElementById('map3d-legend');
        if (map3DLegend) map3DLegend.remove();
      }
    }

    function toggleLegend() {
      isLegendVisible = !isLegendVisible;
      updateLegend(); // Update visibility based on new state
    }

    function applyFilter() {
      isFilterApplied = true;
      lastFilterMode = 'inputs';
      const start = new Date(document.getElementById('start-time').value);
      const end = new Date(document.getElementById('end-time').value);
      if (isNaN(start) || isNaN(end)) {
        console.error('Invalid date/time format.');
        alert('Invalid date/time format.');
        return;
      }

      customFilterStart = start;
      customFilterEnd = end;

      const totalMinutes = (end - start) / (60 * 1000);
      const slider = document.getElementById('history-slider');
      slider.max = Math.max(totalMinutes, parseFloat(document.getElementById('lightning-lifespan').value) * 60);
      slider.value = totalMinutes;
      slider.min = 0;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      // Sort strikes by time (oldest first) to ensure newer strikes are plotted on top
      currentFiltered.sort((a, b) => a.time.getTime() - b.time.getTime());

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ?
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      document.getElementById('time-range').innerText = `Filter applied: ${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('history-label').innerText = formatTimeAgo(0);
      document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('remove-filter').style.display = 'block';
      updateZIndex();
      updateLegend();
      if (is3DMode) update3DView();
    }
    /**
 * Converts a hex color string (e.g., "#FF8C00") to an RGB array [R, G, B].
 * Assumes a valid 6-digit hex code with optional '#' prefix.
 */
    function hexToRgb(hex) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0]; // Return black on failure
    }

    /**
     * Converts an RGB array [R, G, B] to a 6-digit hex color string.
     */
    function rgbToHex(r, g, b) {
      const toHex = (c) => {
        const hex = Math.round(c).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }
    /**
     * Linearly interpolates between two hex colors based on a confidence score.
     * * @param {string} colorLow - Hex color for the lowest confidence (e.g., #FF8C00).
     * @param {string} colorHigh - Hex color for the highest confidence (e.g., #CC0000).
     * @param {number} confidenceScore - Value between 0.0 and 1.0.
     * @returns {string} The interpolated hex color string.
     */
    function interpolateColor(colorLow, colorHigh, confidenceScore) {
      // 1. Clamp the score between 0 and 1
      const t = Math.max(0, Math.min(1, confidenceScore));

      // 2. Convert hex to RGB arrays
      const rgbLow = hexToRgb(colorLow);
      const rgbHigh = hexToRgb(colorHigh);

      // 3. Linear interpolation for R, G, and B components
      const R_low = rgbLow[0];
      const G_low = rgbLow[1];
      const B_low = rgbLow[2];

      const R_high = rgbHigh[0];
      const G_high = rgbHigh[1];
      const B_high = rgbHigh[2];

      const R = R_low + (R_high - R_low) * t;
      const G = G_low + (G_high - G_low) * t;
      const B = B_low + (B_high - B_low) * t;

      // 4. Convert the interpolated RGB back to a Hex code
      return rgbToHex(R, G, B);
    }
    const LOW_CONFIDENCE_COLOR = '#FF8C00'; // Dark Orange
    const HIGH_CONFIDENCE_COLOR = '#CC0000'; // Deep Red
    // In your loop when drawing a nowcast polygon:


    // Render the polygon with finalFillColor and finalOpacity
    function updateStrikeColors() {
      const colorMode = document.getElementById('color-mode').checked;
      const end = new Date(document.getElementById('end-time').value);
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      strikeCircles.forEach(({ circle, strike }) => {
        let color;
        if (colorMode) {
          const ageFraction = (end - strike.time) / (lifespanHours * 3600 * 1000);
          color = getColorFromAge(ageFraction);
        } else {
          color = 'black';
        }
        circle.setStyle({ color, fillColor: color });
      });
      if (is3DMode) update3DView();
      updateLegend();
    }

    function toggleViewMode() {
      stopAnimation();
      const button = document.getElementById('view-mode');
      showAllStrikes = !showAllStrikes;
      button.innerText = showAllStrikes ? 'Disable all strikes' : 'Enable all strikes';

      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        applyFilter();
      } else {
        updateHistory();
      }
    }

    function updateHeatmap(filtered) {
      if (is3DMode) {
        update3DView();
      } else {
        const data = filtered.map(s => [s.coordinates[1], s.coordinates[0], 1]);
        const blur = parseInt(document.getElementById('blur-slider').value);
        if (heatmapLayer) map.removeLayer(heatmapLayer);

        heatmapLayer = L.heatLayer(data, {
          radius: blur,
          blur: 15,
          maxZoom: 10,
          minZoom: 10,
          gradient: { 0.0: '#001219', 0.1: '#001219', 0.2: '#0A9396', 0.3: '#94D2BD', 0.4: '#E9D8A6', 0.5: '#c89578', 0.6: '#EE9B00', 0.7: '#CA6702', 0.8: '#BB3E03', 0.9: '#AE2012', 1.0: '#9B2226' }
        });

        if (document.getElementById('heatmap-toggle').checked) {
          heatmapLayer.addTo(map);
          heatmapLayer._canvas.style.zIndex = 70;
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleHeatmap() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('heatmap-toggle').checked) {
          if (heatmapLayer) {
            heatmapLayer.addTo(map);
            heatmapLayer._canvas.style.zIndex = 70;
          }
        } else {
          if (heatmapLayer) map.removeLayer(heatmapLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleLightningLayer() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('lightning-layer-toggle').checked) {
          if (!map.hasLayer(strikeLayer)) {
            map.addLayer(strikeLayer);
          }
        } else {
          map.removeLayer(strikeLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleKMLLayer() {
      const toggle = document.getElementById('kml-layer-toggle').checked;
      if (is3DMode) {
        // Remove existing layers and source if they exist
        if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
        if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
        if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');

        if (toggle && kmlGeoJSON) {
          // Add new source and layers only if toggle is enabled and kmlGeoJSON exists
          map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
          map3D.addLayer({
            id: 'kml-layer',
            type: 'fill',
            source: 'kml-source',
            paint: {
              'fill-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                'transparent' // Transparent for Severe risk or unknown
              ],
              'fill-opacity': [
                'match',
                ['get', 'name'],
                'Low risk', 0.3,
                'Slight risk', 0.3,
                'Enhanced risk', 0.3,
                'Moderate risk', 0.3,
                'High risk', 0.3,
                0 // No fill for Severe risk or unknown
              ]
            }
          });
          map3D.addLayer({
            id: 'kml-layer-outline',
            type: 'line',
            source: 'kml-source',
            paint: {
              'line-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                risk_colors['Severe risk'] // Black outline for Severe risk or unknown
              ],
              'line-width': 2,
              'line-opacity': 1
            }
          });
          map3D.resize();
        }
      } else {
        if (toggle && kmlLayer && !map.hasLayer(kmlLayer)) {
          map.addLayer(kmlLayer);
          kmlLayer.setZIndex(60);
        } else if (kmlLayer) {
          map.removeLayer(kmlLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function togglePNGLayer() {
      const toggle = document.getElementById('png-layer-toggle').checked;
      if (is3DMode) {
        if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
        if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        if (toggle && pngImage && pngBounds) {
          map3D.addSource('png-source', {
            type: 'image',
            url: pngImage,
            coordinates: [
              [pngBounds[0][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[0][0]],
              [pngBounds[0][1], pngBounds[0][0]]
            ]
          });
          map3D.addLayer({
            id: 'png-layer',
            type: 'raster',
            source: 'png-source',
            paint: {
              'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
            }
          });
        }
      } else {
        if (toggle && pngLayer && !map.hasLayer(pngLayer)) {
          map.addLayer(pngLayer);
          pngLayer.setZIndex(40);
        } else if (pngLayer) {
          map.removeLayer(pngLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }


    function updateZIndex() {
      const expertMode = document.getElementById('expert-mode').checked;
      const lightningZ = expertMode ? parseInt(document.getElementById('lightning-zindex').value) || 1000 : 1000;
      const heatmapZ = expertMode ? parseInt(document.getElementById('heatmap-zindex').value) || 70 : 70;
      const kmlZ = expertMode ? parseInt(document.getElementById('kml-zindex').value) || 60 : 60;
      const pngZ = expertMode ? parseInt(document.getElementById('png-zindex').value) || 40 : 40;
      const numbersZ = expertMode ? parseInt(document.getElementById('numbers-zindex').value) || 1200 : 1200;
      const nowcastZ = Math.max(kmlZ, pngZ) + 10; // Ensure nowcast is above KML and PNG, but below lightning

      // Remove all layers to re-add them in the correct order
      if (nowcastLayer && map.hasLayer(nowcastLayer)) map.removeLayer(nowcastLayer);
      if (strikeLayer && map.hasLayer(strikeLayer)) map.removeLayer(strikeLayer);
      if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
      if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
      if (heatmapLayer && map.hasLayer(heatmapLayer)) map.removeLayer(heatmapLayer);
      if (numberOverlay && map.hasLayer(numberOverlay)) map.removeLayer(numberOverlay);

      // Add layers back in desired order: heatmap, png, kml, nowcast, lightning, numbers
      if (heatmapLayer && document.getElementById('heatmap-toggle').checked) {
        heatmapLayer._canvas.style.zIndex = heatmapZ;
        map.addLayer(heatmapLayer);
      }
      if (pngLayer && document.getElementById('png-layer-toggle').checked) {
        pngLayer.setZIndex(pngZ);
        map.addLayer(pngLayer);
      }
      if (kmlLayer && document.getElementById('kml-layer-toggle').checked) {
        kmlLayer.setZIndex(kmlZ);
        map.addLayer(kmlLayer);
      }
      if (nowcastLayer && document.getElementById('nowcast-toggle').checked) {
        nowcastLayer.eachLayer(layer => {
          if (layer.setZIndex) layer.setZIndex(nowcastZ);
        });
        nowcastLayer.setZIndex(nowcastZ);
        map.addLayer(nowcastLayer);
      }
      if (strikeLayer && document.getElementById('lightning-layer-toggle').checked) {
        strikeLayer.setZIndex(lightningZ);
        map.addLayer(strikeLayer);
      }
      if (numberOverlay && document.getElementById('number-overlay-toggle').checked) {
        numberOverlay.setZIndex(numbersZ);
        map.addLayer(numberOverlay);
      }

      // In 3D mode, ensure correct layer order by re-adding layers
      if (is3DMode) {
        // Remove existing 3D layers
        if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
        if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
        if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
        if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
        nowcastLayer3D.forEach(layer => {
          if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
          if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
        });
        strikeLayer3D.forEach(marker => marker.remove());
        strikeLayer3D = [];

        // Re-add PNG layer
        if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
          map3D.addSource('png-source', {
            type: 'image',
            url: pngImage,
            coordinates: [
              [pngBounds[0][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[0][0]],
              [pngBounds[0][1], pngBounds[0][0]]
            ]
          });
          map3D.addLayer({
            id: 'png-layer',
            type: 'raster',
            source: 'png-source',
            paint: {
              'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
            }
          });
        }

        // Re-add KML layer
        if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
          map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
          map3D.addLayer({
            id: 'kml-layer',
            type: 'fill',
            source: 'kml-source',
            paint: {
              'fill-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                'transparent'
              ],
              'fill-opacity': [
                'match',
                ['get', 'name'],
                'Low risk', 0.3,
                'Slight risk', 0.3,
                'Enhanced risk', 0.3,
                'Moderate risk', 0.3,
                'High risk', 0.3,
                0
              ]
            }
          });
          map3D.addLayer({
            id: 'kml-layer-outline',
            type: 'line',
            source: 'kml-source',
            paint: {
              'line-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                risk_colors['Severe risk']
              ],
              'line-width': 2,
              'line-opacity': 1
            }
          });
        }

        // Re-add nowcast layers
        if (document.getElementById('nowcast-toggle').checked) {
          currentNowcasts.forEach((cluster, index) => {
            if (cluster.confidenceScore >= minNowcastConfidence) {
              const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                cluster.confidenceScore > 0.8 ? 'red' :
                  cluster.confidenceScore > 0.7 ? 'orange' : 'green';
              const radiusKm = cluster.confidenceScore * 5 + 5;
              const coneRadiusKm = cluster.confidenceScore * 30 + 30;
              const radiusDeg = radiusKm / 111;

              map3D.addSource(`nowcast-circle-${index}`, {
                type: 'geojson',
                data: {
                  type: 'Feature',
                  geometry: {
                    type: 'Point',
                    coordinates: [cluster.baseLon, cluster.baseLat]
                  },
                  properties: { radius: radiusDeg }
                }
              });
              map3D.addLayer({
                id: `nowcast-circle-${index}`,
                type: 'circle',
                source: `nowcast-circle-${index}`,
                paint: {
                  'circle-radius': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    5, (radiusKm * 1000) / 1000,
                    10, (radiusKm * 1000) / 250
                  ],
                  'circle-color': confidenceColor,
                  'circle-opacity': 0.5,
                  'circle-stroke-color': confidenceColor,
                  'circle-stroke-width': 2,
                  'circle-stroke-opacity': 0.8
                }
              });
              nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

              const at = turf.sector(
                [cluster.baseLon, cluster.baseLat],
                coneRadiusKm,
                cluster.directionDeg - 15,
                cluster.directionDeg + 15,
                { units: 'kilometers' }
              );
              map3D.addSource(`nowcast-cone-${index}`, {
                type: 'geojson',
                data: cone
              });
              map3D.addLayer({
                id: `nowcast-cone-${index}`,
                type: 'fill',
                source: `nowcast-cone-${index}`,
                paint: {
                  'fill-color': confidenceColor,
                  'fill-opacity': 0.5
                }
              });
              nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
            }
          });
        }

        // Re-add lightning layer
        if (document.getElementById('lightning-layer-toggle').checked) {
          currentFiltered.forEach(s => {
            const ageFraction = (animationEnd - s.time) / (parseFloat(document.getElementById('lightning-lifespan').value) * 3600 * 1000);
            const el = document.createElement('div');
            el.className = 'marker';
            el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
            el.style.width = '10px';
            el.style.height = '10px';
            el.style.borderRadius = '50%';
            const marker = new mapboxgl.Marker(el)
              .setLngLat([s.coordinates[0], s.coordinates[1]])
              .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
              .addTo(map3D);
            strikeLayer3D.push(marker);
          });
        }
      }
    }

    function updateOverlay(filtered) {
      if (numberOverlay) {
        map.removeLayer(numberOverlay);
        numberOverlay = null;
      }
      numberOverlay3D.forEach(marker => marker.remove());
      numberOverlay3D = [];

      if (!document.getElementById('number-overlay-toggle').checked) return;

      const density = parseInt(document.getElementById('density-slider').value);
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;

      const latStep = (maxLat - minLat) / density;
      const lngStep = (maxLng - minLng) / density;
      const grid = new Map();

      for (let i = 0; i < density; i++) {
        for (let j = 0; j < density; j++) grid.set(`${i}_${j}`, 0);
      }

      filtered.forEach(s => {
        const lat = s.coordinates[1];
        const lng = s.coordinates[0];
        if (lat >= minLat && lat <= maxLat && lng >= minLng && lng <= maxLng) {
          const i = Math.floor((lat - minLat) / latStep);
          const j = Math.floor((lng - minLng) / lngStep);
          const key = `${i}_${j}`;
          if (grid.has(key)) grid.set(key, grid.get(key) + 1);
        }
      });

      if (is3DMode) {
        grid.forEach((count, key) => {
          if (count === 0) return;
          const [i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const el = document.createElement('div');
          el.innerHTML = `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`;
          const marker = new mapboxgl.Marker(el)
            .setLngLat([cellLng, cellLat])
            .addTo(map3D);
          numberOverlay3D.push(marker);
        });
      } else {
        numberOverlay = L.layerGroup();
        grid.forEach((count, key) => {
          if (count === 0) return;
          const [i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const text = L.divIcon({
            html: `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`,
            className: ''
          });
          const marker = L.marker([cellLat, cellLng], { icon: text });
          numberOverlay.addLayer(marker);
        });
        numberOverlay.addTo(map);
        numberOverlay.setZIndex(parseInt(document.getElementById('numbers-zindex').value) || 1200);
      }
      updateZIndex();
    }

    function switchBaseMap(style) {
      Object.values(baseLayers).forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      baseLayers[style].addTo(map);
      updateZIndex();
      map.invalidateSize();
    }

    function playAnimation() {
      if (isPlaying) return;
      isPlaying = true;
      const slider = document.getElementById('history-slider');
      let currentValue = parseFloat(slider.value);
      const maxValue = parseFloat(slider.max);
      const speed = parseFloat(document.getElementById('speed-slider').value); // Minutes per second
      let lastFrameTime = performance.now();

      function animate(currentTime) {
        if (!isPlaying) return;

        const deltaTime = (currentTime - lastFrameTime) / 1000; // Time since last frame in seconds
        lastFrameTime = currentTime;

        // Increment slider value: speed (min/sec) * deltaTime (sec) = minutes to advance
        currentValue += speed * deltaTime;

        if (currentValue >= maxValue) {
          currentValue = maxValue;
          slider.value = currentValue;
          updateHistory();
          stopAnimation();
          return;
        }

        slider.value = currentValue;
        updateHistory();

        animationInterval = requestAnimationFrame(animate);
      }

      animationInterval = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      if (animationInterval) {
        cancelAnimationFrame(animationInterval);
        animationInterval = null;
      }
      isPlaying = false;
    }

    function toggleFullScreen() {
      const container = document.body;
      isFullScreen = !isFullScreen;
      if (isFullScreen) {
        container.classList.add('fullscreen');
        if (document.requestFullscreen) {
          container.requestFullscreen();
        } else if (document.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        } else if (document.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
      } else {
        container.classList.remove('fullscreen');
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
      if (is3DMode) {
        map3D.resize();
      } else {
        map.invalidateSize();
      }
    }

    function updateSpeedSlider() {
      const slider = document.getElementById('speed-slider');
      const textbox = document.getElementById('playback-minutes');
      let value = parseFloat(textbox.value) || 1;
      value = Math.max(1, Math.min(100, value)); // Clamp between 0.01 and 10
      slider.value = value;
      textbox.value = value.toFixed(2);
      if (isPlaying) {
        stopAnimation();
        playAnimation();
      }
    }

    function updateSpeedTextbox() {
      const slider = document.getElementById('speed-slider');
      const textbox = document.getElementById('playback-minutes');
      const value = parseFloat(slider.value);
      textbox.value = value.toFixed(2); // Ensure two decimal places
      if (isPlaying) {
        stopAnimation();
        playAnimation();
      }
    }

    function updatePNGOpacity() {
      const opacity = parseFloat(document.getElementById('png-opacity-slider').value);
      if (is3DMode && map3D.getLayer('png-layer')) {
        map3D.setPaintProperty('png-layer', 'raster-opacity', opacity);
      } else if (pngLayer && map.hasLayer(pngLayer)) {
        pngLayer.setOpacity(opacity);
      }
    }

    function importKML(input) {
      if (!input.files || !input.files[0]) return alert('No KML file selected.');
      const file = input.files[0];
      if (document.getElementById('auto-time-filter').checked && !pendingFile) {
        showTimeFilterModal(file, 'kml');
        return;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const parser = new DOMParser();
          const kml = parser.parseFromString(e.target.result, 'text/xml');
          kmlGeoJSON = toGeoJSON.kml(kml);
          if (kmlLayer) map.removeLayer(kmlLayer);
          kmlLayer = L.geoJSON(kmlGeoJSON, {
            style: function (feature) {
              const name = feature.properties.name || '';
              const isSevere = name === 'Severe risk';
              return risk_colors[name] ? {
                color: risk_colors[name],
                fillColor: isSevere ? 'transparent' : risk_colors[name],
                fillOpacity: isSevere ? 0 : 0.3,
                weight: 2
              } : { color: 'black', fillOpacity: 0 };
            },
            onEachFeature: (f, l) => {
              if (f.properties.name) l.bindPopup(f.properties.name);
            }
          });
          if (document.getElementById('expert-mode').checked) {
            if (document.getElementById('kml-layer-toggle').checked && !is3DMode) {
              kmlLayer.addTo(map);
              kmlLayer.setZIndex(1500);
            }
            if (is3DMode) toggleKMLLayer();
          }
          updateZIndex();
          updateLegend();
        } catch (error) {
          console.error('Error parsing KML:', error);
          alert('Failed to parse KML file.');
        }
      };
      reader.readAsText(file);
    }

    function importPNG(input) {
      if (!input.files || !input.files[0]) return alert('No PNG file selected.');
      const file = input.files[0];
      if (document.getElementById('auto-time-filter').checked && !pendingFile) {
        showTimeFilterModal(file, 'png');
        return;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          pngImage = e.target.result;
          let bounds = region_bounds['UK'];
          for (const [region, regionBounds] of Object.entries(region_bounds)) {
            if (file.name.toLowerCase().includes(region.toLowerCase())) {
              bounds = regionBounds;
              break;
            }
          }
          pngBounds = bounds;
          if (pngLayer) map.removeLayer(pngLayer);
          pngLayer = L.imageOverlay(pngImage, bounds, {
            opacity: parseFloat(document.getElementById('png-opacity-slider').value)
          });
          // Only add layer if Expert Mode is enabled
          if (document.getElementById('expert-mode').checked) {
            if (document.getElementById('png-layer-toggle').checked && !is3DMode) {
              pngLayer.addTo(map);
              pngLayer.setZIndex(1400);
            }
            if (is3DMode) togglePNGLayer();
          }
          updateZIndex();
          updateLegend();
        } catch (error) {
          console.error('Error loading PNG:', error);
          alert('Failed to load PNG file.');
        }
      };
      reader.readAsDataURL(file);
    }
    /**
 * Toggles the display of lightning nowcasts on the 2D map (Leaflet)
 * and draws current clusters as convex hulls, and future projections as
 * expanding, time-stepped polygons, similar to the provided image.
 */
    // NOTE: Assuming all required helper functions (calculatePotentialImpact, getImpactHtml, etc.) 
    // are defined and available in the global scope.

    function toggleNowcast() {

      const minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);

      // 1. Clean up existing layers: CLEAR BOTH OLD cone layer AND NEW polygon layer
      if (typeof nowcastLayer !== 'undefined') {
        nowcastLayer.clearLayers();
      }
      if (typeof polygonNowcastLayer !== 'undefined') {
        polygonNowcastLayer.clearLayers();
      }

      if (document.getElementById('nowcast-toggle').checked && !is3DMode) {

        // Recalculate based on current data
        currentNowcasts = calculateLightningNowcast(currentFiltered);

        currentNowcasts.forEach((cluster) => {
          const confidence = cluster.confidenceScore;

          if (confidence >= minNowcastConfidence) {

            // --- DYNAMIC COLOR AND OPACITY CALCULATION ---
            const confidenceColor = interpolateColor(LOW_CONFIDENCE_COLOR, HIGH_CONFIDENCE_COLOR, confidence);
            const baseOpacity = Math.max(0.2, confidence * 0.8 + 0.2);
            // --- END DYNAMIC CALCULATION ---

            // --- IMPACT CALCULATION & STYLING LOGIC ---
            const potentialImpact = calculatePotentialImpact(cluster.clusterSize, confidence);
            const impactHtml = getImpactHtml(potentialImpact);

            // Determine custom styling based on impact level
            let customStrokeColor = 'red'; // Default border color for hull
            let customStrokeWeight = 2;       // Default border weight for hull
            let forecastStrokeWeight = 1;     // Default border weight for forecasts

            if (potentialImpact.includes('LEVEL 5 - EXTREME') || potentialImpact.includes('LEVEL 4 - HIGH')) {
              // Apply special styling for high-risk alerts
              customStrokeColor = '#8A2BE2'; // BlueViolet/Purple
              customStrokeWeight = 8;        // Thick outline for the hull
              forecastStrokeWeight = 4;      // Thicker outline for the forecast polygons
            }
            // ------------------------------------------

            if (typeof polygonNowcastLayer !== 'undefined') {

              // --- A1. DRAW FUTURE POLYGONS FIRST (BOTTOM LAYERS) ---
              if (cluster.nowcastPolygons && cluster.nowcastPolygons.length > 0) {
                cluster.nowcastPolygons.sort((a, b) => b.timeMinutes - a.timeMinutes);

                cluster.nowcastPolygons.forEach(forecast => {
                  const latLngs = forecast.polygon.map(p => [p[1], p[0]]);

                  const timeDecayFactor = 1.0 - (forecast.timeMinutes / 80);
                  const finalStrokeOpacity = baseOpacity * timeDecayFactor;
                  const finalFillOpacity = baseOpacity * timeDecayFactor * 0.3;

                  L.polygon(latLngs, {
                    // Use conditional weight/color for forecast stroke
                    color: customStrokeColor !== 'black' ? customStrokeColor : confidenceColor,
                    weight: forecastStrokeWeight,
                    opacity: finalStrokeOpacity,
                    fillColor: confidenceColor,
                    fillOpacity: finalFillOpacity,
                    dashArray: '5, 5'
                  }).bindPopup(`
                                <div style="font-size: 14px;">
                                    <h4>üß≠ ${forecast.timeMinutes}-Minute Projection</h4>
                                    <hr style="margin: 4px 0;">
                                    <b>Potential Impact:</b> ${impactHtml}<br>
                                    <b>Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                    <b>Projected Speed:</b> ${cluster.speedKmH.toFixed(1)} km/h<br>
                                    <b>Projected Direction:</b> ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                                </div>
                            `).addTo(polygonNowcastLayer);
                });
              }

              // --- A2. DRAW CURRENT HULL LAST (TOP LAYER - Z-INDEX) ---
              if (cluster.hullGeometry) {

                L.geoJSON(cluster.hullGeometry, {
                  style: {
                    fillColor: confidenceColor,
                    fillOpacity: Math.min(baseOpacity, 0.7),
                    // Apply conditional stroke color and weight
                    color: customStrokeColor,
                    weight: customStrokeWeight,
                    opacity: 0.9
                  }
                }).bindPopup(`
                            <div style="font-size: 14px;">
                                <h4>üå©Ô∏è Current Storm Cell (Hull)</h4>
                                <hr style="margin: 4px 0;">
                                <b>Cell Size:</b> ${cluster.clusterSize} strikes<br>
                                <b>Potential Impact:</b> ${impactHtml}<br>
                                <b>Nowcast Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                <b>Storm Motion:</b> ${cluster.speedKmH.toFixed(1)} km/h @ ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                            </div>
                        `).addTo(polygonNowcastLayer);
              }
            }
          }
        });
      }

      // 2. Toggle layer visibility on the map
      const isChecked = document.getElementById('nowcast-toggle').checked;

      if (typeof polygonNowcastLayer !== 'undefined') {
        if (isChecked && !map.hasLayer(polygonNowcastLayer)) {
          map.addLayer(polygonNowcastLayer);
        } else if (!isChecked && map.hasLayer(polygonNowcastLayer)) {
          map.removeLayer(polygonNowcastLayer);
        }
      }

      if (typeof nowcastLayer !== 'undefined') {
        if (isChecked && !map.hasLayer(nowcastLayer)) {
          map.addLayer(nowcastLayer);
        } else if (!isChecked && map.hasLayer(nowcastLayer)) {
          map.removeLayer(nowcastLayer);
        }
      }

      // Update legend after drawing/clearing
      if (typeof updateLegend === 'function') updateLegend();
    }
    // Note: toggleAllNowcasts() remains unchanged as it just calls drawMergedNowcast()

    /**
     * Renders BOTH the New Polygons and the Old Cones in a single pass.
     */

    // --- MISSING HELPERS FOR POLYGON MATH ---

    function ransacRegression(bins, iterations, threshold, decayConstant) {
      let bestModel = { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };
      let maxInliers = 0;

      for (let i = 0; i < iterations; i++) {
        const sample = randomSample(bins, 2);
        if (sample.length < 2) continue;
        const model = fitLinearModel(sample, decayConstant);

        const inliers = bins.filter(b => {
          const t = (b.time - sample[0].time) / 1000;
          const predLat = model.interceptLat + model.slopeLat * t;
          const predLon = model.interceptLon + model.slopeLon * t;
          return Math.abs(b.lat - predLat) < threshold && Math.abs(b.lon - predLon) < threshold;
        });

        if (inliers.length > maxInliers) {
          maxInliers = inliers.length;
          bestModel = fitLinearModel(inliers.length >= 2 ? inliers : sample, decayConstant);
        }
      }
      return bestModel;
    }

    function getPolygonCentroid(polygon) {
      let sumLon = 0, sumLat = 0;
      for (const p of polygon) { sumLon += p[0]; sumLat += p[1]; }
      return [sumLon / polygon.length, sumLat / polygon.length];
    }

    function translatePolygon(polygon, directionDeg, distanceKm) {
      return polygon.map(point => {
        // Simple approximation or use turf.destination for accuracy
        const dest = turf.destination(turf.point(point), distanceKm, directionDeg, { units: 'kilometers' });
        return dest.geometry.coordinates;
      });
    }

    function scalePolygon(polygon, factor, centroid) {
      if (factor === 1.0) return polygon;
      const [clon, clat] = centroid;
      return polygon.map(point => {
        const [plon, plat] = point;
        const dLon = plon - clon;
        const dLat = plat - clat;
        return [clon + dLon * factor, clat + dLat * factor];
      });
    }

    /**
     * ----------------------------------------------------------------------------------
     * --- GEOSPATIAL HELPER FUNCTIONS ---
     * ----------------------------------------------------------------------------------
     */




    /**
     * Calculates the initial bearing (forward azimuth) between two points (in degrees).
     */

    /**
     * Calculates the Circular Standard Deviation of a list of angles (in degrees).
     * Used to quantify directional consistency (based on Von Mises Distribution).
     */
    function calculateCircularStdDev(angles) {
      if (angles.length < 2) return 90;

      const degToRad = Math.PI / 180;
      let sumSin = 0;
      let sumCos = 0;

      for (const angle of angles) {
        sumSin += Math.sin(angle * degToRad);
        sumCos += Math.cos(angle * degToRad);
      }

      const meanSin = sumSin / angles.length;
      const meanCos = sumCos / angles.length;

      const R_sq = meanSin * meanSin + meanCos * meanCos;
      const V = 1 - Math.sqrt(R_sq); // Circular Variance
      const sigma_c_rad = Math.sqrt(-2 * Math.log(Math.max(1e-9, 1 - V))); // Clamp to prevent log(0)

      // Return in degrees, capped at 90 (max possible deviation for random walk)
      return Math.min(90, sigma_c_rad * 180 / Math.PI);
    }

    /**
     * ----------------------------------------------------------------------------------
     * --- REGRESSION AND RANSAC HELPER FUNCTIONS ---
     * ----------------------------------------------------------------------------------
     */

    function randomSample(array, n) {
      const result = [];
      const indices = Array.from({ length: array.length }, (_, i) => i);
      for (let i = 0; i < n && indices.length > 0; i++) {
        const idx = Math.floor(Math.random() * indices.length);
        result.push(array[indices.splice(idx, 1)[0]]);
      }
      return result;
    }

    /**
     * Fits a weighted linear model and calculates the R2 and residual error.
     */
    function fitLinearModel(bins, decayConstant) {
      let sumT = 0, sumLat = 0, sumLon = 0, sumTLat = 0, sumTLon = 0, sumT2 = 0, sumWeight = 0;
      const baseTime = bins[0].time;
      const maxTime = Math.max(...bins.map(b => b.time));
      const minTime = Math.min(...bins.map(b => b.time));

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;

        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const temporalWeight = 1.0 - (ageRatio * decayConstant);
        const strikeCountWeight = Math.log1p(b.count || 1);
        const weight = temporalWeight * strikeCountWeight;

        sumT += t * weight; sumLat += b.lat * weight; sumLon += b.lon * weight;
        sumTLat += t * b.lat * weight; sumTLon += t * b.lon * weight;
        sumT2 += t * t * weight; sumWeight += weight;
      });

      if (sumWeight === 0) return { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };

      const denominator = sumT2 * sumWeight - sumT * sumT;
      const slopeLat = denominator !== 0 ? (sumTLat * sumWeight - sumT * sumLat) / denominator : 0;
      const slopeLon = denominator !== 0 ? (sumTLon * sumWeight - sumT * sumLon) / denominator : 0;
      const interceptLat = (sumLat - slopeLat * sumT) / sumWeight;
      const interceptLon = (sumLon - slopeLon * sumT) / sumWeight;

      let ssTotLat = 0, ssResLat = 0;
      let ssTotLon = 0, ssResLon = 0;
      const meanLat = sumLat / sumWeight;
      const meanLon = sumLon / sumWeight;
      let weightedResidualSum = 0;

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;

        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const temporalWeight = 1.0 - (ageRatio * decayConstant);
        const strikeCountWeight = Math.log1p(b.count || 1);
        const weight = temporalWeight * strikeCountWeight;

        const predLat = interceptLat + slopeLat * t;
        const predLon = interceptLon + slopeLon * t;

        // Sum of Squares Total (for R2)
        ssTotLat += weight * Math.pow(b.lat - meanLat, 2);
        ssTotLon += weight * Math.pow(b.lon - meanLon, 2);

        // Sum of Squares Residual (for R2)
        ssResLat += weight * Math.pow(b.lat - predLat, 2);
        ssResLon += weight * Math.pow(b.lon - predLon, 2);

        // Weighted Residual Sum (for Weighted Standard Error)
        const residualDistanceKm = calculateDistance([b.lon, b.lat], [predLon, predLat]);
        weightedResidualSum += residualDistanceKm * weight;
      });

      // R2 is the average R2 of Lat and Lon components
      const r2_lat = ssTotLat > 0 ? 1 - ssResLat / ssTotLat : 0;
      const r2_lon = ssTotLon > 0 ? 1 - ssResLon / ssTotLon : 0;
      const r2 = (r2_lat + r2_lon) / 2;

      // Weighted Residual Error (Average Weighted Distance of inliers to the line)
      const weightedResidualErrorKm = sumWeight > 0 ? weightedResidualSum / sumWeight : 100;

      return { slopeLat, slopeLon, interceptLat, interceptLon, r2, weightedResidualErrorKm };
    }



    /**
     * ----------------------------------------------------------------------------------
     * --- CLUSTERING FUNCTION (New Dedicated) ---
     * ----------------------------------------------------------------------------------
     */

    /**
     * ==================================================================================
     * MAIN NOWCAST LOGIC
     * ==================================================================================
     */

    /**
     * Calculates lightning nowcast vectors, confidence, and geometry (Hulls/Polygons).
     * All major constants are dynamically adjusted based on the volume and recency of the lightning data.
     * The confidence calculation is optimized for stability in developing storms.
     * * @param {Array<Object>} lightningData - Time-filtered lightning strikes.
     * @returns {Array<Object>} - Array of calculated storm cluster objects.
     */
    function calculateLightningNowcast(lightningData) {
      if (!lightningData || lightningData.length === 0) return [];

      // --- 0. DYNAMIC PARAMETER CALCULATION & FILTERING ---
      const referenceTime = typeof animationEnd !== 'undefined' && animationEnd ? new Date(animationEnd) : new Date();

      const initialMaxTimeRange = 5 * 3600 * 1000;
      const recentLightning = lightningData.filter(s => (referenceTime.getTime() - s.time.getTime()) <= initialMaxTimeRange);
      const recentLightningLength = recentLightning.length;

      recentLightning.sort((a, b) => a.time.getTime() - b.time.getTime());

      // --- BASE PARAMETER DEFINITION (Dynamic) ---

      const maxDensityTarget = 2000;
      const densityRatio = Math.min(1.0, recentLightningLength / maxDensityTarget); // 0.0 to 1.0

      // --- BALANCED SOFT TIME WINDOW (Gentle nerf, no hard feelings) ---

      // Base dynamic range: high activity ‚Üí shorter window (more precise), low ‚Üí longer
      let baseMaxHours = 4.0 - (2.0 * densityRatio);
      // ‚Üí High density (ratio‚âà1): ~2 hours  
      // ‚Üí Low density (ratio‚âà0): ~4 hours  

      // Gentle penalty only when extremely sparse
      let timePenalty = 1.0;
      if (densityRatio < 0.4) {
        // Smooth quadratic shrink only in very quiet conditions
        timePenalty = 0.6 + 0.4 * Math.pow(densityRatio / 0.4, 1.5);
        // At densityRatio = 0.4 ‚Üí penalty = 1.0 (no shrink)
        // At densityRatio = 0.2 ‚Üí penalty ‚âà 0.75 (25% shrink)
        // At densityRatio = 0.0 ‚Üí penalty ‚âà 0.6 (only 40% shrink ‚Üí still ~2.4 hours)
      }

      // Optional: Light boost from recent strike rate (helps preserve active but spread-out storms)
      const recentHours = 3;
      const recentStrikes = recentLightning.filter(s =>
        (referenceTime.getTime() - s.time.getTime()) <= recentHours * 3600 * 1000
      );
      const strikeRatePerHour = recentStrikes.length / recentHours;

      // If at least moderate ongoing activity, reduce penalty
      if (strikeRatePerHour > 8) {
        timePenalty = Math.max(timePenalty, 0.85);  // Never shrink below 85% if semi-active
      }

      let maxTimeRange = baseMaxHours * 3600 * 1000 * timePenalty;

      // --- Also gently tighten spatial clustering when quiet ---
      let maxDistance = Math.max(15, Math.min(40, 35 - 15 * (1 - densityRatio)));
      // Quiet ‚Üí slightly smaller clusters, but never tiny

      let minClusterSize = Math.max(4, Math.floor(5 + 4 * densityRatio));
      // Low density needs slightly more strikes to qualify ‚Üí avoids noise clusters

      let maxInactivityMs = Math.max(10 * 60 * 1000, 25 * 60 * 1000 * (1.0 - densityRatio * 0.4));
      // Keeps decaying clusters alive a bit longer during lulls

      let maxTemporalSeparation = Math.max(10 * 60 * 1000, 30 * 60 * 1000 * (1.0 - densityRatio * 0.6));

      let ransacIterations = Math.min(250, 100 + Math.floor(recentLightningLength / 2));
      let baseDecayConstant = 0.5 + (0.1 * densityRatio);
      let binSize = 5 * 60 * 1000;
      let jumpAnalysisWindow = 10 * 60 * 1000;

      // NEW CONSTANT: Enforce a speed cap, especially useful for highly stable, slow-moving cells
      const maxSpeedCapKmH = 80;

      const finalLightning = recentLightning.filter(s => (referenceTime.getTime() - s.time.getTime()) <= maxTimeRange);

      // --- 1. CLUSTERING ---
      const clusters = clusterLightningStrikes(finalLightning, { minClusterSize, maxDistance, maxTemporalSeparation });

      // --- PASS 1: RAW VECTORS & CONFIDENCE (Updated for Intensity & Stability) ---
      const rawClusterInfos = [];
      const minBinCountForHighConfidence = 5;

      clusters.forEach((cluster) => {
        const strikeTimes = cluster.map(s => s.time.getTime());
        const minTime = Math.min(...strikeTimes);
        const maxTime = Math.max(...strikeTimes);
        const lastStrikeTime = new Date(maxTime);
        const timeSinceLastStrike = referenceTime.getTime() - lastStrikeTime.getTime();
        const clusterTimeSpanHours = (maxTime - minTime) / (3600 * 1000);

        if (timeSinceLastStrike > maxInactivityMs) return;

        // Binning
        const bins = [];
        for (let t = minTime; t < maxTime; t += binSize) {
          const binStrikes = cluster.filter(s => s.time.getTime() >= t && s.time.getTime() < t + binSize);
          if (binStrikes.length > 0) {
            let sumLat = 0, sumLon = 0, sumWeight = 0;
            binStrikes.forEach(s => {
              const ageRatio = (maxTime - s.time.getTime()) / (maxTime - minTime);
              const weight = 1.0 - (ageRatio * baseDecayConstant);
              sumLat += s.coordinates[1] * weight; sumLon += s.coordinates[0] * weight; sumWeight += weight;
            });
            bins.push({
              time: (t + t + binSize) / 2, lat: sumLat / sumWeight, lon: sumLon / sumWeight, count: binStrikes.length
            });
          }
        }
        if (bins.length === 0) return;

        // Dynamic RANSAC Threshold (as before)
        let ransacThreshold = Math.max(0.03, Math.min(0.1, 0.05 + (clusterTimeSpanHours * 0.02)));


        // RANSAC Regression
        let speedKmH = 0, directionDeg = 0, regressionScore = 0, weightedResidualErrorKm = 100;
        if (bins.length >= 2) {
          const ransacModel = ransacRegression(bins, ransacIterations, ransacThreshold, baseDecayConstant);
          regressionScore = ransacModel.r2;
          weightedResidualErrorKm = ransacModel.weightedResidualErrorKm;
          const latFactor = Math.cos(bins[0].lat * Math.PI / 180);
          const speedLatKmH = ransacModel.slopeLat * 111 * 3600;
          const speedLonKmH = ransacModel.slopeLon * 111 * latFactor * 3600;
          speedKmH = Math.sqrt(speedLatKmH * speedLatKmH + speedLonKmH * speedLonKmH);
          directionDeg = (Math.atan2(speedLonKmH, speedLatKmH) * 180 / Math.PI + 360) % 360;
        } else {
          regressionScore = 0.1;
        }

        // Apply max speed cap to raw calculation
        speedKmH = Math.min(speedKmH, maxSpeedCapKmH);

        // Directional Consistency
        const bearings = [];
        for (let i = 1; i < bins.length; i++) bearings.push(calculateBearing([bins[i - 1].lon, bins[i - 1].lat], [bins[i].lon, bins[i].lat]));
        const circularStdDevDeg = calculateCircularStdDev(bearings);
        const directionalConsistencyScore = 1.0 - (circularStdDevDeg / 90.0);

        // Lightning Jump
        const timeCutoff = referenceTime.getTime() - jumpAnalysisWindow;
        const latestCount = cluster.filter(s => s.time.getTime() >= timeCutoff).length;
        const middleCount = cluster.filter(s => s.time.getTime() < timeCutoff && s.time.getTime() >= timeCutoff - jumpAnalysisWindow).length;
        const lightningJumpDetected = (latestCount > 2.5 * middleCount && latestCount >= 6);
        const lightningJumpBonus = lightningJumpDetected ? 0.35 : 0;

        // Confidence Calculation
        const ratio = Math.min(timeSinceLastStrike / maxInactivityMs, 1.0);
        const decayFactor = Math.pow(1.0 - ratio, 2);
        const clusterSizeScore = Math.min(cluster.length / 50, 1);

        // **UPDATED** Intensity-Adjusted Bin Stability Multiplier
        const binStabilityBoost = 1.0 + (0.1 * clusterSizeScore); // Max 1.1 boost for intense storms
        const binConfidenceMultiplier = Math.min(1.0, (bins.length / minBinCountForHighConfidence) * binStabilityBoost);

        // **UPDATED** Increased weight for stability metrics
        let baseConfidence = (clusterSizeScore * 0.15 +          // Slightly reduced direct cluster size weight
          (speedKmH / maxSpeedCapKmH) * 0.05 +                // Capped speed contribution
          regressionScore * 0.30 +                            // Increased weight for linear fit (stability)
          directionalConsistencyScore * 0.35 +                // Increased weight for consistent direction (stability)
          (bins.length / minBinCountForHighConfidence) * 0.10); // Increased weight for history length

        baseConfidence *= decayFactor;
        baseConfidence *= binConfidenceMultiplier;

        let confidenceScore = Math.min(1.0, baseConfidence + lightningJumpBonus);

        rawClusterInfos.push({
          cluster, baseLat: bins[bins.length - 1].lat, baseLon: bins[bins.length - 1].lon,
          speedKmH, directionDeg, regressionScore, directionalConsistencyScore, weightedResidualErrorKm,
          confidenceScore, clusterSize: cluster.length, lightningJump: lightningJumpDetected, decaying: decayFactor < 0.5,
        });
      });

      // --- PASS 2: SMOOTHING & GEOMETRY GENERATION ---
      const clusterInfos = [];
      const projectionTimeHours = 1.0;
      const maxSmoothingDistanceKm = 50;

      rawClusterInfos.forEach((currentCluster) => {
        // A. Temporal Smoothing
        let moderatedSpeedKmH = currentCluster.speedKmH;
        let moderatedDirectionDeg = currentCluster.cluster.length < minClusterSize ? 0 : currentCluster.directionDeg;

        if (typeof previousNowcasts !== 'undefined' && previousNowcasts.length > 0) {

          // Dynamic Smoothing Factor (as before)
          const dynamicSmoothingFactor = 0.8 - (currentCluster.directionalConsistencyScore * 0.6);

          let nearestPrevNowcast = null;
          let minDistance = Infinity;
          const currentPoint = turf.point([currentCluster.baseLon, currentCluster.baseLat]);

          previousNowcasts.forEach(prevCluster => {
            const prevPoint = turf.point([prevCluster.baseLon, prevCluster.baseLat]);
            const distance = turf.distance(currentPoint, prevPoint, { units: 'kilometers' });

            if (distance < minDistance) {
              minDistance = distance;
              nearestPrevNowcast = prevCluster;
            }
          });

          if (nearestPrevNowcast && minDistance <= maxSmoothingDistanceKm) {
            const distanceRatio = minDistance / maxSmoothingDistanceKm;
            const distanceWeight = 1.0 - distanceRatio;

            const finalWeight = dynamicSmoothingFactor * nearestPrevNowcast.confidenceScore * distanceWeight;
            const inverseWeight = 1.0 - finalWeight;

            const currentU = currentCluster.speedKmH * Math.sin(currentCluster.directionDeg * Math.PI / 180);
            const currentV = currentCluster.speedKmH * Math.cos(currentCluster.directionDeg * Math.PI / 180);
            const prevU = nearestPrevNowcast.speedKmH * Math.sin(nearestPrevNowcast.directionDeg * Math.PI / 180);
            const prevV = nearestPrevNowcast.speedKmH * Math.cos(nearestPrevNowcast.directionDeg * Math.PI / 180);

            const smoothedU = (currentU * inverseWeight) + (prevU * finalWeight);
            const smoothedV = (currentV * inverseWeight) + (prevV * finalWeight);

            moderatedSpeedKmH = Math.sqrt(smoothedU * smoothedU + smoothedV * smoothedV);
            moderatedDirectionDeg = (Math.atan2(smoothedU, smoothedV) * 180 / Math.PI + 360) % 360;

            // Final check: Apply speed cap after smoothing
            moderatedSpeedKmH = Math.min(moderatedSpeedKmH, maxSpeedCapKmH);
          }
        }

        // B. Convex Hull (Current Shape Geometry)
        let hullGeometry = null;
        if (typeof turf !== 'undefined' && currentCluster.cluster.length >= minClusterSize) {
          const points = turf.featureCollection(currentCluster.cluster.map(s => turf.point([s.coordinates[0], s.coordinates[1]])));
          hullGeometry = turf.convex(points);
        }

        // C. FUTURE POLYGON PROJECTION 
        const nowcastPolygons = [];
        if (hullGeometry && hullGeometry.geometry && hullGeometry.geometry.coordinates) {
          const hullCoords = hullGeometry.geometry.coordinates[0];
          const projectionTimesMin = [15, 30, 45, 60];

          for (const tMin of projectionTimesMin) {
            const distanceKm = moderatedSpeedKmH * (tMin / 60);

            const projectedHull = translatePolygon(hullCoords, moderatedDirectionDeg, distanceKm);

            let scaleFactor = 1.0;
            if (currentCluster.lightningJump) scaleFactor = 1.0 + 0.1 * (tMin / 15);
            else if (currentCluster.decaying) scaleFactor = 1.0 - 0.15 * (tMin / 15);
            scaleFactor = Math.max(0.1, scaleFactor);

            const projectedCentroid = getPolygonCentroid(projectedHull);
            const finalHull = scalePolygon(projectedHull, scaleFactor, projectedCentroid);

            nowcastPolygons.push({ timeMinutes: tMin, polygon: finalHull });
          }
        }

        // D. Uncertainty Ellipse
        const directionalErrorDeg = (1.0 - currentCluster.directionalConsistencyScore) * 90;
        const circularStdDevRad = directionalErrorDeg * Math.PI / 180;
        const projectionDistanceKm = moderatedSpeedKmH * projectionTimeHours;
        const semiMinorKm = Math.min(75, Math.max(10, projectionDistanceKm * Math.sin(circularStdDevRad) * 0.7));
        const semiMajorKm = Math.min(150, Math.max(20, projectionDistanceKm + (currentCluster.weightedResidualErrorKm * 3)));

        if (currentCluster.confidenceScore > 0.1) {
          clusterInfos.push({
            baseLat: currentCluster.baseLat, baseLon: currentCluster.baseLon,
            speedKmH: moderatedSpeedKmH,
            directionDeg: moderatedDirectionDeg,
            confidenceScore: currentCluster.confidenceScore, clusterSize: currentCluster.clusterSize,
            hullGeometry: hullGeometry,
            nowcastPolygons: nowcastPolygons,
            uncertaintyEllipse: { semiMajorKm, semiMinorKm, rotationDeg: moderatedDirectionDeg }
          });
        }
      });

      if (typeof previousNowcasts !== 'undefined') {
        previousNowcasts = clusterInfos;
      }

      return clusterInfos;
    }
    /**
     * ==================================================================================
     * HELPER FUNCTIONS (CLUSTERING & MATH)
     * ==================================================================================
     */

    function clusterLightningStrikes(lightningData, params) {
      if (!lightningData || lightningData.length === 0) return [];

      const { minClusterSize, maxDistance, maxTemporalSeparation } = params;
      const localDensityWindowMs = 5 * 60 * 1000;
      const densityDistanceKm = 50;

      const clusters = [];
      const used = new Set();

      for (let i = 0; i < lightningData.length; i++) {
        if (used.has(i)) continue;

        const currentCluster = [];
        const queue = [i];
        used.add(i);

        while (queue.length > 0) {
          const idx = queue.shift();
          const strike = lightningData[idx];
          currentCluster.push(strike);

          const localDensityCount = lightningData.filter(s =>
            (strike.time.getTime() - s.time.getTime()) <= localDensityWindowMs &&
            calculateDistance(strike.coordinates, s.coordinates) <= densityDistanceKm
          ).length;

          const densityFactor = Math.max(0.5, 1.0 - (localDensityCount / 50) * 0.5);
          const dynamicMaxDistance = maxDistance * densityFactor;

          for (let j = 0; j < lightningData.length; j++) {
            if (used.has(j)) continue;
            const neighbor = lightningData[j];
            const dist = calculateDistance(strike.coordinates, neighbor.coordinates);
            const timeDiff = Math.abs(strike.time.getTime() - neighbor.time.getTime());

            if (dist <= dynamicMaxDistance && timeDiff <= maxTemporalSeparation) {
              used.add(j);
              queue.push(j);
            }
          }
        }
        if (currentCluster.length >= minClusterSize) {
          clusters.push(currentCluster);
        }
      }
      return clusters;
    }

    function calculateDistance(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function calculateBearing(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }



    function randomSample(array, n) {
      const result = [];
      const indices = Array.from({ length: array.length }, (_, i) => i);
      for (let i = 0; i < n && indices.length > 0; i++) {
        const idx = Math.floor(Math.random() * indices.length);
        result.push(array[indices.splice(idx, 1)[0]]);
      }
      return result;
    }

    function fitLinearModel(bins, decayConstant) {
      let sumT = 0, sumLat = 0, sumLon = 0, sumTLat = 0, sumTLon = 0, sumT2 = 0, sumWeight = 0;
      const baseTime = bins[0].time;
      const maxTime = Math.max(...bins.map(b => b.time));
      const minTime = Math.min(...bins.map(b => b.time));

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const weight = (1.0 - (ageRatio * decayConstant)) * Math.log1p(b.count || 1);
        sumT += t * weight; sumLat += b.lat * weight; sumLon += b.lon * weight;
        sumTLat += t * b.lat * weight; sumTLon += t * b.lon * weight;
        sumT2 += t * t * weight; sumWeight += weight;
      });

      if (sumWeight === 0) return { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };

      const denominator = sumT2 * sumWeight - sumT * sumT;
      const slopeLat = denominator !== 0 ? (sumTLat * sumWeight - sumT * sumLat) / denominator : 0;
      const slopeLon = denominator !== 0 ? (sumTLon * sumWeight - sumT * sumLon) / denominator : 0;
      const interceptLat = (sumLat - slopeLat * sumT) / sumWeight;
      const interceptLon = (sumLon - slopeLon * sumT) / sumWeight;

      let ssTotLat = 0, ssResLat = 0, ssTotLon = 0, ssResLon = 0, weightedResidualSum = 0;
      const meanLat = sumLat / sumWeight;
      const meanLon = sumLon / sumWeight;

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const weight = (1.0 - (ageRatio * decayConstant)) * Math.log1p(b.count || 1);

        const predLat = interceptLat + slopeLat * t;
        const predLon = interceptLon + slopeLon * t;

        ssTotLat += weight * Math.pow(b.lat - meanLat, 2);
        ssTotLon += weight * Math.pow(b.lon - meanLon, 2);
        ssResLat += weight * Math.pow(b.lat - predLat, 2);
        ssResLon += weight * Math.pow(b.lon - predLon, 2);

        weightedResidualSum += calculateDistance([b.lon, b.lat], [predLon, predLat]) * weight;
      });

      const r2 = ((ssTotLat > 0 ? 1 - ssResLat / ssTotLat : 0) + (ssTotLon > 0 ? 1 - ssResLon / ssTotLon : 0)) / 2;
      const weightedResidualErrorKm = weightedResidualSum / sumWeight;

      return { slopeLat, slopeLon, interceptLat, interceptLon, r2, weightedResidualErrorKm };
    }

    function ransacRegression(bins, iterations, threshold, decayConstant) {
      let bestModel = { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };
      let maxInliers = 0;

      for (let i = 0; i < iterations; i++) {
        const sample = randomSample(bins, 2);
        if (sample.length < 2) continue;
        const model = fitLinearModel(sample, decayConstant);
        const inliers = bins.filter(b => {
          const t = (b.time - sample[0].time) / 1000;
          const predLat = model.interceptLat + model.slopeLat * t;
          const predLon = model.interceptLon + model.slopeLon * t;
          return Math.abs(b.lat - predLat) < threshold && Math.abs(b.lon - predLon) < threshold;
        });
        if (inliers.length > maxInliers) {
          maxInliers = inliers.length;
          bestModel = fitLinearModel(inliers.length >= 2 ? inliers : sample, decayConstant);
        }
      }
      return bestModel;
    }

    /**
     * Calculates a professional, diagnostic risk rating and description based on storm intensity 
     * and prediction confidence. Uses a Level 1 to Level 5 scale.
     */
    function calculatePotentialImpact(clusterSize, confidence) {

      const highConfidence = confidence > 0.8;
      const moderateConfidence = confidence > 0.5;

      // --- Level 5: Extreme Risk (Focus on Size > 3000) ---

      // Catches the most massive cells
      if (clusterSize >= 6000) return `LEVEL 5 - EXTREME: Cell size over 6,000 strikes. Sustained, widespread activity.`;

      // Massive cell with high predictability
      if (clusterSize > 3000 && highConfidence) return `LEVEL 5 - EXTREME: Massive cell with high forecast confidence. Prepare for widespread impact.`;

      // Large cell with strong evidence of consistent, extreme intensity
      if (clusterSize > 1000 && confidence > 0.9) return `LEVEL 5 - EXTREME: Cell highly concentrated (over 1,000 strikes). High predictability.`;


      // --- Level 4: High Risk (Focus on Size 300 - 3000) ---

      // Very large cell, regardless of confidence
      if (clusterSize > 3000) return `LEVEL 4 - HIGH: Very large cell (over 3,000 strikes). High potential for significant coverage.`;

      // Significant size with good predictability
      if (clusterSize > 300 && highConfidence) return `LEVEL 4 - HIGH: Significant cell size with strong directional confidence.`;

      // Large cell, moderate predictability
      if (clusterSize > 1000 && moderateConfidence) return `LEVEL 4 - HIGH: Large area of activity (over 1,000 strikes). Moderate predictability.`;


      // --- Level 3: Moderate Risk (Focus on Size 80 - 300) ---

      // Moderate size with excellent predictability
      if (clusterSize > 80 && highConfidence) return `LEVEL 3 - MODERATE: Concentrated strike cluster with high forecast confidence.`;

      // Medium-large size, moderate predictability
      if (clusterSize > 200 && moderateConfidence) return `LEVEL 3 - MODERATE: Medium-large cell. Maintain situational awareness.`;

      // Large size, low predictability (still requires attention)
      if (clusterSize > 500 && confidence > 0.3) return `LEVEL 3 - MODERATE: Large but disorganized cell. Monitor for consolidation.`;


      // --- Level 2: Minor Risk (Focus on Size 15 - 80) ---

      // Small clusters that are still predictable
      if (clusterSize > 15 && moderateConfidence) return `LEVEL 2 - MINOR: Defined activity cluster. Low potential for local impact.`;

      // General tracking of scattered cells
      if (clusterSize > 5) return `LEVEL 2 - MINOR: Isolated, sparse strike activity tracked.`;


      // --- Level 1: Negligible Risk ---
      return `LEVEL 1 - NEGLIGIBLE: Insignificant activity. Negligible risk.`;
    }
    /**
     * Helper function to convert degrees to cardinal/intercardinal direction.
     */
    function getDirection(degrees) {
      if (degrees > 337.5 || degrees <= 22.5) return "N";
      if (degrees > 22.5 && degrees <= 67.5) return "NE";
      if (degrees > 67.5 && degrees <= 112.5) return "E";
      if (degrees > 112.5 && degrees <= 157.5) return "SE";
      if (degrees > 157.5 && degrees <= 202.5) return "S";
      if (degrees > 202.5 && degrees <= 247.5) return "SW";
      if (degrees > 247.5 && degrees <= 292.5) return "W";
      if (degrees > 292.5 && degrees <= 337.5) return "NW";
      return "";
    }
    // NOTE: Ensure these helper functions are defined in your script scope:
    // getDirection, interpolateColor, LOW_CONFIDENCE_COLOR_HEX, HIGH_CONFIDENCE_COLOR_HEX, calculatePotentialImpact

    // Utility to generate styled HTML for the impact level
    function getImpactHtml(impact) {
      let color;
      let weight = 'normal';

      // Determine color based on the numerical Level
      if (impact.includes('LEVEL 5 - EXTREME')) {
        color = '#FF0000'; // Bright Red
        weight = 'bolder';
      } else if (impact.includes('LEVEL 4 - HIGH')) {
        color = '#FF4500'; // Orange-Red
        weight = 'bold';
      } else if (impact.includes('LEVEL 3 - MODERATE')) {
        color = '#FF8C00'; // Dark Orange
        weight = 'bold';
      } else if (impact.includes('LEVEL 2 - MINOR')) {
        color = '#DAA520'; // Goldenrod/Yellowish
      } else { // LEVEL 1 - NEGLIGIBLE
        color = '#32CD32'; // Green
      }

      // Convert to uppercase for high visibility in the popup
      const formattedImpact = impact.toUpperCase();

      return `<span style="color: ${color}; font-weight: ${weight};">${formattedImpact}</span>`;
    }

    function updateNowcast(filtered) {
      // 1. CLEAR ALL LAYERS (Both 2D and 3D)
      if (typeof polygonNowcastLayer !== 'undefined') {
        polygonNowcastLayer.clearLayers();
      }
      if (typeof nowcastLayer !== 'undefined') {
        nowcastLayer.clearLayers();
      }
      if (typeof nowcastLayer3D !== 'undefined') {
        nowcastLayer3D.forEach(layer => {
          if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
          if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
        });
        nowcastLayer3D = [];
      }

      // 2. CHECK TOGGLE
      if (!document.getElementById('nowcast-toggle').checked) return;

      // 3. CALCULATE NOWCAST WITH FILTERED DATA
      const minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value) || 0.5;
      currentNowcasts = calculateLightningNowcast(filtered);

      // 4. DRAWING LOOP
      currentNowcasts.forEach((cluster, index) => {
        const confidence = cluster.confidenceScore;

        // Skip low confidence
        if (confidence < minNowcastConfidence) return;

        // ============================================================
        // DYNAMIC COLOR & OPACITY CALCULATION
        // HIGH CONFIDENCE => HIGH OPACITY (LOW TRANSPARENCY)
        // ============================================================
        // NOTE: Assuming LOW_CONFIDENCE_COLOR_HEX/HIGH_CONFIDENCE_COLOR_HEX constants are available
        const confidenceColor = interpolateColor(LOW_CONFIDENCE_COLOR, HIGH_CONFIDENCE_COLOR, confidence);

        // Base opacity: Min 0.2 opacity at CS 0.0, Max 1.0 opacity at CS 1.0 (for uncapped use)
        const baseOpacity = Math.max(0.2, confidence * 0.8 + 0.2);
        // ============================================================

        // --- IMPACT CALCULATION & STYLING LOGIC ---
        const potentialImpact = calculatePotentialImpact(cluster.clusterSize, confidence);
        const impactHtml = getImpactHtml(potentialImpact);

        // Determine custom styling based on impact level (Level 4/5 = Purple/Thick)
        let customStrokeColor = 'red'; // Default border color for hull
        let customStrokeWeight = 2;       // Default border weight for hull
        let forecastStrokeWeight = 1;     // Default border weight for forecasts

        if (potentialImpact.includes('LEVEL 5 - EXTREME') || potentialImpact.includes('LEVEL 4 - HIGH')) {
          // Apply special styling for high-risk alerts: Purple and thicker
          customStrokeColor = '#8A2BE2'; // BlueViolet/Purple
          customStrokeWeight = 8;        // Thick outline for the hull
          forecastStrokeWeight = 4;      // Thicker outline for the forecast polygons
        }
        // ------------------------------------------

        // ============================================================
        // 2D MODE (Leaflet)
        // ============================================================
        if (!is3DMode) {

          if (typeof polygonNowcastLayer !== 'undefined') {

            // --- A1. DRAW FUTURE POLYGONS FIRST (BOTTOM LAYERS) ---
            if (cluster.nowcastPolygons && cluster.nowcastPolygons.length > 0) {
              cluster.nowcastPolygons.sort((a, b) => b.timeMinutes - a.timeMinutes);

              cluster.nowcastPolygons.forEach(forecast => {
                const latLngs = forecast.polygon.map(p => [p[1], p[0]]);

                const timeDecayFactor = 1.0 - (forecast.timeMinutes / 80);
                const finalStrokeOpacity = baseOpacity * timeDecayFactor;
                const finalFillOpacity = baseOpacity * timeDecayFactor * 0.3;

                L.polygon(latLngs, {
                  // Use conditional weight/color for forecast stroke
                  color: customStrokeColor !== 'black' ? customStrokeColor : confidenceColor,
                  weight: forecastStrokeWeight,
                  opacity: finalStrokeOpacity,
                  fillColor: confidenceColor,
                  fillOpacity: finalFillOpacity,
                  dashArray: '5, 5'
                }).bindPopup(`
                            <div style="font-size: 14px;">
                                <h4>üß≠ ${forecast.timeMinutes}-Minute Projection</h4>
                                <hr style="margin: 4px 0;">
                                <b>Potential Impact:</b> ${impactHtml}<br>
                                <b>Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                <b>Projected Speed:</b> ${cluster.speedKmH.toFixed(1)} km/h<br>
                                <b>Projected Direction:</b> ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                            </div>
                        `).addTo(polygonNowcastLayer);
              });
            }

            // --- A2. DRAW CURRENT HULL LAST (TOP LAYER - Z-INDEX) ---
            if (cluster.hullGeometry) {
              L.geoJSON(cluster.hullGeometry, {
                style: {
                  fillColor: confidenceColor,
                  // FIX: Hull opacity is capped at 0.7 
                  fillOpacity: Math.min(baseOpacity, 0.7), // Reverted cap to 0.7
                  // Apply conditional stroke color and weight
                  color: customStrokeColor,
                  weight: customStrokeWeight,
                  opacity: 0.9 // Stroke opacity remains high
                }
              }).bindPopup(`
                        <div style="font-size: 14px;">
                            <h4>üå©Ô∏è Current Storm Cell (Hull)</h4>
                            <hr style="margin: 4px 0;">
                            <b>Cell Size:</b> ${cluster.clusterSize} strikes<br>
                            <b>Potential Impact:</b> ${impactHtml}<br>
                            <b>Nowcast Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                            <b>Storm Motion:</b> ${cluster.speedKmH.toFixed(1)} km/h @ ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                        </div>
                    `).addTo(polygonNowcastLayer);
            }
          }


        }

        // ============================================================
        // 3D MODE (Mapbox GL JS) 
        // ============================================================
        else {
          const radiusKm = confidence * 5 + 5;
          const coneRadiusKm = confidence * 30 + 30;
          const radiusDeg = radiusKm / 111;

          // Render Cluster Circle
          const circleId = `nowcast-circle-${index}`;
          map3D.addSource(circleId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [cluster.baseLon, cluster.baseLat] },
              properties: { radius: radiusDeg }
            }
          });
          map3D.addLayer({
            id: circleId,
            type: 'circle',
            source: circleId,
            paint: {
              'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, (radiusKm * 1000) / 1000, 10, (radiusKm * 1000) / 250],
              'circle-color': confidenceColor,
              'circle-opacity': baseOpacity, // Dynamic opacity
              'circle-stroke-width': customStrokeWeight, // Use custom weight for emphasis
              'circle-stroke-color': customStrokeColor // Use custom color for emphasis
            }
          });
          nowcastLayer3D.push({ id: circleId, source: circleId });

          // Render Cone Sector (Cone Sector uses color and fill opacity)
          if (typeof turf !== 'undefined') {
            const cone = turf.sector(
              [cluster.baseLon, cluster.baseLat],
              coneRadiusKm,
              cluster.directionDeg - 15,
              cluster.directionDeg + 15,
              { units: 'kilometers' }
            );
            const coneId = `nowcast-cone-${index}`;
            map3D.addSource(coneId, { type: 'geojson', data: cone });
            map3D.addLayer({
              id: coneId,
              type: 'fill',
              source: coneId,
              paint: {
                'fill-color': confidenceColor,
                'fill-opacity': baseOpacity * 0.5 // Dynamic fill opacity
              }
            });
            nowcastLayer3D.push({ id: coneId, source: coneId });
          }
        }
      });

      // Ensure layers are added to map if visible
      if (!is3DMode) {
        if (typeof polygonNowcastLayer !== 'undefined' && !map.hasLayer(polygonNowcastLayer)) {
          map.addLayer(polygonNowcastLayer);
        }
        if (typeof nowcastLayer !== 'undefined' && !map.hasLayer(nowcastLayer)) {
          map.addLayer(nowcastLayer);
        }
      }

      if (typeof updateLegend === 'function') updateLegend();
    }
    function calculateDistance(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function initializeDragAndDrop() {
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        mapDiv.addEventListener(evt, handleDragDrop, false);
        map3DDiv.addEventListener(evt, handleDragDrop, false);
      });
    }

    function handleDragDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      if (e.type === 'dragenter' || e.type === 'dragover') {
        mapDiv.classList.add('dropzone');
        map3DDiv.classList.add('dropzone');
      } else if (e.type === 'dragleave') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
      } else if (e.type === 'drop') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
        const file = e.dataTransfer.files[0];
        if (!file) return;
        if (file.name.endsWith('.kml')) {
          document.getElementById('kml-file').files = e.dataTransfer.files;
          importKML(document.getElementById('kml-file'));
        } else if (file.name.endsWith('.png')) {
          document.getElementById('png-file').files = e.dataTransfer.files;
          importPNG(document.getElementById('png-file'));
        }
      }
    }

    map.on('moveend', () => {
      if (!is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        const currentBounds = map.getBounds();
        currentFiltered.forEach(s => {
          const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
          const isNewStrike = !lastRenderedStrikes.has(strikeKey);
          const inBounds = currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
          if (isNewStrike && inBounds) {
            playThunderSound();
            addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
          }
        });
      }
    });

    map3D.on('moveend', () => {
      if (is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        update3DView();
      }
    });
    initializeDrawControl();
    initializeDragAndDrop();
    fetchData();
    setRefreshInterval();
    document.addEventListener('DOMContentLoaded', () => {
      // Only add title group on desktop (screen width ‚â•769px)
      if (window.innerWidth >= 769) {
        const topBar = document.getElementById('top-bar');

        const titleGroup = document.createElement('div');
        titleGroup.id = 'title-group';
        titleGroup.innerHTML = `
      <img id="app-logo" 
           src="https://raw.githubusercontent.com/Handry-Outlook/Convective-Outlook/refs/heads/main/Handry_outlook_icon_pride_small.png" 
           alt="RadarLoop UK ‚ö°‚õàÔ∏è">
      <h2 id="app-title">RadarLoop UK ‚ö°‚õàÔ∏è</h2>
    `;

        // Insert in the middle (after draw-toolbar, before right-controls)
        const rightControls = topBar.querySelector('.right-controls');
        topBar.insertBefore(titleGroup, rightControls);
      }

      // Optional: Re-check on resize (e.g., rotating tablet)
      window.addEventListener('resize', () => {
        const titleGroup = document.getElementById('title-group');
        if (window.innerWidth >= 769) {
          if (!titleGroup) {
            // Add it if now desktop
            location.reload(); // Simple way ‚Äî or re-run the injection code
          }
        } else {
          if (titleGroup) {
            titleGroup.remove();
          }
        }
      });
    });
  </script>
  <script>
