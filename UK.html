<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta charset="utf-8">
  <title>RadarLoop</title>
  <link rel="icon" type="image/png"
    href="https://raw.githubusercontent.com/Handry-Outlook/Convective-Outlook/main/Handry_outlook_icon_pride_small.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />

  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.min.js"></script>

  <script>
    console.log("--- Plugin Diagnostic ---");
    console.log("L exists:", typeof L);
    // If L exists, check if L.vectorGrid was created
    if (typeof L !== 'undefined' && typeof L.vectorGrid === 'undefined') {
      console.warn("L.vectorGrid is missing! Checking for Leaflet version conflict...");
    }
    console.log("L.vectorGrid type:", typeof L.vectorGrid);
  </script>

  <style>
    /* ==================== BEAUTIFUL ADDITIONAL CONTROLS ==================== */
    /* ==================== GLOW EFFECT FOR SWITCH CONTROLS WHEN ON ==================== */

    /* ==================== UNIFIED ACTIVE/GLOW STYLES FOR LAYER & SWITCH CONTROLS ==================== */
    .map-style-control {
      background: rgba(255, 255, 255, 0.9);
      border-color: #d0d0d0;
    }

    /* Prevent glow/dimming on Map Style control */
    .map-style-control,
    .map-style-control:hover {
      background: rgba(255, 255, 255, 0.85) !important;
      box-shadow: none !important;
      border-color: #e0e0e0 !important;
      transform: none !important;
    }

    body.dark-mode .map-style-control,
    body.dark-mode .map-style-control:hover {
      background: rgba(45, 45, 45, 0.9) !important;
      border-color: #555 !important;
      box-shadow: none !important;
      transform: none !important;
    }

    body.dark-mode .map-style-control {
      background: rgba(50, 50, 50, 0.95);
      border-color: #666;
    }

    /* No hover lift or glow ‚Äî keep it calm */
    .map-style-control:hover {
      background: rgba(255, 255, 255, 0.95);
      transform: none;
      box-shadow: none;
    }

    body.dark-mode .map-style-control:hover {
      background: rgba(55, 55, 55, 0.95);
    }

    /* Base styles for both control types */
    .layer-control,
    .switch-control {
      padding: 10px 12px;
      margin-bottom: 10px;
      border-radius: 10px;
      border: 1px solid #e0e0e0;
      transition: all 0.3s ease;
      position: relative;
    }

    body.dark-mode .layer-control,
    body.dark-mode .switch-control {
      border-color: #555;
    }

    /* Default (OFF) state - dimmed */
    .layer-control.off,
    .switch-control.glow-off {
      opacity: 0.48;
      transform: none;
    }

    body.dark-mode .layer-control.off,
    body.dark-mode .switch-control.glow-off {
      opacity: 0.45;
    }

    /* Active (ON) state - brighter background + subtle glow */
    .layer-control:not(.off),
    .switch-control.glow-on {
      background: rgba(255, 255, 255, 0.95);
      box-shadow:
        0 2px 8px rgba(33, 150, 243, 0.15),
        0 0 12px rgba(33, 150, 243, 0.25);
      border-color: rgba(33, 150, 243, 0.4);
      transform: translateY(-1px);
    }

    body.dark-mode .layer-control:not(.off),
    body.dark-mode .switch-control.glow-on {
      background: rgba(50, 55, 70, 0.95);
      box-shadow:
        0 2px 10px rgba(75, 155, 255, 0.2),
        0 0 14px rgba(75, 155, 255, 0.35);
      border-color: rgba(75, 155, 255, 0.5);
    }

    /* Hover enhancement when ON */
    .layer-control:not(.off):hover,
    .switch-control.glow-on:hover {
      background: white;
      box-shadow:
        0 4px 16px rgba(33, 150, 243, 0.3),
        0 0 18px rgba(33, 150, 243, 0.45);
      transform: translateY(-2px);
    }

    body.dark-mode .layer-control:not(.off):hover,
    body.dark-mode .switch-control.glow-on:hover {
      background: rgba(60, 65, 80, 0.98);
      box-shadow:
        0 4px 20px rgba(75, 155, 255, 0.4),
        0 0 20px rgba(75, 155, 255, 0.5);
    }

    /* Default background (when no state class) */
    .layer-control,
    .switch-control {
      background: rgba(255, 255, 255, 0.85);
    }

    body.dark-mode .layer-control,
    body.dark-mode .switch-control {
      background: rgba(45, 45, 45, 0.95);
    }

    /* Hover when OFF (gentle lift) */
    .layer-control.off:hover,
    .switch-control.glow-off:hover {
      background: rgba(255, 255, 255, 0.9);
      transform: translateY(-1px);
    }

    body.dark-mode .layer-control.off:hover,
    body.dark-mode .switch-control.glow-off:hover {
      background: rgba(50, 50, 50, 0.95);
    }

    /* ==================== SWITCH-CONTROL SPECIFIC LAYOUT ==================== */

    .switch-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .switch-control .label-group {
      flex: 1;
      min-width: 0;
    }

    .switch-control .label-text {
      font-weight: 600;
      font-size: 0.94em;
      color: #1a2a44;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    body.dark-mode .switch-control .label-text {
      color: #e0e0e0;
    }

    .switch-control .tooltip {
      font-size: 0.78em;
      color: #777;
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: opacity 0.3s ease, max-height 0.3s ease;
      margin-top: 2px;
    }

    body.dark-mode .switch-control .tooltip {
      color: #bbb;
    }

    .switch-control:hover .tooltip {
      opacity: 0.9;
      max-height: 28px;
    }

    .switch-control .toggle-switch {
      width: 54px;
      height: 30px;
      flex-shrink: 0;
    }

    /* ==================== LEGACY PRETTY CHECKBOX (if still used anywhere) ==================== */

    body.dark-mode .pretty-checkbox .checkmark {
      background: #333;
      border-color: #555;
    }

    .pretty-checkbox input:checked~.checkmark {
      background: #2196F3;
      border-color: #2196F3;
    }

    body.dark-mode .pretty-checkbox input:checked~.checkmark {
      background: #4b9bff;
      border-color: #4b9bff;
    }

    .pretty-checkbox input:checked~.checkmark:after {
      content: "‚úì";
      position: absolute;
      color: white;
      font-weight: bold;
      font-size: 14px;
      left: 5px;
      top: 1px;
    }

    body.dark-mode .pretty-checkbox input:checked~.checkmark {
      background: #4b9bff;
      border-color: #4b9bff;
    }

    .pretty-checkbox input:checked~.checkmark:after {
      content: "‚úì";
      position: absolute;
      color: white;
      font-weight: bold;
      font-size: 14px;
      left: 5px;
      top: 1px;
    }

    /* Slider with live value */
    .pretty-slider {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .pretty-slider input[type="range"] {
      height: 8px;
      border-radius: 4px;
      background: #ddd;
      -webkit-appearance: none;
      outline: none;
    }

    .pretty-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #2196F3;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
    }

    body.dark-mode .pretty-slider input[type="range"] {
      background: #444;
    }

    body.dark-mode .pretty-slider input[type="range"]::-webkit-slider-thumb {
      background: #4b9bff;
    }

    .slider-value {
      font-size: 0.88em;
      font-weight: 600;
      color: #2196F3;
      align-self: flex-end;
    }

    body.dark-mode .slider-value {
      color: #6fb3ff;
    }

    /* Styled text/number/datetime inputs */
    .pretty-input input {
      padding: 9px 11px;
      font-size: 0.92em;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: white;
      color: #333;
      outline: none;
      transition: border 0.2s ease;
    }

    .pretty-input input:focus {
      border-color: #2196F3;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }

    body.dark-mode .pretty-input input {
      background: #333;
      color: #e0e0e0;
      border-color: #555;
    }

    body.dark-mode .pretty-input input:focus {
      border-color: #4b9bff;
      box-shadow: 0 0 0 2px rgba(75, 155, 255, 0.3);
    }

    .unit {
      font-size: 0.85em;
      color: #666;
      margin-top: 4px;
    }

    body.dark-mode .unit {
      color: #aaa;
    }

    /* Button group */
    .button-group {
      display: flex;
      gap: 10px;
      margin: 12px 0;
    }

    .button-group button {
      flex: 1;
      padding: 10px;
      font-size: 0.92em;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      background: #2196F3;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .button-group button:hover {
      background: #1976D2;
      transform: translateY(-1px);
    }

    .button-group button:active {
      transform: translateY(0);
    }

    body.dark-mode .button-group button {
      background: #4b9bff;
    }

    body.dark-mode .button-group button:hover {
      background: #3578d6;
    }

    #remove-filter {
      background: #f44336 !important;
    }

    #remove-filter:hover {
      background: #d32f2f !important;
    }

    body.dark-mode #remove-filter {
      background: #f66 !important;
    }

    .smooth-raster {
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: pixelated;
      transform: translateZ(0);
      will-change: transform;
      transition: opacity 0.05s ease;
    }

    .smooth-raster.no-transition {
      transition: none;
    }

    .draw-toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .draw-toolbar button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .seamless-layer {
      /* Ensure layers can transition smoothly */
      transition: opacity 0.3s ease-in-out;
    }

    .draw-toolbar button:hover {
      background: #2563eb;
    }

    .draw-toolbar select {
      padding: 6px;
      border-radius: 4px;
      font-size: 0.9em;
    }

    #polygon-controls {
      background: #ffffff;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode #polygon-controls {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .leaflet-draw {
      z-index: 1003;
    }

    .leaflet-layer-pixelated {
      /* Prevents the browser from smoothly interpolating pixels when scaling up */
      image-rendering: -webkit-optimize-contrast;
      /* For Chrome/Safari */
      image-rendering: -moz-crisp-edges;
      /* For Firefox */
      image-rendering: pixelated;
      /* Standard (and works in most modern browsers) */
    }

    .leaflet-draw-toolbar {
      display: none !important;
      /* Hide default Leaflet.draw toolbar */
    }

    .polygon-popup input,
    .polygon-popup select,
    .polygon-popup button {
      margin: 5px 0;
      padding: 5px;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 768px) {
      .draw-toolbar {
        flex-direction: column;
        align-items: flex-start;
      }

      #top-bar .draw-toolbar {
        display: none;
      }

      #control-panel .draw-toolbar {
        display: flex;
      }
    }

    @media (min-width: 769px) {
      #control-panel .draw-toolbar {
        display: none;
      }

      #top-bar .draw-toolbar {
        display: flex;
      }
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      background: #f4f7fa;
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode {
      background: #1a1a1a;
      color: #e0e0e0;
    }

    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #283673;
      padding: 10px 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 1002;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
      transition: background 0.3s ease;
    }

    /* Center the whole title group */
    #title-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      /* Space between logo and text */
      flex: 1;
      /* Takes middle space */
      pointer-events: none;
      /* Doesn't block underlying clicks */
      opacity: 0;
      /* Hidden on mobile by default */
      transition: opacity 0.3s ease;
    }

    #app-logo {
      height: 42px;
      /* Adjust to match your logo's design */
      width: auto;
      object-fit: contain;
    }

    #app-title {
      margin: 0;
      color: #ffffff;
      font-weight: 600;
      font-size: 1.5em;
      white-space: nowrap;
      /* Prevents text wrapping */
    }

    /* Show only on desktop */
    @media (min-width: 769px) {
      #title-group {
        opacity: 1;
      }
    }

    /* Optional: Slightly smaller on medium screens */
    @media (max-width: 1200px) {
      #app-logo {
        height: 36px;
      }

      #app-title {
        font-size: 1.3em;
      }
    }

    #top-bar>div {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    body.dark-mode #top-bar {
      background: #2a2a2a;
    }

    #top-bar h2 {
      margin: 0;
      color: #ffffff;
      font-weight: 600;
      font-size: 1.2em;
      flex-shrink: 0;
    }

    #top-bar div {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      flex-wrap: nowrap;
      max-width: 50%;
    }

    #top-bar button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      flex-shrink: 0;
      margin-right: 5px;
    }

    #top-bar button:hover {
      background: #2563eb;
    }

    .logo {
      width: 80px;
      pointer-events: none;
      z-index: 1001;
    }

    .leaflet-layer.satellite-layer {
      z-index: 140 !important;
      /* Added transition to help with fade-in/out */
      transition: opacity 0.3s ease-in-out;
    }

    @media (min-width: 769px) {
      .logo {
        position: absolute;
        bottom: 20px;
        right: 15px;
      }
    }

    @media (max-width: 768px) {
      .logo {
        position: absolute;
        top: 70px;
        left: 10px;
      }
    }

    #map,
    #map-3d {
      position: fixed;
      top: 60;
      left: 0;
      width: 100%;
      height: calc(100vh - 60px);
      z-index: 1;
      border-radius: 8px;
    }

    #map-3d {
      display: none;
    }

    #control-panel {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 106;
      padding: 10px;
      transition: background 0.3s ease, color 0.3s ease;
      z-index: 1003;
      overflow-x: hidden;
      direction: rtl
    }

    #control-panel::-webkit-scrollbar {
      width: 8px;
      /* Thin scrollbar for WebKit browsers */
    }

    /* Ensure control panel handles overflow correctly */
    #control-panel {
      padding: 8px;
      /* Consistent with previous compact design */
      width: 280px;
      /* Slightly narrower */
      max-height: calc(100vh - 80px);
      /* Limit height to viewport minus top bar */
      overflow-y: auto;
      /* Vertical scrollbar for overflow */
      overflow-x: hidden;
      /* Prevent horizontal overflow */
      box-sizing: border-box;
      /* Ensure padding is included in width */
    }

    /* Compact section styling */
    .section {
      margin-bottom: 10px;
      padding-bottom: 8px;
    }

    /* Compact labels to constrain sliders */
    .control-panel label {
      font-size: 0.75em;
      margin-bottom: 6px;
      width: 100%;
      /* Ensure label takes full width of container */
      box-sizing: border-box;
      /* Include padding in width */
    }

    /* Constrain sliders to prevent overflow */
    .control-panel input[type="range"] {
      width: 100%;
      /* Full width of parent label */
      max-width: 240px;
      /* Limit slider width to fit within control panel */
      height: 6px;
      /* Compact height */
      background: #d1d5db;
      border-radius: 3px;
      margin: 2px 0;
      /* Reduced margin to minimize vertical space */
      padding: 0;
      /* Remove any padding */
      box-sizing: border-box;
      /* Ensure width includes all components */
    }

    /* Smaller slider thumbs */
    .control-panel input[type="range"]::-webkit-slider-thumb {
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -3px;
      /* Adjust thumb position to align with track */
    }

    .control-panel input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Dark mode slider styling */
    body.dark-mode .control-panel input[type="range"] {
      background: #555;
    }

    body.dark-mode .control-panel input[type="range"]::-webkit-slider-thumb {
      background: #4b9bff;
      /* Match dark mode button color */
    }

    body.dark-mode .control-panel input[type="range"]::-moz-range-thumb {
      background: #4b9bff;
    }

    /* Ensure other inputs and buttons remain compact */
    .control-panel input,
    .control-panel select,
    .control-panel button {
      padding: 4px;
      font-size: 0.75em;
      border-radius: 3px;
      width: 100%;
      /* Ensure full width within container */
      max-width: 240px;
      /* Consistent with slider width */
      box-sizing: border-box;
    }

    /* Compact checkboxes */
    .control-panel input[type="checkbox"] {
      transform: scale(0.8);
      margin-top: 2px;
      width: auto;
      /* Override max-width for checkboxes */
    }

    /* Ensure draw-toolbar elements are compact */
    .draw-toolbar button,
    .draw-toolbar select {
      padding: 4px 8px;
      font-size: 0.75em;
      border-radius: 3px;
      max-width: 240px;
      /* Constrain to fit within control panel */
    }

    /* Thin scrollbar */
    #control-panel::-webkit-scrollbar {
      width: 6px;
    }

    #control-panel::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 3px;
    }

    #control-panel::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    #control-panel::-webkit-scrollbar-thumb {
      background: #555;
      /* Dark mode thumb */
      border-radius: 4px;
    }

    #control-panel::-webkit-scrollbar-thumb:hover {
      background: #777;
      /* Lighter on hover */
    }

    #control-panel>* {
      direction: ltr;
      /* Reset content direction to normal */
    }

    body.dark-mode #control-panel {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    @media (min-width: 769px) {
      #control-panel {
        position: fixed;
        top: 60px;
        left: 20px;
        width: 300px;
        height: calc(100% - 80px);
        overflow-y: auto;
      }

      #map,
      #map-3d {
        left: 340px;
        width: calc(100% - 340px);
      }
    }

    @media (max-width: 768px) {
      #control-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        overflow-y: auto;
      }

      #control-panel.open {
        display: block;
      }

      #settings-button {
        position: fixed;
        top: 80px;
        right: 30px;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 1.2em;
        cursor: pointer;
        z-index: 1004;
      }

      #settings-button:hover {
        background: #2563eb;
      }

      #fullscreen-button,
      .fullscreen-toggle {
        display: none;
      }
    }

    .section {
      margin-bottom: 15px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 10px;
    }

    body.dark-mode .section {
      border-bottom: 1px solid #444;
    }

    .section h4 {
      margin: 0 0 10px;
      color: #1a2a44;
      font-weight: 600;
      font-size: 0.9em;
    }

    body.dark-mode .section h4 {
      color: #e0e0e0;
    }

    .control-panel label {
      display: flex;
      flex-direction: column;
      font-size: 0.8em;
      color: #1a2a44;
      font-weight: 500;
      margin-bottom: 8px;
      position: relative;
    }

    body.dark-mode .control-panel label {
      color: #e0e0e0;
    }

    .control-panel label span.tooltip {
      display: none;
      position: absolute;
      top: -30px;
      left: 0;
      background: #333;
      color: white;
      padding: 5px;
      border-radius: 4px;
      font-size: 0.7em;
      white-space: nowrap;
    }

    body.dark-mode .control-panel label span.tooltip {
      background: #555;
    }

    .control-panel label:hover span.tooltip {
      display: block;
    }

    .control-panel input,
    .control-panel select,
    .control-panel button {
      margin-top: 3px;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8em;
      background: #fff;
      color: #1a2a44;
      transition: background 0.3s ease, color 0.3s ease, border 0.3s ease;
    }

    body.dark-mode .control-panel input,
    body.dark-mode .control-panel select,
    body.dark-mode .control-panel button {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .control-panel input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }

    body.dark-mode .control-panel input[type="range"] {
      background: #555;
    }

    .control-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-panel input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-panel input[type="checkbox"] {
      margin-top: 3px;
      accent-color: #3b82f6;
    }

    .control-panel button,
    #remove-filter {
      background: #3b82f6;
      color: white;
      border: none;
      cursor: pointer;
    }

    .control-panel button:hover,
    #remove-filter:hover {
      background: #2563eb;
    }

    #expert-controls {
      display: none;
      padding: 10px;
      background: #f9fafb;
      border-radius: 6px;
      transition: background 0.3s ease;
    }

    body.dark-mode #expert-controls {
      background: #333;
    }

    .time-slider-container {
      position: fixed;
      bottom: 20px;
      background: #ffffff;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-sizing: border-box;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode .time-slider-container {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    @media (min-width: 769px) {
      .time-slider-container {
        left: 340px;
        width: calc((100% - 340px) * 0.8);
        left: calc(340px + ((100% - 340px) - ((100% - 340px) * 0.8)) / 2);
      }
    }

    @media (max-width: 768px) {
      .time-slider-container #history-time {
        font-size: 0.7em;
      }

      .time-slider-container {
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
      }
    }

    .time-slider-container .animator {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .time-slider-container button {
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
    }

    .time-slider-container button:hover {
      background: #2563eb;
    }

    .slider {
      width: 100%;
      -webkit-appearance: none;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }

    body.dark-mode .slider {
      background: #555;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }

    .time-slider-container .status-info {
      font-size: 0.75em;
      color: #1a2a44;
      margin: 0;
    }

    body.dark-mode .time-slider-container .status-info {
      color: #e0e0e0;
    }

    .status-info-container {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 4px;
    }

    .legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      font-size: 0.75em;
      color: #1a2a44;
      max-width: 200px;
      /* Increased from 125px to make the legend wider */
      min-width: 150px;
      /* Increased from 110px for consistency with wider design */
      max-height: 300px;
      /* Set maximum height to limit vertical size */
      overflow-y: auto;
      /* Enable vertical scrolling when content exceeds max-height */
      position: absolute;
      top: 10px;
      /* Consistent 10px margin from top */
      right: 10px;
      /* Consistent 10px margin from right */
      z-index: 1010;
      /* High z-index to stay above map elements */
      transition: background 0.3s ease, color 0.3s ease;
    }

    /* Optional: Style the scrollbar for better aesthetics (works in WebKit browsers like Chrome/Safari) */
    .legend::-webkit-scrollbar {
      width: 8px;
      /* Width of the scrollbar */
    }

    .legend::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      /* Light track background */
      border-radius: 4px;
    }

    .legend::-webkit-scrollbar-thumb {
      background: rgba(26, 42, 68, 0.5);
      /* Match color scheme (#1a2a44 with opacity) */
      border-radius: 4px;
    }

    .legend::-webkit-scrollbar-thumb:hover {
      background: rgba(26, 42, 68, 0.8);
      /* Darker on hover */
    }

    .fullscreen .legend {
      right: 10px;
      /* Ensure 10px margin */
      top: 10px;
    }

    body.three-d-mode .legend {
      right: 10px;
      /* Ensure 10px margin */
      top: 10px;
    }

    @media (min-width: 769px) {
      .legend {
        right: calc(10px + 340px);
        /* Adjust for map offset */
      }
    }

    body.dark-mode .legend {
      background: rgba(40, 40, 40, 0.95);
      color: #e0e0e0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }

    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 8px;
      vertical-align: middle;
    }

    .gradient-bar {
      height: 10px;
      width: 100%;
    }

    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 1555;
      max-width: 90%;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode .modal {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    #tutorial-modal {
      max-height: 80vh;
      overflow-y: auto;
      width: 70%;
      max-width: 70vh;
      padding: 20px;
    }

    @media (max-width: 768px) {
      #tutorial-modal {
        width: 70%;
        max-height: 85vh;
        padding: 15px;
      }
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1004;
    }

    .hidden {
      display: none;
    }

    #fullscreen-button {
      position: fixed;
      bottom: 20px;
      right: 10px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 1004;
    }

    .user-location-marker {
      background-color: #3b82f6;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
      }
    }

    .fullscreen #map,
    .fullscreen #map-3d {
      width: 100vw;
      height: 1calc(100vh - 60px);
      left: 0;
      overflow: hidden
    }

    .fullscreen #control-panel {
      display: none;
    }

    .fullscreen .time-slider-container {
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
    }

    #map {
      position: absolute;
      top: 60px;
      bottom: 0;
      width: 100%;
      z-index: 1;
      transition: opacity 0.3s ease;
    }

    #map3D {
      position: absolute;
      top: 60px;
      bottom: 0;
      width: 100%;
      z-index: 2;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    /* ==================== FINAL COMPACT LAYER CONTROL WITH OPACITY ==================== */

    .layer-control {
      display: flex;
      flex-direction: column;
      gap: 7px;
      padding: 11px;
      margin-bottom: 9px;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 12px;
      border: 1px solid #e0e0e0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: all 0.25s ease;
    }

    body.dark-mode .layer-control {
      background: rgba(45, 45, 45, 0.95);
      border-color: #555;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    /* Dimmed state when layer is toggled off */
    .layer-control.off {
      opacity: 0.48;
    }

    /* Hover effect for better interactivity */
    .layer-control:hover {
      background: rgba(255, 255, 255, 0.95);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
    }

    body.dark-mode .layer-control:hover {
      background: rgba(55, 55, 55, 0.95);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Top row: Layer name + Toggle switch */
    .top-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: 34px;
    }

    .label-group {
      flex: 1;
      min-width: 0;
      /* Essential for text truncation */
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .label-text {
      font-weight: 600;
      font-size: 0.96em;
      color: #1a2a44;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    body.dark-mode .label-text {
      color: #f0f0f0;
    }

    /* Tooltip (description) - appears on hover */
    .tooltip {
      font-size: 0.79em;
      color: #777;
      font-weight: 400;
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: opacity 0.35s ease, max-height 0.35s ease;
    }

    body.dark-mode .tooltip {
      color: #bbb;
    }

    .layer-control:hover .tooltip {
      opacity: 0.9;
      max-height: 28px;
    }

    /* Compact toggle switch */
    .toggle-switch {
      position: relative;
      width: 54px;
      height: 30px;
      flex-shrink: 0;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch .switch {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #bbb;
      border-radius: 30px;
      transition: background-color 0.3s ease;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15);
    }

    .toggle-switch .switch:before {
      content: "";
      position: absolute;
      width: 26px;
      height: 26px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      border-radius: 50%;
      transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
    }

    .toggle-switch input:checked+.switch {
      background-color: #2196F3;
    }

    .toggle-switch input:checked+.switch:before {
      transform: translateX(24px);
    }

    /* ON/OFF labels inside switch */
    .toggle-switch .switch::after {
      content: "OFF";
      position: absolute;
      top: 50%;
      left: 8px;
      transform: translateY(-50%);
      font-size: 0.62em;
      font-weight: bold;
      color: white;
      opacity: 0.9;
    }

    .toggle-switch input:checked+.switch::after {
      content: "ON";
      left: auto;
      right: 7px;
    }

    /* Dropdown - full width */
    .layer-control select {
      width: 100%;
      padding: 9px 11px;
      font-size: 0.89em;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: white;
      color: #333;
      outline: none;
      transition: border-color 0.2s ease;
    }

    .layer-control select:focus {
      border-color: #2196F3;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }

    body.dark-mode .layer-control select {
      background: #333;
      color: #e0e0e0;
      border-color: #555;
    }

    body.dark-mode .layer-control select:focus {
      border-color: #4b9bff;
      box-shadow: 0 0 0 2px rgba(75, 155, 255, 0.3);
    }

    .layer-control select:disabled {
      opacity: 0.4;
      background: #f8f8f8;
      cursor: not-allowed;
    }

    body.dark-mode .layer-control select:disabled {
      background: #2a2a2a;
    }

    /* Opacity control with live percentage */
    .opacity-control {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 6px;
    }

    .opacity-control input[type="range"] {
      flex: 1;
      height: 7px;
      border-radius: 4px;
      background: #d0d0d0;
      outline: none;
      -webkit-appearance: none;
    }

    .opacity-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #2196F3;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      transition: transform 0.2s ease;
    }

    .opacity-control input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15);
    }

    .opacity-control input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #2196F3;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
    }

    body.dark-mode .opacity-control input[type="range"] {
      background: #555;
    }

    body.dark-mode .opacity-control input[type="range"]::-webkit-slider-thumb,
    body.dark-mode .opacity-control input[type="range"]::-moz-range-thumb {
      background: #4b9bff;
    }

    .opacity-value {
      font-size: 0.84em;
      font-weight: 600;
      color: #444;
      min-width: 44px;
      text-align: right;
    }

    body.dark-mode .opacity-value {
      color: #ddd;
    }

    /* Dim opacity control when layer is off */
    .layer-control.off .opacity-control {
      opacity: 0.55;
    }

    /* Optional: Slightly larger touch targets on mobile */
    @media (max-width: 768px) {
      .layer-control {
        padding: 12px;
      }

      .toggle-switch {
        width: 58px;
        height: 32px;
      }

      .toggle-switch .switch:before {
        width: 28px;
        height: 28px;
      }

      .toggle-switch input:checked+.switch:before {
        transform: translateX(26px);
      }

      .opacity-control input[type="range"]::-webkit-slider-thumb {
        width: 20px;
        height: 20px;
      }
    }

    body.three-d-mode #map {
      opacity: 0;
      /* Hide 2D map but keep it functional */
      pointer-events: none;
      /* Prevent interactions except for popups */
      height: 0;
      /* Minimize impact on layout */
      overflow: hidden;
    }

    body.three-d-mode #map3D {
      opacity: 1;
      /* Show 3D map */
    }

    .mapboxgl-ctrl-group {
      z-index: 1100 !important;
      /* Ensure mapbox-gl-draw controls are above top bar */
      margin-top: 70px !important;
      /* Move controls below top bar */
    }

    #expert-controls button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      margin-top: 5px;
      width: 100%;
      transition: background 0.3s ease;
    }

    #expert-controls button:hover {
      background: #2563eb;
    }

    body.dark-mode #expert-controls button {
      background: #4b9bff;
      color: #e0e0e0;
    }

    body.dark-mode #expert-controls button:hover {
      background: #3578d6;
    }

    .modal h3 {
      margin-top: 0;
      font-size: 1.1em;
      color: #1a2a44;
    }

    body.dark-mode .modal h3 {
      color: #e0e0e0;
    }

    .modal p {
      font-size: 0.9em;
      color: #1a2a44;
      margin: 10px 0;
    }

    body.dark-mode .modal p {
      color: #e0e0e0;
    }

    .modal label {
      display: block;
      font-size: 0.8em;
      color: #1a2a44;
      margin: 8px 0;
    }

    body.dark-mode .modal label {
      color: #e0e0e0;
    }

    .modal input[type="text"],
    .modal input[type="datetime-local"],
    .modal input[type="checkbox"] {
      width: 100%;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8em;
      background: #fff;
      color: #1a2a44;
      box-sizing: border-box;
      margin-top: 3px;
    }

    body.dark-mode .modal input[type="text"],
    body.dark-mode .modal input[type="datetime-local"],
    body.dark-mode .modal input[type="checkbox"] {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .modal input[type="checkbox"] {
      width: auto;
      accent-color: #3b82f6;
    }

    .modal button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      margin: 5px 5px 0 0;
    }

    .modal button:hover {
      background: #2563eb;
    }

    body.dark-mode .modal button {
      background: #4b9bff;
    }

    body.dark-mode .modal button:hover {
      background: #3578d6;
    }

    /* Adjust 3D map position in normal mode */
    #map-3d {
      position: absolute;
      top: 60px;
      /* Match 2D map offset to avoid top bar overlap */
      left: 0;
      width: 100%;
      height: calc(100vh - 60px);
      /* Adjust height to fit viewport minus top bar */
      z-index: 2;
      display: none;
      /* Preserve existing behavior */
      overflow: hidden;
    }

    /* Desktop mode with control panel */
    @media (min-width: 769px) {
      #map-3d {
        left: 340px;
        /* Match 2D map offset for control panel */
        width: calc(100% - 340px);
        height: calc(100vh - 60px);
        /* Maintain height */
      }
    }

    /* Fullscreen mode */
    .fullscreen #map-3d {
      top: 0;
      /* No offset needed in fullscreen */
      left: 0;
      width: 100vw;
      height: 100vh;
      /* Full viewport height */
      overflow: hidden;
    }

    /* Ensure 3D mode visibility */
    body.three-d-mode #map-3d {
      display: block;
      /* Show 3D map */
      opacity: 1;
    }
  </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M5QDT7XR39"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'G-M5QDT7XR39');
</script>

<body class="dark-mode">
  <div id="top-bar">
    <div class="draw-toolbar">
      <button onclick="toggleDrawing()">Enable Drawing</button>
      <select id="risk-level-select">
        <option value="Low risk">Low risk</option>
        <option value="Slight risk">Slight risk</option>
        <option value="Enhanced risk">Enhanced risk</option>
        <option value="Moderate risk">Moderate risk</option>
        <option value="High risk">High risk</option>
        <option value="Severe risk">Severe risk</option>
      </select>
      <button onclick="exportToKML()">Export KML</button>
    </div>
    <!-- NEW: Centered logo + title group -->

    <div class="right-controls">
      <button onclick="toggleDarkMode()">‚òÄÔ∏è Light Mode</button>
      <button onclick="toggleLegend()">Toggle Legend</button>
      <button onclick="showTutorial()">Help</button>
      <button onclick="showUserLocation()">üìç</button>
      <button class="fullscreen-toggle" onclick="toggleFullScreen()">‚õ∂</button>
    </div>
  </div>
  <div id="control-panel" class="control-panel">

    <div class="section">
      <h4>üó∫Ô∏è Map Style</h4>
      <div class="layer-control map-style-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Map Background</span>
            <span class="tooltip">Choose map background style</span>
          </div>
        </div>

        <select id="map-style" onchange="switchBaseMap(this.value)">
          <option value="mapbox-streets-satellite">Mapbox Streets-Satellite</option>
          <option value="mapbox-navigation">Mapbox Navigation</option>
          <option value="mapbox-traffic-night">Mapbox Traffic Night</option>
          <option value="mapbox-traffic-day">Mapbox Traffic Day</option>
          <option value="custom">Mapbox Classic</option>
          <option value="mapbox-satellite">Mapbox Satellite</option>
          <option value="mapbox-outdoors">Mapbox Outdoors</option>
          <option value="mapbox-dark">Mapbox Dark</option>
          <option value="mapbox-light">Mapbox Light</option>
          <option value="mapbox-navigation-night">Mapbox Navigation Night</option>
          <option value="osm">OpenStreetMap</option>
          <option value="opentopo">OpenTopoMap</option>
          <option value="esri">Esri World Imagery</option>
          <option value="maptiler-streets">MapTiler Streets</option>
          <option value="maptiler-outdoor">MapTiler Outdoor</option>
          <option value="maptiler-light">MapTiler Light</option>
          <option value="maptiler-dark">MapTiler Dark</option>
        </select>
      </div>

      <div class="section"></div>
      <h4>‚õàÔ∏è Weather Layers</h4>

      <!-- Radar Layer - ON -->
      <div class="layer-control" id="radar-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Radar Layer</span>
            <span class="tooltip">Select radar data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="radarToggle" checked onchange="toggleLayer('radar', this.checked);">
            <label for="radarToggle" class="switch"></label>
          </div>
        </div>
        <select id="radarLayer" onchange="radarLayerTypeHandler();">
          <option value="uk-precip-intensity">UK High Resolution Rainfall Intensity (Smoothed)</option>
          <option value="uk-precip-intensity-pixelated">UK High Resolution Rainfall Intensity (Pixelated)</option>
          <option value="uk-precip-intensity-accessible">UK High Resolution Rainfall Intensity (Accessible)</option>
          <option value="uk-precip-type">UK High Resolution Precipitation Type</option>
          <option value="europe-precip-intensity">Europe Low Resolution Rainfall Intensity</option>
          <option value="europe-precip-type">Europe Low Resolution Precipitation Type</option>
          <option value="radar-precip-intensity-global-raster">Global Rainfall Intensity</option>
          <option value="placeholder" disabled>-------------------------------------------------------------------------
          </option>
          <option value="global-precip-intensity">Precipitation - NASA global precipitation intensity</option>
          <option value="placeholder" disabled>-------------------------------------------------------------------------
          </option>
          <option value="radar-base-ref-precip-type-na-contours">North America Base Reflectivity Precip - Contour
          </option>
          <option value="radar-base-ref-precip-type-europe-contours">Europe Base Reflectivity Precip - Contour</option>
          <option value="radar-base-ref-precip-type-australia-contours">Australia Base Reflectivity Precip - Contour
          </option>
          <option value="radar-base-ref-precip-type-westpacific-contours">West Pacific Base Reflectivity Precip -
            Contour</option>
          <option value="radar-max-ref-precip-type-na-contours">North America Max Reflectivity Precip</option>
          <option value="radar-max-ref-precip-type-australia-contours">Australia Max Reflectivity Precip</option>
          <option value="radar-precip-rate-europe-contours">Radar Precipitation Rate - Contour (Europe)</option>
          <option value="radar-precip-rate-europe-raster">Radar Precipitation Rate - Grid (Europe)</option>
          <option value="radar-reflectivity-mosaic-global-contours">Synthetic Radar - Contour (Global)</option>
          <option value="radar-reflectivity-mosaic-global-raster">Synthetic Radar - Grid (Global)</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="radarOpacity" min="0" max="1" step="0.05" value="0.9"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">90%</span>
        </div>
      </div>

      <!-- Satellite Layer - ON -->
      <div class="layer-control" id="satellite-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Satellite Layer</span>
            <span class="tooltip">Select satellite data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="satelliteToggle" checked onchange="toggleLayer('satellite', this.checked);">
            <label for="satelliteToggle" class="switch"></label>
          </div>
        </div>
        <select id="satelliteLayerSelect" onchange="satelliteLayerTypeHandler();">
          <option value="global-ir">Satellite - Global infrared (GOES)</option>
          <option value="europe-vis">Satellite - Europe visible (MeteoSat)</option>
          <option value="europe-ir">Satellite - Europe infrared (MeteoSat)</option>
          <option value="europe-water">Satellite - Europe water vapor (MeteoSat)</option>
          <option value="us-visible">Satellite - North America visible (GOES)</option>
          <option value="us-ir">Satellite - North America infrared (GOES)</option>
          <option value="satellite-infrared-enhanced-global-raster">Global Enhanced Infrared</option>
          <option value="satellite-visible-global-raster">Global Visible</option>
          <option value="satellite-water-vapor-global-raster">Global Water Vapor</option>
          <option value="satellite-night-fog-global-raster">Global Night Fog</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="satelliteOpacity" min="0" max="1" step="0.05" value="0.5"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">50%</span>
        </div>
      </div>

      <!-- Isobar Layer - ON -->
      <div class="layer-control" id="isobar-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Isobar Layer</span>
            <span class="tooltip">Select isobar data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="isobarToggle" checked onchange="toggleLayer('isobar', this.checked);">
            <label for="isobarToggle" class="switch"></label>
          </div>
        </div>
        <select id="isobarLayerSelect" onchange="isobarLayerTypeHandler();">
          <option value="pressure_two">Mean Sea Level Pressure (every 2 hPa)</option>
          <option value="pressure_four">Mean Sea Level Pressure (every 4 hPa)</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="isobarOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>
      <!-- Surface Front Layer - ON -->
      <div class="layer-control" id="surfaceFront-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Surface Front Layer</span>
            <span class="tooltip">Select Surface Fronts layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="surfaceFrontToggle" checked
              onchange="toggleLayer('surfaceFront', this.checked);">
            <label for="surfaceFrontToggle" class="switch"></label>
          </div>
        </div>
        <select id="surfaceFrontLayerSelect" onchange="surfaceFrontLayerTypeHandler();">
          <option value="fcst-surface-fronts-isolines">Surface Fronts</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="surfaceFrontOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>
      <!-- Wind Direction Layer - ON -->
      <div class="layer-control" id="wind-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Wind Direction Layer</span>
            <span class="tooltip">Select wind direction data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="windToggle" checked onchange="toggleLayer('wind', this.checked);">
            <label for="windToggle" class="switch"></label>
          </div>
        </div>
        <select id="windLayerSelect" onchange="windLayerTypeHandler();">
          <option value="wind-direction">Wind direction</option>
          <option value="fcst-manta-current-direction-grid">Current Direction</option>
          <option value="fcst-manta-mean-wave-direction-grid">Mean Wave Direction</option>
          <option value="fcst-manta-significant-wave-symbol-grid">Significant Wave Height Direction</option>
          <option value="fcst-manta-swell-wave-symbol-grid">Swell Wave Direction</option>
          <option value="fcst-sea-wave-height-swell-waves-period-grid">Swell Waves Period Direction</option>
          <option value="fcst-manta-wind-wave-symbol-grid">Wind Wave Directions</option>
          <option value="fcst-sea-wave-height-wind-waves-period-grid">Wind Waves Period Direction</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="windOpacity" min="0" max="1" step="0.05" value="0.8" oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>
      <!-- Global Nowcast Layer - ON -->
      <div class="layer-control" id="nowcast-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Global Nowcast Layer</span>
            <span class="tooltip">Select Global Nowcast data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="nowcastToggle" checked onchange="toggleLayer('nowcast', this.checked);">
            <label for="nowcastToggle" class="switch"></label>
          </div>
        </div>
        <select id="nowcastLayerSelect" onchange="nowcastLayerTypeHandler();">
          <option value="sevwx-global-storm-corridors-plot">Storm Nowcasts</option>
          <option value="sevwx-storm-corridors-plot">Storm Corridors</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="nowcastOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>
      <!-- Tropical Storms Layer - OFF -->
      <div class="layer-control" id="tropicalStorms-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Tropical Storms Layer</span>
            <span class="tooltip">Select Tropical Storms data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="tropicalStormsToggle" onchange="toggleLayer('tropicalStorms', this.checked);">
            <label for="tropicalStormsToggle" class="switch"></label>
          </div>
        </div>
        <select id="tropicalStormsLayerSelect" onchange="tropicalStormsLayerTypeHandler();" disabled>
          <option value="sevwx-dtn-tropical-cyclones-plot">Tropical Storms</option>
          <option value="sevwx-agency-tropical-cyclones-plot">Agency Tropical Storms</option>
          <option value="sevwx-tropical-cyclone-tracks">Tropical Storm Model Tracks</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="tropicalStormsOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>

      <!-- Rotation Layer - OFF -->
      <div class="layer-control" id="rotation-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Rotation Layer (US Only)</span>
            <span class="tooltip">Select Rotation Tracks layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="rotationToggle" onchange="toggleLayer('rotation', this.checked);">
            <label for="rotationToggle" class="switch"></label>
          </div>
        </div>
        <select id="rotationLayerSelect" onchange="rotationLayerTypeHandler();" disabled>
          <option value="sevwx-rotation-track-contours">Rotation Tracks</option>
          <option value="avwx-echo-tops-plot">Echo Tops</option>
          <option value="avwx-echo-tops-contours">Echo Top Contours</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="rotationOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>



      <!-- Global Lightning Layer - OFF -->
      <div class="layer-control" id="lightning-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Global Lightning Layer</span>
            <span class="tooltip">Select Global Lightning data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="lightningToggle" onchange="toggleLayer('lightning', this.checked);">
            <label for="lightningToggle" class="switch"></label>
          </div>
        </div>
        <select id="lightningLayerSelect" onchange="lightningLayerTypeHandler();" disabled>
          <option value="sevwx-lightning-global-plot">Global Lightning</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="lightningOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>

      <!-- Observation Layer - OFF -->
      <div class="layer-control" id="observation-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Observation Layer</span>
            <span class="tooltip">Select Observation data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="observationToggle" onchange="toggleLayer('observation', this.checked);">
            <label for="observationToggle" class="switch"></label>
          </div>
        </div>
        <select id="observationLayerSelect" onchange="observationLayerTypeHandler();" disabled>
          <option value="sfcanlys-temperature-contours">Surface Temperature</option>
          <option value="sfcanlys-wind-speed-contours">Wind Speed</option>
          <option value="global-wind-speed">Wind Speed (Alternative)</option>
          <option value="sfcanlys-dew-point-contours">Dew Point Temperature</option>
          <option value="sfcanlys-wet-bulb-temperature-globe-contours">Wet Bulb Globe Temperature</option>
          <option value="sfcanlys-relative-humidity-contours">Relative Humidity</option>
          <option value="global-visibility">Visibility</option>
          <option value="sfcanlys-snow-depth-contours">Snow Depth</option>
          <option value="sfcanlys-sea-surface-temp-contours">Sea Surface Temperature</option>
          <option value="sfcanlys-uv-radiation-index-contours">UV Radiation Index</option>
          <option value="fcst-onefx-freezing-rain-last-24hrs-contours">Freezing Rain Last 24 Hours</option>
          <option value="fcst-onefx-snowfall-last-24hrs-contours">Snowfall Last 24 Hours</option>
          <option value="fcst-onefx-ice-accretion-last-hour-contours">Ice Accretion Last 1 Hour</option>
          <option value="fcst-onefx-wet-snow-last-1hr-contours">Wet Snow Index</option>
          <option value="precip-qpe-168hrs-eu-contours">Observed Precipitation ‚Äì Past 7 days Contour (Europe)</option>
          <option value="precip-qpe-168hrs-eu-raster">Observed Precipitation ‚Äì Past 7 days Grid (Europe)</option>
          <option value="precip-qpe-72hrs-eu-contours">Observed Precipitation ‚Äì Past 3 days Contour (Europe)</option>
          <option value="precip-qpe-72hrs-eu-raster">Observed Precipitation ‚Äì Past 3 days Grid (Europe)</option>
          <option value="precip-qpe-48hrs-eu-contours">Observed Precipitation ‚Äì Past 2 days Contour (Europe)</option>
          <option value="precip-qpe-48hrs-eu-raster">Observed Precipitation ‚Äì Past 2 days Grid (Europe)</option>
          <option value="precip-qpe-24hrs-eu-contours">Observed Precipitation ‚Äì Past 24h Contour (Europe)</option>
          <option value="precip-qpe-24hrs-eu-raster">Observed Precipitation ‚Äì Past 24h Grid (Europe)</option>
          <option value="precip-qpe-1hr-eu-contours">Observed Precipitation ‚Äì Past 1h Contour (Europe)</option>
          <option value="precip-qpe-1hr-eu-raster">Observed Precipitation ‚Äì Past 1h Grid (Europe)</option>
          <option value="placeholder">-------------------------------------------------------------------------</option>

          <option value="precip-qpe-168hrs-gm-contours">Observed Precipitation ‚Äì Past 7 days Contour (Global)</option>
          <option value="precip-qpe-168hrs-gm-raster">Observed Precipitation ‚Äì Past 7 days Grid (Global)</option>
          <option value="precip-qpe-72hrs-gm-contours">Observed Precipitation ‚Äì Past 3 days Contour (Global)</option>
          <option value="precip-qpe-72hrs-gm-raster">Observed Precipitation ‚Äì Past 3 days Grid (Global)</option>
          <option value="precip-qpe-48hrs-gm-contours">Observed Precipitation ‚Äì Past 2 days Contour (Global)</option>
          <option value="precip-qpe-48hrs-gm-raster">Observed Precipitation ‚Äì Past 2 days Grid (Global)</option>
          <option value="precip-qpe-24hrs-gm-contours">Observed Precipitation ‚Äì Past 24h Contour (Global)</option>
          <option value="precip-qpe-24hrs-gm-raster">Observed Precipitation ‚Äì Past 24h Grid (Global)</option>
          <option value="precip-qpe-1hr-gm-contours">Observed Precipitation ‚Äì Past 1h Contour (Global)</option>
          <option value="precip-qpe-1hr-gm-raster">Observed Precipitation ‚Äì Past 1h Grid (Global)</option>

          <option value="placeholder">-------------------------------------------------------------------------</option>

          <option value="global-current-speed">Current Speed</option>
          <option value="global-wave-height">Peak Wave Period</option>
          <option value="global-wave-period">Peak Wave Period</option>
          <option value="fcst-sea-wave-height-swell-waves-contours">Swell Waves</option>
          <option value="fcst-sea-wave-height-swell-waves-period-contours">Swell Waves Period</option>
          <option value="fcst-sea-wave-height-wind-waves-contours">Wind Waves</option>
          <option value="fcst-sea-wave-height-wind-waves-period-contours">Wind Waves Period</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="observationOpacity" min="0" max="1" step="0.05" value="0.5"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">50%</span>
        </div>
      </div>

      <!-- Global Warning Layer - OFF -->
      <div class="layer-control" id="warning-control">
        <div class="top-row">
          <div class="label-group">
            <span class="label-text">Global Warning Layer</span>
            <span class="tooltip">Select Global Warning data layer</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="warningToggle" onchange="toggleLayer('warning', this.checked);">
            <label for="warningToggle" class="switch"></label>
          </div>
        </div>
        <select id="warningLayerSelect" onchange="warningLayerTypeHandler();" disabled>
          <option value="sevwx-agency-bulletin-zones">Global Weather Bulletins</option>
        </select>
        <div class="opacity-control">
          <input type="range" id="warningOpacity" min="0" max="1" step="0.05" value="0.8"
            oninput="updateLayerOpacities()">
          <span class="opacity-value">80%</span>
        </div>
      </div>


      <!-- Additional Lightning Controls (kept simple but styled consistently) -->
      <div class="section">
        <h4>‚ö° UK Lightning Controls</h4>

        <div class="switch-control lightning-layer-control"> <!-- Added unique class -->
          <div class="label-group">
            <span class="label-text">UK Lightning Layer</span>
            <span class="tooltip">Show lightning strikes</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="lightning-layer-toggle" checked
              onchange="toggleLightningLayer(); updateSwitchGlow(this, 'lightning-layer-control')">
            <label for="lightning-layer-toggle" class="switch"></label>
          </div>
        </div>

        <div class="switch-control color-mode-control"> <!-- Added unique class -->
          <div class="label-group">
            <span class="label-text">Lightning Color by Age</span>
            <span class="tooltip">Color strikes by age</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="color-mode" checked
              onchange="updateStrikeColors(); updateSwitchGlow(this, 'color-mode-control')">
            <label for="color-mode" class="switch"></label>
          </div>
        </div>

        <!-- Lightning Heatmap + Blur Slider -->
        <div class="layer-control heatmap-control"> <!-- Added heatmap-control class -->
          <div class="top-row">
            <div class="label-group">
              <span class="label-text">Lightning Heatmap</span>
              <span class="tooltip">Show 2D heatmap of strike density</span>
            </div>
            <div class="toggle-switch">
              <input type="checkbox" id="heatmap-toggle"
                onchange="toggleHeatmap(); updateControlDimming(this, 'heatmap-control')">
              <label for="heatmap-toggle" class="switch"></label>
            </div>
          </div>

          <div class="opacity-control">
            <input type="range" id="blur-slider" min="1" max="50" value="30"
              oninput="updateHeatmap(currentFiltered); this.closest('.opacity-control').querySelector('.slider-value').textContent = this.value">
          </div>
        </div>

        <div class="layer-control counter-control">
          <div class="top-row">
            <div class="label-group">
              <span class="label-text">Lightning Counter</span>
              <span class="tooltip">Show strike counts in grid cells</span>
            </div>
            <div class="toggle-switch">
              <input type="checkbox" id="number-overlay-toggle"
                onchange="updateOverlay(currentFiltered); updateControlDimming(this, 'counter-control')">
              <label for="number-overlay-toggle" class="switch"></label>
            </div>
          </div>

          <div class="opacity-control">
            <input type="range" id="density-slider" min="1" max="100" value="50"
              oninput="updateOverlay(currentFiltered); this.closest('.opacity-control').querySelector('.slider-value').textContent = this.value">
          </div>
        </div>
      </div>


      <h4>‚ú® Lightning Heatmap Opacity & Detail</h4>

      <label class="pretty-slider">
        Heatmap Blur
        <input type="range" id="blur-slider" min="1" max="50" value="30" onchange="updateHeatmap(currentFiltered)">
        <span class="tooltip">Adjust heatmap spread</span>
      </label>

      <label class="pretty-slider">
        Number Resolution
        <input type="range" id="density-slider" min="1" max="100" value="50" onchange="updateOverlay(currentFiltered)">
        <span class="tooltip">Adjust overlay grid size</span>
      </label>
    </div>
    <div class="section">
      <h4>‚ûï Extras & Nowcasting</h4>
      <div class="switch-control sound-control">
        <div class="label-group">
          <span class="label-text">Sound Effects</span>
          <span class="tooltip">Play thunder sound on strikes</span>
        </div>
        <div class="toggle-switch">
          <input type="checkbox" id="sound-toggle" onchange="toggleSound(); updateSwitchGlow(this, 'sound-control')">
          <label for="sound-toggle" class="switch"></label>
        </div>
      </div>

      <div class="switch-control nowcast-control">
        <div class="label-group">
          <span class="label-text">Nowcast Predictions</span>
          <span class="tooltip">Show lightning predictions</span>
        </div>
        <div class="toggle-switch">
          <input type="checkbox" id="nowcast-toggle" checked
            onchange="toggleAllNowcast(); updateSwitchGlow(this, 'nowcast-control')">
          <label for="nowcast-toggle" class="switch"></label>
        </div>
      </div>

      <label class="pretty-slider">
        Nowcast Confidence
        <input type="range" id="min-nowcast-confidence" min="0" max="1" step="0.01" value="0.1"
          onchange="is3DMode ? update3DView() : toggleNowcast()">
        <span class="tooltip">Minimum confidence for nowcast cones</span>
      </label>
    </div>
    <div class="section">
      <h4>‚è≥ Time Filter</h4>
      <label class="pretty-input">
        Start Time
        <input type="datetime-local" id="start-time">
        <span class="tooltip">Filter strikes from this time</span>
      </label>

      <label class="pretty-input">
        End Time
        <input type="datetime-local" id="end-time">
        <span class="tooltip">Filter strikes up to this time</span>
      </label>

      <div class="button-group">
        <button onclick="applyFilter()">Apply Filter</button>
        <button id="remove-filter" onclick="removeTimeFilter()" style="display: none;">Remove Filter</button>
      </div>

      <div class="switch-control auto-time-control">
        <div class="label-group">
          <span class="label-text">Auto Time Filter</span>
          <span class="tooltip">Auto-adjust time based on data</span>
        </div>
        <div class="toggle-switch">
          <input type="checkbox" id="auto-time-filter" checked>
          <label for="auto-time-filter" class="switch"></label>
        </div>
      </div>

      <label class="pretty-input">
        Lightning Lifespan
        <input type="number" id="lightning-lifespan" value="3" min="0.1" step="0.1">
        <span class="unit">hours</span>
        <span class="tooltip">Show strikes within this period</span>
      </label>

      <label class="pretty-input">
        Slider Max History
        <input type="number" id="max-history-hours" value="6" min="1" step="1" onchange="updateHistorySliderMax()">
        <span class="unit">hours</span>
        <span class="tooltip">Max hours back for time slider</span>
      </label>
    </div>

    <div class="section">
      <h4>üó∫Ô∏è Polygon Drawing</h4>
      <label>Enable Polygons: <input type="checkbox" id="drawn-polygons-toggle" checked
          onchange="toggleDrawnPolygons()"><span class="tooltip">Show/hide drawn polygons</span></label>
      <label>Opacity: <input type="range" id="polygon-opacity" min="0" max="1" step="0.1" value="0.3"
          onchange="updateAllPolygonsOpacity()"><span class="tooltip">Adjust polygon fill opacity</span></label>
      <label>Outline Thickness: <input type="range" id="polygon-weight" min="1" max="10" step="1" value="2"
          onchange="updateAllPolygonsWeight()"><span class="tooltip">Adjust polygon outline thickness</span></label>
      <div class="draw-toolbar">
        <button onclick="toggleDrawing()">Enable Drawing</button>
        <select id="risk-level-select">
          <option value="Low risk">Low risk</option>
          <option value="Slight risk">Slight risk</option>
          <option value="Enhanced risk">Enhanced risk</option>
          <option value="Moderate risk">Moderate risk</option>
          <option value="High risk">High risk</option>
          <option value="Severe risk">Severe risk</option>
        </select>
        <button onclick="exportToKML()">Export KML</button>
      </div>
    </div>

    <div class="section">
      <h4>‚öôÔ∏è Automation</h4>
      <label>Auto-refresh: <select id="refresh-interval" onchange="setRefreshInterval()">
          <option value="0">Off</option>
          <option value="0.0167">1 seconds (This might slow down your device)</option>
          <option value="0.167" selected>10 seconds</option>
          <option value="0.5">30 seconds</option>
          <option value="1">1 minute</option>
          <option value="5">5 minutes</option>
          <option value="10">10 minutes</option>
        </select><span class="tooltip">Set data refresh interval</span></label>
      <label>Auto-set Latest: <input type="checkbox" id="auto-latest" checked onchange="toggleAutoLatest()"><span
          class="tooltip">Keep time at latest</span></label>
      <label><button id="view-mode" onclick="toggleViewMode()">Enable All Strikes</button><span class="tooltip">Show all
          strikes in range</span></label>
    </div>



    <div class="section">
      <h4>üßë‚Äçüíª Expert Mode</h4>
      <div class="switch-control expert-mode-control">
        <div class="label-group">
          <span class="label-text">Enable Expert Mode</span>
          <span class="tooltip">Show advanced options</span>
        </div>
        <div class="toggle-switch">
          <input type="checkbox" id="expert-mode"
            onchange="toggleExpertMode(); updateSwitchGlow(this, 'expert-mode-control')">
          <label for="expert-mode" class="switch"></label>
        </div>
      </div>
      <div id="expert-controls" style="display: none;">
        <button class="expert-button" onclick="showRectangleExportModal()">
          Export Strikes As PNG
        </button>
        <div class="switch-control kml-control">
          <div class="label-group">
            <span class="label-text">KML Layer</span>
            <span class="tooltip">Toggle custom KML overlay</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="kml-layer-toggle" checked
              onchange="toggleKMLLayer(); updateSwitchGlow(this, 'kml-control')">
            <label for="kml-layer-toggle" class="switch"></label>
          </div>
        </div>
        <label class="pretty-input">
          KML File
          <input type="file" id="kml-file" accept=".kml" onchange="importKML(this)">
          <span class="tooltip">Upload a KML file</span>
        </label>

        <!-- PNG Layer -->
        <div class="switch-control png-control">
          <div class="label-group">
            <span class="label-text">PNG Layer</span>
            <span class="tooltip">Toggle custom PNG overlay</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="png-layer-toggle" checked
              onchange="togglePNGLayer(); updateSwitchGlow(this, 'png-control')">
            <label for="png-layer-toggle" class="switch"></label>
          </div>
        </div>

        <label class="pretty-input">
          PNG File
          <input type="file" id="png-file" accept=".png" onchange="importPNG(this)">
          <span class="tooltip">Upload a PNG overlay</span>
        </label>

        <label class="pretty-slider">
          PNG Opacity
          <input type="range" id="png-opacity-slider" min="0" max="1" step="0.05" value="0.8"
            onchange="updatePNGOpacity()">
          <span class="slider-value">80%</span>
          <span class="tooltip">Adjust PNG overlay transparency</span>
        </label>

        <label class="pretty-input">
          KML Z-Index
          <input type="number" id="kml-zindex" value="1" min="0" onchange="updateZIndex()">
          <span class="tooltip">Layer draw order (higher = on top)</span>
        </label>

        <label class="pretty-input">
          PNG Z-Index
          <input type="number" id="png-zindex" value="1400" min="0" onchange="updateZIndex()">
          <span class="tooltip">Layer draw order (higher = on top)</span>
        </label>

        <label class="pretty-input">
          Lightning Z-Index
          <input type="number" id="lightning-zindex" value="1000" min="0" onchange="updateZIndex()">
          <span class="tooltip">Layer draw order (higher = on top)</span>
        </label>

        <label class="pretty-input">
          Heatmap Z-Index
          <input type="number" id="heatmap-zindex" value="70" min="0" onchange="updateZIndex()">
          <span class="tooltip">Layer draw order (higher = on top)</span>
        </label>

        <label class="pretty-input">
          Numbers Z-Index
          <input type="number" id="numbers-zindex" value="1200" min="0" onchange="updateZIndex()">
          <span class="tooltip">Layer draw order (higher = on top)</span>
        </label>
      </div>
    </div>

    <div class="section">
      <h4>üîó Useful Links</h4>
      <a href="https://handry-outlook.github.io/Convective-Outlook/lightning_strikes_chart.html"
        target="_blank"><button>Strikes Chart</button></a>
      <a href="https://handry-outlook.github.io/Convective-Outlook/interactive_map.html" target="_blank"><button>Radar &
          Forecast</button></a>
    </div>
  </div>
  <div id="map"></div>
  <div id="map-3d"></div>
  <div class="time-slider-container">
    <label><input type="range" id="history-slider" class="slider" min="0" max="360" value="360"
        oninput="updateHistory()"> <span id="history-label">Now</span></label>
    <p id="history-time"></p>
    <div class="animator">
      <button onclick="playAnimation()">‚ñ∂Ô∏è Play</button>
      <button onclick="stopAnimation()">‚èπÔ∏è Stop</button>
      <label>Speed: <input type="range" id="speed-slider" min="1" max="30" step="5" value="15"
          oninput="updateSpeedTextbox()"></label>
      <label>Min/Sec: <input type="number" id="playback-minutes" min="1" max="30" step="5" value="15"
          oninput="updateSpeedSlider()"></label>
    </div>
    <p id="time-range" class="status-info"></p>
    <div class="status-info-container">
      <p id="last-update" class="status-info"></p>
      <p id="current-time" class="status-info"></p>
    </div>
  </div>
  <button id="settings-button" onclick="toggleControls()">‚öôÔ∏è</button>
  <div id="3d-draw-modal" class="modal" style="display: none;">
    <p>Drawing is only available in 2D mode. Would you like to switch to 2D mode to draw?</p>
    <button onclick="switchTo2DForDrawing()">Switch to 2D</button>
    <button onclick="close3DDrawModal()">Cancel</button>
  </div>
  <div id="tutorial-modal" class="modal" style="display: none;">
    <h3>üìö Tutorial: RadarLoop</h3>

    <hr>

    <div id="basic-tutorial">
      <h4>üó∫Ô∏è Map Interaction & Time History</h4>

      <p>Use the **Start Time** and **End Time** inputs to filter lightning strikes by date and time, then click **Apply
        Filter**.</p>

      <p>The **history slider** below the map controls the data timestamp. The right side is the current time (**Now**),
        and the left side goes back up to the **Max History** hours (default: 24 hours). Data displayed corresponds to
        the slider's current position.</p>

      <p>Click **Play** to animate the history of strikes from oldest to newest. Adjust the playback speed using the
        slider or the **Minutes per Second** input (e.g., 1 = 1 minute of strikes per second). Click **Stop** to pause
        the animation.</p>
    </div>

    <hr>

    <div id="layer-tutorial">
      <h4>üåê Layer Management & Visualization</h4>

      <p>Use the checkboxes to toggle visualization layers:</p>
      <ul>
        <li>**UK Lightning Layer:** Displays individual strike markers in the UK.</li>
        <li>**Lightning Heatmap:** Shows a 2D density map of strikes. Adjust its appearance using the **Heatmap Blur**
          slider.
        </li>
        <li>**Lightning Counter:** Displays the total count of strikes within a cluster or area.</li>
        <li>**Sound:** Enable this to play a thunder sound for each new strike that occurs within the current map view.
        </li>
      </ul>

      <p>Use the dropdowns to overlay real-time or modeled weather data. Adjust visibility using the respective
        **Opacity** slider (if available). Changing a layer selection will automatically refresh the map to plot the new
        layer at the
        current history time.</p>

      <h5>Weather Overlays:</h5>
      <ul>
        <li>**Map Style:** Change the base map's appearance (e.g., Satellite, Dark, Light).</li>
        <li>**Radar and Weather Layer:** Shows precipitation (rain, snow, type) intensity or reflectivity. This includes
          UK high-resolution and global products.</li>
        <li>**Satellite Layer:** Displays cloud or atmospheric imagery (e.g., Visible, Infrared, Water Vapor).</li>
        <li>**Isobar Layer (Pressure):** Overlays lines of equal mean sea level pressure (isobars). Used to locate high
          and low pressure centers.</li>
        <li>**Wind Direction Layer:** Overlays wind direction data.</li>
        <li>**Tropical Storms Layer:** Displays active tropical storm tracks and forecasts.</li>
        <li>**Rotation Layer (US Only):** Shows rotational signatures like storm rotation tracks or echo tops.</li>
        <li>**Surface Front Layer:** Overlays boundaries between different air masses (Cold, Warm, Stationary, Occluded
          fronts).</li>
        <li>**Global Lightning Layer:** Displays real-time lightning strikes on a global scale.</li>
        <li>**Observation Layer:** Provides various surface observational data such as Temperature, Wind Speed, Snow
          Depth, and Sea Surface Temperature.</li>
        <li>**Global Warning Layer:** Displays zones with active weather bulletins or warnings.</li>
        <li>**Global Nowcast Layer:** Shows immediate short-term predictions for storms.</li>
      </ul>
    </div>

    <hr>

    <div id="nowcast-tutorial">
      <h4>‚ö° Nowcasting & Prediction</h4>

      <p>Enable **Nowcast** to display predicted lightning movement based on recent strike clusters. Nowcast shows
        circles at cluster centers and cones indicating the predicted direction of movement.</p>
      <p>Prediction confidence is indicated by color: **Purple** (very high) and **Red** (high). This feature updates
        dynamically whenever you apply filters or change the time slider position.</p>
    </div>

    <hr>

    <div id="expert-tutorial">
      <h4>üõ†Ô∏è Expert Mode & Custom Layers</h4>

      <p>Enable **Expert Mode** to access advanced customization options:</p>
      <ul>
        <li>**Custom Layers (KML/PNG):** Upload a KML file to overlay risk zones or a PNG file for custom imagery (e.g.,
          model outputs).</li>
        <li>**Layer Settings:** Adjust settings like **PNG Opacity** or modify layer z-indices to customize the display
          order relative to the lightning and weather layers.</li>
        <li>**KML Formatting:** For KML files, ensure polygon names match predefined risk levels ('Low risk', 'Slight
          risk', 'Enhanced risk', 'Moderate risk', 'High risk') to ensure correct color styling.</li>
        <li>**PNG Bounds:** For PNG files, the filename should include the region name (e.g., 'England', 'Wales') to
          help the system automatically set the image boundaries on the map.</li>
        <li>**Export:** Click **Export Strikes As PNG** to save the current map view and lightning strikes as an image
          file. You can enter specific coordinates or drag an area on the map to define the export region.</li>
      </ul>
    </div>
    <button onclick="closeTutorial()">Close</button>
  </div>
  </div>
  <div id="modal" class="modal" style="display: none;">
    <p>Do you want to adjust the time filter based on the file's timestamp?</p>
    <button onclick="confirmAutoTimeFilter(true)">Yes</button>
    <button onclick="confirmAutoTimeFilter(false)">No</button>
  </div>
  <div id="overlay" class="overlay" style="display: none;"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0"></script>
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
  <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
  <script>
    const mapboxAccessToken = 'pk.eyJ1IjoibWV0ZW9ncm91cC1tYXBib3giLCJhIjoiY2pudWJyMWVhMDQ0bjNxdXFsNWJ5M2ZtbSJ9.ANOKYyv5s0VFVbnesnGGUQ';
    const maptilerApiKey = 'd6FiSbcpDtzJ4g4e0oD4';

    const risk_colors = {
      'Low risk': '#5aac91',
      'Slight risk': '#ffff00',
      'Enhanced risk': '#ffa500',
      'Moderate risk': '#ff0000',
      'High risk': '#800080',
      'Severe risk': '#000000' // Added Severe risk with black color
    };

    const region_bounds = {
      "England": [[47.7, -20.4], [57.075, 10.55]],
      "Wales": [[51.4, -5.3], [53.4, -2.8]],
      "Scotland": [[54.6, -7.5], [60.8, -0.7]],
      "Northern Ireland": [[49.98, -20.2], [56.25, 1.175]],
      "Ireland and Northern Ireland": [[49.98, -21.65], [56.25, 1.075]],
      "UK": [[47.8, -31.2], [61.3, 16.6]]
    };
    let is3DMode = false;
    let map, map3D;
    let baseLayers = {
      opentopo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {

        attribution: 'Map data: ¬© OpenTopoMap (CC-BY-SA)'
      }),
      custom: L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {

        attribution: '¬© OpenStreetMap'
      }),
      esri: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {

        attribution: 'Tiles ¬© Esri'
      }),
      'maptiler-streets': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.STREETS,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-outdoor': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.OUTDOOR,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-dark': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.DARK,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'maptiler-light': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.LIGHT,
        attribution: '¬© MapTiler ¬© OpenStreetMap contributors'
      }),
      'mapbox-satellite': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-outdoors': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-dark': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/dark-v11/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-navigation': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-day-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-light': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/light-v11/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-streets-satellite': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-navigation-night': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-night-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-traffic-day': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/traffic-day-v2/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-traffic-night': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/traffic-night-v2/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      }),
      'mapbox-contrast': L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/high-contrast-v1/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 256,

        attribution: '¬© Mapbox ¬© OpenStreetMap',

      })
    };

    map = L.map('map', { layers: [baseLayers['mapbox-streets-satellite']], zoomControl: false }).setView([53.5, -4.5], 6);

    map3D = new mapboxgl.Map({
      container: 'map-3d',
      style: 'mapbox://styles/handry-outlook/cm9457ty1009d01sk37353ux2',
      center: [-4.5, 53.5],
      zoom: 5,
      projection: 'globe',
      accessToken: mapboxAccessToken
    });

    map3D.on('load', () => {
      map3D.addSource('mapbox-dem', {
        'type': 'raster-dem',
        'url': 'mapbox://mapbox.terrain-rgb',
        'tileSize': 512,
        'maxzoom': 14
      });
      map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 12 });
      map3D.resize(); // Ensure 3D map is sized correctly
    });
    map.invalidateSize(); // Ensure 2D map is sized correctly

    const timeSliderContainer = document.querySelector('.time-slider-container');
    const logo = document.createElement('img');
    logo.src = 'https://raw.githubusercontent.com/Handry-Outlook/Lightning-Strike-Visualiser-/refs/heads/main/RadarLoop%20Logo.png';
    logo.className = 'logo';

    logo.style.pointerEvents = 'none';
    logo.style.zIndex = '1001'; // Ensure logo is above other elements
    document.body.appendChild(logo); // Append to body instead of map container
    // Append logo to the map container for mobile positioning


    const legendControl = L.control({ position: 'topright' });
    legendControl.onAdd = function (map) {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '<h4>Legend</h4>';
      div.style.display = 'none'; // Initially hidden

      return div;
    };
    legendControl.addTo(map);
    let forceLayerReplot = false;
    let strikeData = [];
    let strikeLayer = L.layerGroup().addTo(map);
    let heatmapLayer = null;
    let numberOverlay = null;
    let numberOverlay3D = [];
    let animationInterval = null;
    let currentFiltered = [];
    let animationStart, animationEnd;
    let kmlLayer = null;
    let kmlGeoJSON = null;
    let pngLayer = null;
    let pngImage = null;
    let pngBounds = null;
    let isPlaying = false;
    let strikeCircles = [];
    let pendingFile = null;
    let pendingFileType = null;
    let isFullScreen = false;
    let refreshTimer = null;
    let lastUpdateTime = null;
    let isAdjustingHistory = false;
    let lastFilterMode = 'slider';
    let customFilterStart = null;
    let customFilterEnd = null;
    let showAllStrikes = false;
    let strikeLayer3D = [];
    let heatmapLayer3D = null;
    let lastRenderedStrikes = new Set();
    let thunderAudio = new Audio('https://handry-outlook.github.io/Lightning-Strike-Visualiser-/mouse-click-117076-%5BAudioTrimmer.com%5D.mp3');
    thunderAudio.preload = 'auto';
    let soundEnabled = false;
    let lightningEffectEnabled = false;
    let lastSoundTime = 0;
    const SOUND_COOLDOWN = 50;
    let nowcastLayer = L.layerGroup();
    let nowcastLayer3D = [];
    let currentNowcasts = [];

    let minNowcastConfidence = 0.8;
    let userLocationMarker = null;
    let isLegendVisible = false;
    let lastDrawnRectangle = null; //
    let drawnItems = L.featureGroup().addTo(map);
    let drawControl;
    let drawControl3D;
    let drawnItems3D = [];
    let isDrawingEnabled = false;
    let editingLayerId = null;
    let previousNowcasts = [];

    let isFilterApplied = false;
    var polygonNowcastLayer = L.layerGroup();

    const currentTime = new Date();
    // Assuming 'map' is globally defined by Leaflet setup

    // ==========================================
    // 1. GLOBAL VARIABLE DEFINITIONS & OPTIONS
    // ==========================================

    // --- RADAR OPTIONS (UNCHANGED) ---
    const radarOptions = {
      'uk-precip-intensity': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-intensity-uk-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'DTN Meteoguard'
      },
      'uk-precip-type': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-type-uk-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'DTN Meteoguard'
      },
      'europe-precip-intensity': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-intensity-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 15 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'DTN Meteoguard'
      },
      'europe-precip-type': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-type-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 15 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'DTN Meteoguard'
      },
      'radar-precip-intensity-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-intensity-global-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 30 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'DTN Meteoguard'
      },
      'uk-precip-intensity-pixelated': {
        url: 'https://maps.consumer-digital.api.metoffice.gov.uk/wms_ob/single/high-res/rainfall_radar/${iso}.png',
        interval: 5 * 60 * 1000,
        type: 'image',
        bounds: [
          [44.02, -25],
          [64, 16]
        ],
        attribution: 'Met Office'
      },
      'uk-precip-intensity-accessible': {
        url: 'https://maps.consumer-digital.api.metoffice.gov.uk/wms_ob/single/high-res/rainfall_radar_accessible/${iso}.png',
        interval: 5 * 60 * 1000,
        type: 'image',
        bounds: [
          [44.02, -25],
          [64, 16]
        ],
        attribution: 'Met Office'
      },
      'global-precip-intensity': {

        url: 'https://tiles.meteoguard.dtn.com/tiles/VECTOR.obs-radar.nasa.global-imerg_01x01_intensity.default/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 15 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-base-ref-precip-type-na-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-base-ref-precip-type-na-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-base-ref-precip-type-europe-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-base-ref-precip-type-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-base-ref-precip-type-europe-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-base-ref-precip-type-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-base-ref-precip-type-australia-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-base-ref-precip-type-australia-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-base-ref-precip-type-westpacific-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-base-ref-precip-type-westpacific-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-max-ref-precip-type-na-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-max-ref-precip-type-na-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-max-ref-precip-type-australia-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-max-ref-precip-type-australia-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-precip-rate-europe-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-rate-europe-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-precip-rate-europe-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-rate-europe-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-precip-rate-europe-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-precip-rate-europe-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-reflectivity-mosaic-global-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-reflectivity-mosaic-global-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 10 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'radar-reflectivity-mosaic-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/radar-reflectivity-mosaic-global-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 10 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-current-speed': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-current-speed-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wave-height': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-significant-wave-height-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wave-period': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-peak-wave-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-swell-waves-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-swell-waves-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-swell-waves-period-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-swell-waves-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-wind-waves-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-wind-waves-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-wind-waves-period-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-wind-waves-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-visibility': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-visibility-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wind-speed': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-wind-speed-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      }
    };

    // --- SATELLITE OPTIONS (NEW) ---
    const satelliteOptions = {
      'global-ir': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.mg.global-composite_data_ir.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 10 * 60 * 1000, // Example interval
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'europe-vis': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.ems.meteosat-0e_europe_proj_hrv.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 15 * 60 * 1000,
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'europe-ir': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.ems.meteosat-0e_europe_proj_ir108.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 15 * 60 * 1000,
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'europe-water': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.ems.meteosat-0e_europe_proj_wv062.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 15 * 60 * 1000,
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'us-visible': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.noaa.goes-east-75w.sh.s3.mg_north_america_vis.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000,
        type: 'tile-layer',
        attribution: 'NOAA/GOES'
      },
      'us-ir': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/RASTER.obs-sat.noaa.goes-east-75w.sh.s3.mg_north_america_ir.default/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000,
        type: 'tile-layer',
        attribution: 'NOAA/GOES'
      },
      'satellite-infrared-enhanced-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/satellite-infrared-enhanced-global-raster/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 10 * 60 * 1000, // Example interval
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'satellite-visible-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/satellite-visible-global-raster/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 10 * 60 * 1000, // Example interval
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'satellite-water-vapor-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/satellite-water-vapor-global-raster/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 10 * 60 * 1000, // Example interval
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
      'satellite-night-fog-global-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/satellite-night-fog-global-raster/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 10 * 60 * 1000, // Example interval
        type: 'tile-layer',
        attribution: 'DTN Meteoguard'
      },
    };
    const lightningOptions = {
      'sevwx-lightning-global-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-lightning-global-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const tropicalStormsOptions = {
      'sevwx-dtn-tropical-cyclones-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-dtn-tropical-cyclones-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sevwx-agency-tropical-cyclones-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-agency-tropical-cyclones-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sevwx-tropical-cyclone-tracks': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-tropical-cyclone-tracks/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const rotationOptions = {
      'sevwx-rotation-track-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-rotation-track-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'avwx-echo-tops-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/avwx-echo-tops-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'avwx-echo-tops-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/avwx-echo-tops-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const surfaceFrontOptions = {
      'fcst-surface-fronts-isolines': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-surface-fronts-isolines/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const observationOptions = {
      'precip-qpe-168hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-eu-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-eu-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-eu-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-eu-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'tile-layer',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-168hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-168hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-72hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-72hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-48hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-48hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-24hrs-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-24hrs-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-gm-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-gm-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'precip-qpe-1hr-gm-raster': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/precip-qpe-1hr-gm-raster/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-current-speed': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-current-speed-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wave-height': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-significant-wave-height-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wave-period': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-peak-wave-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-swell-waves-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-swell-waves-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-swell-waves-period-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-swell-waves-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-wind-waves-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-wind-waves-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-wind-waves-period-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-wind-waves-period-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-visibility': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-visibility-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'global-wind-speed': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-wind-speed-contours/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 60 * 60 * 1000,
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-temperature-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-temperature-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-wind-speed-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-wind-speed-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-dew-point-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-dew-point-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-wet-bulb-temperature-globe-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-wet-bulb-temperature-globe-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-relative-humidity-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-relative-humidity-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-snow-depth-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-snow-depth-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-sea-surface-temp-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-sea-surface-temp-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sfcanlys-uv-radiation-index-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sfcanlys-uv-radiation-index-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-onefx-freezing-rain-last-24hrs-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-onefx-freezing-rain-last-24hrs-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-onefx-snowfall-last-24hrs-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-onefx-snowfall-last-24hrs-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-onefx-ice-accretion-last-hour-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-onefx-ice-accretion-last-hour-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-onefx-wet-snow-last-1hr-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-onefx-wet-snow-last-1hr-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'avwx-echo-tops-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/avwx-echo-tops-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'avwx-echo-tops-contours': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/avwx-echo-tops-contours/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const nowcastOptions = {
      'sevwx-storm-corridors-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-storm-corridors-plot/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'sevwx-global-storm-corridors-plot': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-global-storm-corridors-plot/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 5 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    const warningOptions = {
      'sevwx-agency-bulletin-zones': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/sevwx-agency-bulletin-zones/${iso}/${iso}/{z}/{x}/{y}.pbf',
        interval: 2 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    // --- ISOBAR OPTIONS (NEW) ---
    const isobarOptions = {
      'pressure_two': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-mean-sea-level-pressure-isolines/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'pressure_four': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-mean-sea-level-pressure-4mb-isolines/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12-hourly update
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-geopotential-height-500hpa-isolines': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-geopotential-height-500hpa-isolines/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12-hourly update
        type: 'vector-tile',
        bounds: null,
        attribution: 'dtn'
      }
    };
    const windOptions = {
      'wind-direction': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-wind-symbol-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-current-direction-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-current-direction-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-mean-wave-direction-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-mean-wave-direction-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-significant-wave-symbol-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-significant-wave-symbol-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // 12Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-current-speed-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-current-speed-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-swell-wave-symbol-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-swell-wave-symbol-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-swell-waves-period-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-swell-waves-period-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-manta-wind-wave-symbol-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-manta-wind-wave-symbol-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
      'fcst-sea-wave-height-wind-waves-period-grid': {
        url: 'https://tiles.meteoguard.dtn.com/tiles/fcst-sea-wave-height-wind-waves-period-grid/${iso}/${iso}/{z}/{x}/{y}.png',
        interval: 60 * 60 * 1000, // Hourly update, for example
        type: 'vector-tile', // Typically vector tiles for lines/contours
        bounds: null,
        attribution: 'dtn'
      },
    };
    // --- GLOBAL STATE VARIABLES ---
    let radarLayer = null;
    let satelliteLayer = null;
    let isobarLayer = null;
    let windLayer = null;
    let lightningLayer = null;          // NEW
    let tropicalStormsLayer = null;     // NEW
    let rotationLayer = null;           // NEW
    let surfaceFrontLayer = null;       // NEW
    let observationLayer = null;        // NEW
    let NowcastLayer = null;            // NEW
    let warningLayer = null;            // NEW

    let isPlotting = false;
    let lastRadarTimestamp = null;
    let lastRadarType = null;
    let lastSatelliteTimestamp = null;
    let lastSatelliteType = null;
    let lastIsobarTimestamp = null;
    let lastIsobarType = null;
    let lastWindTimestamp = null;
    let lastWindType = null;
    let lastLightningTimestamp = null;          // NEW
    let lastLightningType = null;               // NEW
    let lastTropicalStormsTimestamp = null;     // NEW
    let lastTropicalStormsType = null;          // NEW
    let lastRotationTimestamp = null;           // NEW
    let lastRotationType = null;                // NEW
    let lastSurfaceFrontTimestamp = null;       // NEW
    let lastSurfaceFrontType = null;            // NEW
    let lastObservationTimestamp = null;        // NEW
    let lastObservationType = null;             // NEW
    let lastNowcastTimestamp = null;            // NEW
    let lastNowcastType = null;                 // NEW
    let lastWarningTimestamp = null;            // NEW
    let lastWarningType = null;                 // NEW

    let isSatelliteAnimating = false;
    let isRadarAnimating = false;
    let isIsobarAnimating = false;
    let isWindAnimating = false;
    let isLightningAnimating = false;           // NEW
    let isTropicalStormsAnimating = false;      // NEW
    let isRotationAnimating = false;            // NEW
    let isSurfaceFrontAnimating = false;        // NEW
    let isObservationAnimating = false;         // NEW
    let isNowcastAnimating = false;             // NEW
    let isWarningAnimating = false;             // NEW

    let lastRequestedRadarTimestamp = null;
    let lastRequestedSatelliteTimestamp = null;
    let lastRequestedIsobarTimestamp = null;
    let lastRequestedWindTimestamp = null;
    let lastRequestedLightningTimestamp = null;         // NEW
    let lastRequestedTropicalStormsTimestamp = null;    // NEW
    let lastRequestedRotationTimestamp = null;          // NEW
    let lastRequestedSurfaceFrontTimestamp = null;      // NEW
    let lastRequestedObservationTimestamp = null;       // NEW
    let lastRequestedNowcastTimestamp = null;           // NEW
    let lastRequestedWarningTimestamp = null;           // NEW

    const sixDaysInMs = 7 * 24 * 60 * 60 * 1000;
    let lastValidTileUrls = {};
    const radarValidationCache = new Map();

    let currentFilterTimestamp = null;

    const SATELLITE_Z_INDEX = 140;
    const RADAR_Z_INDEX = 150;
    const WIND_Z_INDEX = 155;
    const ISOBAR_Z_INDEX = 160;
    const LIGHTNING_Z_INDEX = 165;          // NEW
    const TROPICAL_STORMS_Z_INDEX = 170;    // NEW
    const ROTATION_Z_INDEX = 175;           // NEW
    const SURFACE_FRONT_Z_INDEX = 180;      // NEW
    const OBSERVATION_Z_INDEX = 130;        // NEW
    const NOWCAST_Z_INDEX = 190;            // NEW
    const WARNING_Z_INDEX = 135;            // NEW

    // ==========================================
    // 2. HELPER FUNCTIONS
    // ==========================================

    // --- DEBOUNCE FUNCTION (UNCHANGED) ---
    function debounce(func, delay) {
      let timeoutId;
      return function (/* timestamp */ ...args) {
        const context = this;
        // Check if the second argument is explicitly passed as true
        const forceExecute = args.length > 1 && args[1] === true;

        clearTimeout(timeoutId);

        if (forceExecute) {
          func.apply(context, [args[0]]); // Execute immediately
          timeoutId = null;
        } else {
          timeoutId = setTimeout(() => { // Execute after delay
            func.apply(context, args);
          }, delay);
        }
      };
    }

    function updateSwitchGlow(checkbox, controlClass) {
      const control = checkbox.closest('.switch-control');
      if (control) {
        if (checkbox.checked) {
          control.classList.add('glow-on');
          control.classList.remove('glow-off');
        } else {
          control.classList.add('glow-off');
          control.classList.remove('glow-on');
        }
      }
    }
    function updateLegend() {
      const radarOpacity = parseFloat(document.getElementById('radarOpacity')?.value || 0.8);
      const satelliteOpacity = parseFloat(document.getElementById('satelliteOpacity')?.value || 0.8);
      const isobarOpacity = parseFloat(document.getElementById('isobarOpacity')?.value || 0.8);
      const windOpacity = parseFloat(document.getElementById('windOpacity')?.value || 0.8);
      const lightningOpacity = parseFloat(document.getElementById('lightningOpacity')?.value || 0.8);
      const tropicalStormsOpacity = parseFloat(document.getElementById('tropicalStormsOpacity')?.value || 0.8);
      const rotationOpacity = parseFloat(document.getElementById('rotationOpacity')?.value || 0.8);
      const surfaceFrontOpacity = parseFloat(document.getElementById('surfaceFrontOpacity')?.value || 0.8);
      const observationOpacity = parseFloat(document.getElementById('observationOpacity')?.value || 0.8);
      const nowcastOpacity = parseFloat(document.getElementById('nowcastOpacity')?.value || 0.8);
      const warningOpacity = parseFloat(document.getElementById('warningOpacity')?.value || 0.8);

      document.getElementById('opacity-value-radar').textContent = `Radar Opacity: ${radarOpacity.toFixed(1)}`;
      document.getElementById('opacity-value-satellite').textContent = `Satellite Opacity: ${satelliteOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-isobar')) document.getElementById('opacity-value-isobar').textContent = `Isobar Opacity: ${isobarOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-wind')) document.getElementById('opacity-value-wind').textContent = `Wind Opacity: ${windOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-lightning')) document.getElementById('opacity-value-lightning').textContent = `Lightning Opacity: ${lightningOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-tropicalStorms')) document.getElementById('opacity-value-tropicalStorms').textContent = `Tropical Storms Opacity: ${tropicalStormsOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-rotation')) document.getElementById('opacity-value-rotation').textContent = `Rotation Opacity: ${rotationOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-surfaceFront')) document.getElementById('opacity-value-surfaceFront').textContent = `Surface Front Opacity: ${surfaceFrontOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-observation')) document.getElementById('opacity-value-observation').textContent = `Observation Opacity: ${observationOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-nowcast')) document.getElementById('opacity-value-nowcast').textContent = `Nowcast Opacity: ${nowcastOpacity.toFixed(1)}`;
      if (document.getElementById('opacity-value-warning')) document.getElementById('opacity-value-warning').textContent = `Warning Opacity: ${warningOpacity.toFixed(1)}`;
    }
    // ==========================================
    // LAYER TOGGLE HANDLER (WITH VISUAL FEEDBACK)
    // ==========================================
    const layerMap = {
      radar: { select: 'radarLayer', handler: 'radarLayerTypeHandler' },
      satellite: { select: 'satelliteLayerSelect', handler: 'satelliteLayerTypeHandler' },
      isobar: { select: 'isobarLayerSelect', handler: 'isobarLayerTypeHandler' },
      wind: { select: 'windLayerSelect', handler: 'windLayerTypeHandler' },
      tropicalStorms: { select: 'tropicalStormsLayerSelect', handler: 'tropicalStormsLayerTypeHandler' },
      rotation: { select: 'rotationLayerSelect', handler: 'rotationLayerTypeHandler' },
      surfaceFront: { select: 'surfaceFrontLayerSelect', handler: 'surfaceFrontLayerTypeHandler' },
      lightning: { select: 'lightningLayerSelect', handler: 'lightningLayerTypeHandler' },
      observation: { select: 'observationLayerSelect', handler: 'observationLayerTypeHandler' },
      warning: { select: 'warningLayerSelect', handler: 'warningLayerTypeHandler' },
      nowcast: { select: 'nowcastLayerSelect', handler: 'nowcastLayerTypeHandler' }
    };
    function updateControlDimming(checkbox, controlClass) {
      const control = checkbox.closest('.layer-control');
      if (control) {
        if (checkbox.checked) {
          control.classList.remove('off');
        } else {
          control.classList.add('off');
        }
      }
    }
    function toggleLayer(layerKey, enabled) {
      const layer = layerMap[layerKey];
      if (!layer) return;

      const select = document.getElementById(layer.select);
      const container = select?.closest('.layer-control');

      if (select) {
        select.disabled = !enabled;
      }

      if (container) {
        if (enabled) {
          container.classList.remove('off');
        } else {
          container.classList.add('off');
        }
      }

      const handler = window[layer.handler];
      if (typeof handler === 'function') {
        handler();
      }

      updateLegend();
    }
    // ==========================================
    // 3. IMAGE/TILE FETCHING LOGIC (MODIFIED)
    // ==========================================

    const recentTimeThreshold = 15 * 60 * 1000;

    async function fetchTileUrl(timestamp, layerConfig) {
      let layerTypeKey;
      if (Object.values(radarOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(radarOptions).find(key => radarOptions[key] === layerConfig);
      } else if (Object.values(satelliteOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(satelliteOptions).find(key => satelliteOptions[key] === layerConfig);
      } else if (Object.values(isobarOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(isobarOptions).find(key => isobarOptions[key] === layerConfig);
      } else if (Object.values(windOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(windOptions).find(key => windOptions[key] === layerConfig);
      } else if (Object.values(lightningOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(lightningOptions).find(key => lightningOptions[key] === layerConfig);
      } else if (Object.values(tropicalStormsOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(tropicalStormsOptions).find(key => tropicalStormsOptions[key] === layerConfig);
      } else if (Object.values(rotationOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(rotationOptions).find(key => rotationOptions[key] === layerConfig);
      } else if (Object.values(surfaceFrontOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(surfaceFrontOptions).find(key => surfaceFrontOptions[key] === layerConfig);
      } else if (Object.values(observationOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(observationOptions).find(key => observationOptions[key] === layerConfig);
      } else if (Object.values(nowcastOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(nowcastOptions).find(key => nowcastOptions[key] === layerConfig);
      } else if (Object.values(warningOptions).includes(layerConfig)) {
        layerTypeKey = Object.keys(warningOptions).find(key => warningOptions[key] === layerConfig);
      } else {
        console.warn("Unknown layer config passed to fetchTileUrl", layerConfig);
        return null;
      }

      if (layerConfig.type === 'tile-layer') {
        const date = new Date(timestamp);
        const formatISO = (d) => d.toISOString().replace(/\.\d{3}Z$/, 'Z');
        // No validation check needed for standard tile layers, just construct the URL
        return layerConfig.url.replace(/\${iso}/g, formatISO(date));
      }

      // --- Validation/Cache Logic for Image and Vector-Tile Layers ---
      const cacheKey = `${layerTypeKey}_${timestamp}`;
      if (Date.now() - timestamp < recentTimeThreshold) {
        radarValidationCache.delete(cacheKey);
      }
      if (radarValidationCache.has(cacheKey)) {
        return radarValidationCache.get(cacheKey);
      }

      const cacheAndReturn = (result) => {
        if (Date.now() - timestamp >= recentTimeThreshold) {
          radarValidationCache.set(cacheKey, result);
        }
        return result;
      };

      if (typeof timestamp !== 'number' || isNaN(timestamp)) {
        return cacheAndReturn(lastValidTileUrls[layerTypeKey] || null);
      }

      const date = new Date(timestamp);
      const interval = layerConfig.interval || 5 * 60 * 1000;

      date.setMinutes(Math.floor(date.getMinutes() / (interval / 60 / 1000)) * (interval / 60 / 1000));
      date.setSeconds(0);
      date.setMilliseconds(0);

      let minTime = new Date(Date.now() - sixDaysInMs);
      const formatISO = (d) => d.toISOString().replace(/\.\d{3}Z$/, 'Z');


      // --- ENFORCED LOGIC: Determine search bounds based on current filter time ---
      let maxAttempts = layerConfig.type === 'image' ? 4 : 288;
      let isHistoricalView = currentFilterTimestamp && (Date.now() - currentFilterTimestamp) > recentTimeThreshold;
      let currentTimeCheck = new Date(date);

      if (isHistoricalView) {
        maxAttempts = 3;
      } else {
        maxAttempts = layerConfig.type === 'image' ? 4 : 288;
      }


      if (layerConfig.type === 'image') {
        for (let attempt = 0; attempt < maxAttempts && currentTimeCheck >= minTime; attempt++) {
          const url = layerConfig.url.replace(/\${iso}/g, formatISO(currentTimeCheck));
          const img = new Image();
          img.src = url;

          const isValid = await new Promise((resolve) => {
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            setTimeout(() => resolve(false), 5000);
          });

          if (isValid) {
            lastValidTileUrls[layerTypeKey] = url;
            return cacheAndReturn(url);
          }
          currentTimeCheck.setMinutes(currentTimeCheck.getMinutes() - (interval / 60 / 1000));
        }
        return cacheAndReturn(lastValidTileUrls[layerTypeKey] || null);
      } else {
        // Tile Logic (Vector Tiles)
        async function validateTile(checkTime) {
          if (checkTime < minTime) return null;
          const iso = formatISO(checkTime);
          const tileUrl = layerConfig.url.replace(/\${iso}/g, iso);

          // FIX: Use a higher, central zoom tile (6/32/32) instead of the problematic 0/0/0
          const checkUrl = tileUrl.replace('{z}/{x}/{y}', '0/0/0');

          for (let retry = 0; retry < 2; retry++) {
            try {
              const response = await fetch(checkUrl, { method: 'GET' });

              if (response.ok) {
                // REMOVE THE arrayBuffer.byteLength CHECK for vector tiles
                // const arrayBuffer = await response.arrayBuffer();
                // if (arrayBuffer.byteLength > 0) { 
                return tileUrl.replace(/\${iso}/g, iso);
                // }
              }
            } catch (error) {
              // Ignore error
            }
          }
          return null;
        }

        for (let i = 0; i < maxAttempts; i++) {
          const checkTime = new Date(date.getTime() - i * interval);
          const tileUrl = await validateTile(checkTime);
          if (tileUrl) {
            lastValidTileUrls[layerTypeKey] = tileUrl;
            return cacheAndReturn(tileUrl);
          }
        }

        if (lastValidTileUrls[layerTypeKey]) {
          return cacheAndReturn(lastValidTileUrls[layerTypeKey]);
        }

        return cacheAndReturn(null);
      }
    }

    // ==========================================
    // 4. MAIN UPDATE FUNCTIONS (UNIFIED)
    // ==========================================

    /**
     * Plots either the Radar, Satellite, Isobar, or Wind layer with an atomic fade-swap.
     * @param {string} finalUrl - The pre-validated tile URL.
     * @param {string} layerType - The specific key (e.g., 'us-visible', 'uk-precip-intensity', 'global-pressure', 'global-wind').
     * @param {number|null} timestamp - The rounded timestamp of the plotted data.
     * @param {string} layerKey - 'satellite', 'radar', 'isobar', or 'wind'.
     */
    async function plotMainLayer(finalUrl, layerType, timestamp, layerKey) {
      let layerOptions, zIndex, currentLayerRef, lastTimestampRef, lastTypeRef, isAnimatingRef;

      switch (layerKey) {
        case 'satellite':
          layerOptions = satelliteOptions[layerType];
          zIndex = SATELLITE_Z_INDEX;
          currentLayerRef = satelliteLayer;
          // References for state modification, not direct value access
          lastTimestampRef = 'lastSatelliteTimestamp';
          lastTypeRef = 'lastSatelliteType';
          isAnimatingRef = 'isSatelliteAnimating';
          break;
        case 'radar':
          layerOptions = radarOptions[layerType];
          zIndex = RADAR_Z_INDEX;
          currentLayerRef = radarLayer;
          lastTimestampRef = 'lastRadarTimestamp';
          lastTypeRef = 'lastRadarType';
          isAnimatingRef = 'isRadarAnimating';
          break;
        case 'isobar':
          layerOptions = isobarOptions[layerType];
          zIndex = ISOBAR_Z_INDEX;
          currentLayerRef = isobarLayer;
          lastTimestampRef = 'lastIsobarTimestamp';
          lastTypeRef = 'lastIsobarType';
          isAnimatingRef = 'isIsobarAnimating';
          break;
        case 'wind':
          layerOptions = windOptions[layerType];
          zIndex = WIND_Z_INDEX;
          currentLayerRef = windLayer;
          lastTimestampRef = 'lastWindTimestamp';
          lastTypeRef = 'lastWindType';
          isAnimatingRef = 'isWindAnimating';
          break;
        case 'lightning':
          layerOptions = lightningOptions[layerType];
          zIndex = LIGHTNING_Z_INDEX;
          currentLayerRef = lightningLayer;
          lastTimestampRef = 'lastLightningTimestamp';
          lastTypeRef = 'lastLightningType';
          isAnimatingRef = 'isLightningAnimating';
          break;
        case 'tropicalStorms':
          layerOptions = tropicalStormsOptions[layerType];
          zIndex = TROPICAL_STORMS_Z_INDEX;
          currentLayerRef = tropicalStormsLayer;
          lastTimestampRef = 'lastTropicalStormsTimestamp';
          lastTypeRef = 'lastTropicalStormsType';
          isAnimatingRef = 'isTropicalStormsAnimating';
          break;
        case 'rotation':
          layerOptions = rotationOptions[layerType];
          zIndex = ROTATION_Z_INDEX;
          currentLayerRef = rotationLayer;
          lastTimestampRef = 'lastRotationTimestamp';
          lastTypeRef = 'lastRotationType';
          isAnimatingRef = 'isRotationAnimating';
          break;
        case 'surfaceFront':
          layerOptions = surfaceFrontOptions[layerType];
          zIndex = SURFACE_FRONT_Z_INDEX;
          currentLayerRef = surfaceFrontLayer;
          lastTimestampRef = 'lastSurfaceFrontTimestamp';
          lastTypeRef = 'lastSurfaceFrontType';
          isAnimatingRef = 'isSurfaceFrontAnimating';
          break;
        case 'observation':
          layerOptions = observationOptions[layerType];
          zIndex = OBSERVATION_Z_INDEX;
          currentLayerRef = observationLayer;
          lastTimestampRef = 'lastObservationTimestamp';
          lastTypeRef = 'lastObservationType';
          isAnimatingRef = 'isObservationAnimating';
          break;
        case 'nowcast':
          layerOptions = nowcastOptions[layerType];
          zIndex = NOWCAST_Z_INDEX;
          currentLayerRef = NowcastLayer;  // Fixed typo
          lastTimestampRef = 'lastNowcastTimestamp';
          lastTypeRef = 'lastNowcastType';
          isAnimatingRef = 'isNowcastAnimating';
          break;
        case 'warning':
          layerOptions = warningOptions[layerType];
          zIndex = WARNING_Z_INDEX;
          currentLayerRef = warningLayer;
          lastTimestampRef = 'lastWarningTimestamp';
          lastTypeRef = 'lastWarningType';
          isAnimatingRef = 'isWarningAnimating';
          break;
        default:
          return;
      }

      // Note: Direct use of global variables for comparison before the switch is safer for complex state
      const lastPlottedTimestamp = eval(lastTimestampRef);
      const lastPlottedType = eval(lastTypeRef);

      const currentOpacity = parseFloat(document.getElementById(`${layerKey}Opacity`)?.value || 0.8);

      let layerToDispose = currentLayerRef;
      let newLayer = null;

      try {
        // --- Layer Creation (Unified Logic) --- (unchanged)
        if (layerOptions.type === 'image') {
          newLayer = L.imageOverlay(finalUrl, layerOptions.bounds, {
            opacity: 0.01,
            zIndex: zIndex,
            attribution: layerOptions.attribution,
            className: 'seamless-layer'
          });
        } else if (layerOptions.type === 'vector-tile') {
          try {
            const defaultStyle = { fill: true, opacity: 0.01, fillOpacity: 0.01, weight: 0, color: 'inherit' };
            let vectorStyles = {};
            const baseOpacity = 0.01;

            if (layerKey === 'isobar') {
              vectorStyles = {
                'default': { stroke: true, color: '#FFFFFF', weight: 2, opacity: baseOpacity, fill: false },
                'features': { stroke: true, color: '#FFFFFF', weight: 2, opacity: baseOpacity, fill: false }
              };
            } else if (layerKey === 'wind') {
              vectorStyles = {
                'default': { stroke: true, color: '#88E0FF', weight: 1, opacity: baseOpacity, fill: false },
                'features': { stroke: true, color: '#88E0FF', weight: 1, opacity: baseOpacity, fill: false }
              };
            } else {
              vectorStyles = { 'default': defaultStyle, 'features': defaultStyle };
            }

            newLayer = L.vectorGrid.protobuf(finalUrl, {
              opacity: 0.01,
              vectorTileLayerStyles: vectorStyles,
              className: 'seamless-layer',
              zIndex: zIndex
            });
          } catch (error) {
            newLayer = L.tileLayer(finalUrl, {
              opacity: 0.01, zIndex: zIndex, attribution: layerOptions.attribution, className: 'seamless-layer'
            });
          }
        } else { // 'tile-layer'
          newLayer = L.tileLayer(finalUrl, {
            opacity: 0.01,
            zIndex: zIndex,
            attribution: layerOptions.attribution,
            tms: true,
            tileSize: 256,
            className: 'seamless-layer'
          });
        }

        if (!newLayer) return;

        newLayer.addTo(map);

        // --- Wait for Layer Load ---
        const layerLoadedPromise = new Promise(resolve => {
          const timeout = setTimeout(() => resolve(true), 1000);
          newLayer.once('load', () => { clearTimeout(timeout); resolve(true); });
          newLayer.once('error', () => { clearTimeout(timeout); resolve(false); });
        });

        const success = await layerLoadedPromise;

        // --- Robustness Check: Requested Timestamp and Layer Type ---
        // Accessing lastRequested timestamps
        let requestedTimestamp;
        switch (layerKey) {
          case 'satellite': requestedTimestamp = lastRequestedSatelliteTimestamp; break;
          case 'radar': requestedTimestamp = lastRequestedRadarTimestamp; break;
          case 'isobar': requestedTimestamp = lastRequestedIsobarTimestamp; break;
          case 'wind': requestedTimestamp = lastRequestedWindTimestamp; break;
          case 'lightning': requestedTimestamp = lastRequestedLightningTimestamp; break;
          case 'tropicalStorms': requestedTimestamp = lastRequestedTropicalStormsTimestamp; break;
          case 'rotation': requestedTimestamp = lastRequestedRotationTimestamp; break;
          case 'surfaceFront': requestedTimestamp = lastRequestedSurfaceFrontTimestamp; break;
          case 'observation': requestedTimestamp = lastRequestedObservationTimestamp; break;
          case 'nowcast': requestedTimestamp = lastRequestedNowcastTimestamp; break;
          case 'warning': requestedTimestamp = lastRequestedWarningTimestamp; break;
        }

        const currentType = (
          document.getElementById(`${layerKey}LayerSelect`) ||
          document.getElementById(`${layerKey}Layer`)
        )?.value || 'none';

        if (currentType !== layerType || (timestamp !== null && lastPlottedTimestamp === timestamp)) {
          if (newLayer && map.hasLayer(newLayer)) {
            map.removeLayer(newLayer);
          }
          return;
        }

        if (success) {
          // 1. Update active layer and state variables (Direct variable modification)
          switch (layerKey) {
            case 'satellite':
              satelliteLayer = newLayer;
              lastSatelliteTimestamp = timestamp !== null ? timestamp : lastSatelliteTimestamp;
              lastSatelliteType = layerType;
              break;
            case 'radar':
              radarLayer = newLayer;
              lastRadarTimestamp = timestamp !== null ? timestamp : lastRadarTimestamp;
              lastRadarType = layerType;
              break;
            case 'isobar':
              isobarLayer = newLayer;
              lastIsobarTimestamp = timestamp !== null ? timestamp : lastIsobarTimestamp;
              lastIsobarType = layerType;
              break;
            case 'wind':
              windLayer = newLayer;
              lastWindTimestamp = timestamp !== null ? timestamp : lastWindTimestamp;
              lastWindType = layerType;
              break;
            case 'lightning':
              lightningLayer = newLayer;
              lastLightningTimestamp = timestamp !== null ? timestamp : lastLightningTimestamp;
              lastLightningType = layerType;
              break;
            case 'tropicalStorms':
              tropicalStormsLayer = newLayer;
              lastTropicalStormsTimestamp = timestamp !== null ? timestamp : lastTropicalStormsTimestamp;
              lastTropicalStormsType = layerType;
              break;
            case 'rotation':
              rotationLayer = newLayer;
              lastRotationTimestamp = timestamp !== null ? timestamp : lastRotationTimestamp;
              lastRotationType = layerType;
              break;
            case 'surfaceFront':
              surfaceFrontLayer = newLayer;
              lastSurfaceFrontTimestamp = timestamp !== null ? timestamp : lastSurfaceFrontTimestamp;
              lastSurfaceFrontType = layerType;
              break;
            case 'observation':
              observationLayer = newLayer;
              lastObservationTimestamp = timestamp !== null ? timestamp : lastObservationTimestamp;
              lastObservationType = layerType;
              break;
            case 'nowcast':
              NowcastLayer = newLayer;
              lastNowcastTimestamp = timestamp !== null ? timestamp : lastNowcastTimestamp;
              lastNowcastType = layerType;
              break;
            case 'warning':
              warningLayer = newLayer;
              lastWarningTimestamp = timestamp !== null ? timestamp : lastWarningTimestamp;
              lastWarningType = layerType;
              break;
          }

          // 2. Fade In
          if (newLayer.getElement) {
            const imgElement = newLayer.getElement();
            if (imgElement) imgElement.style.opacity = currentOpacity;
          } else if (newLayer.setOpacity) {
            newLayer.setOpacity(currentOpacity);
          }

          // 3. Fade Out & Remove Old Layer
          if (layerToDispose && map.hasLayer(layerToDispose)) {
            if (layerToDispose.getElement) {
              const oldImgElement = layerToDispose.getElement();
              if (oldImgElement) oldImgElement.style.opacity = 0;
            } else if (layerToDispose.setOpacity) {
              layerToDispose.setOpacity(0);
            }

            setTimeout(() => {
              if (map.hasLayer(layerToDispose)) {
                map.removeLayer(layerToDispose);
              }
            }, 350);
          }

          lastValidTileUrls[layerType] = finalUrl;

        } else {
          if (newLayer && map.hasLayer(newLayer)) {
            map.removeLayer(newLayer);
          }
        }

      } catch (error) {
        console.error(`Critical plotting error during ${layerKey} layer creation/swap:`, error);
        if (newLayer && map.hasLayer(newLayer)) {
          map.removeLayer(newLayer);
        }
      } finally {
        // Reset animation flag for ALL layers
        switch (layerKey) {
          case 'satellite': isSatelliteAnimating = false; break;
          case 'radar': isRadarAnimating = false; break;
          case 'isobar': isIsobarAnimating = false; break;
          case 'wind': isWindAnimating = false; break;
          case 'lightning': isLightningAnimating = false; break;
          case 'tropicalStorms': isTropicalStormsAnimating = false; break;
          case 'rotation': isRotationAnimating = false; break;
          case 'surfaceFront': isSurfaceFrontAnimating = false; break;
          case 'observation': isObservationAnimating = false; break;
          case 'nowcast': isNowcastAnimating = false; break;
          case 'warning': isWarningAnimating = false; break;
        }
      }
    }


    /**
     * Main function to coordinate updating the map layers.
     * @param {number} timestamp - The target timestamp from the slider/current time.
     */
    async function updateMapLayers(timestamp) {
      if (isPlotting) return;
      isPlotting = true;

      const PROCESSING_DELAY_MS = 5 * 60 * 1000;
      let targetTimestamp = timestamp;
      const timeSlider = document.getElementById('history-slider');
      if (timeSlider && timeSlider.value === timeSlider.max) {
        targetTimestamp = Date.now() - PROCESSING_DELAY_MS;
      }

      const getLayerType = (id) => {
        const el = document.getElementById(id);
        return el && !el.disabled ? el.value : null;
      };

      const radarType = getLayerType('radarLayer');
      const satelliteType = getLayerType('satelliteLayerSelect');
      const isobarType = getLayerType('isobarLayerSelect');
      const windType = getLayerType('windLayerSelect');
      const lightningType = getLayerType('lightningLayerSelect');
      const tropicalStormsType = getLayerType('tropicalStormsLayerSelect');
      const rotationType = getLayerType('rotationLayerSelect');
      const surfaceFrontType = getLayerType('surfaceFrontLayerSelect');
      const observationType = getLayerType('observationLayerSelect');
      const nowcastType = getLayerType('nowcastLayerSelect');
      const warningType = getLayerType('warningLayerSelect');

      if (radarType) await plotLayerIfNecessary(radarType, radarOptions, targetTimestamp, 'radar');
      if (satelliteType) await plotLayerIfNecessary(satelliteType, satelliteOptions, targetTimestamp, 'satellite');
      if (isobarType) await plotLayerIfNecessary(isobarType, isobarOptions, targetTimestamp, 'isobar');
      if (windType) await plotLayerIfNecessary(windType, windOptions, targetTimestamp, 'wind');
      if (lightningType) await plotLayerIfNecessary(lightningType, lightningOptions, targetTimestamp, 'lightning');
      if (tropicalStormsType) await plotLayerIfNecessary(tropicalStormsType, tropicalStormsOptions, targetTimestamp, 'tropicalStorms');
      if (rotationType) await plotLayerIfNecessary(rotationType, rotationOptions, targetTimestamp, 'rotation');
      if (surfaceFrontType) await plotLayerIfNecessary(surfaceFrontType, surfaceFrontOptions, targetTimestamp, 'surfaceFront');
      if (observationType) await plotLayerIfNecessary(observationType, observationOptions, targetTimestamp, 'observation');
      if (nowcastType) await plotLayerIfNecessary(nowcastType, nowcastOptions, targetTimestamp, 'nowcast');
      if (warningType) await plotLayerIfNecessary(warningType, warningOptions, targetTimestamp, 'warning');

      isPlotting = false;
      updateLegend();
    }

    // ==========================================
    // DEBOUNCED TRIGGER (CLEARS ALL IF NOTHING ENABLED)
    // ==========================================
    // ==========================================
    // DEBOUNCED TRIGGER (CLEARS ALL IF NOTHING ENABLED)
    // ==========================================
    const triggerMapUpdate = debounce((timestamp) => {
      currentFilterTimestamp = timestamp;

      const anyEnabled = [
        'radarLayer', 'satelliteLayerSelect', 'isobarLayerSelect', 'windLayerSelect',
        'lightningLayerSelect', 'tropicalStormsLayerSelect', 'rotationLayerSelect',
        'surfaceFrontLayerSelect', 'observationLayerSelect', 'nowcastLayerSelect', 'warningLayerSelect'
      ].some(id => {
        const el = document.getElementById(id);
        return el && !el.disabled && el.value;
      });

      if (!anyEnabled) {
        clearRadarLayers();
        clearSatelliteLayers();
        clearIsobarLayers();
        clearWindLayers();
        clearLightningLayers();
        clearTropicalStormsLayers();
        clearRotationLayers();
        clearSurfaceFrontLayers();
        clearObservationLayers();
        clearNowcastLayers();
        clearWarningLayers();
        updateLegend();
        return;
      }

      updateMapLayers(timestamp);
    }, 100);

    /**
     * Generic logic to check state, fetch URLs, and call the plotting function.
     * @param {string} layerType - The specific layer key.
     * @param {object} optionsMap - The options map (radarOptions, satelliteOptions, isobarOptions, windOptions).
     * @param {number} targetTimestamp - The target timestamp.
     * @param {string} layerKey - 'satellite', 'radar', 'isobar', or 'wind', etc.
     */
    async function plotLayerIfNecessary(layerType, optionsMap, targetTimestamp, layerKey) {
      const layerConfig = optionsMap[layerType];

      if (!layerConfig) {
        console.error(`Layer configuration not found for type: ${layerType}`);

        let currentLayer;
        // The original file ended here, completing the switch:
        switch (layerKey) {
          case 'satellite': currentLayer = satelliteLayer; break;
          case 'radar': currentLayer = radarLayer; break;
          case 'isobar': currentLayer = isobarLayer; break;
          case 'wind': currentLayer = windLayer; break;
          case 'lightning': currentLayer = lightningLayer; break;
          case 'tropicalStorms': currentLayer = tropicalStormsLayer; break;
          case 'rotation': currentLayer = rotationLayer; break;
          case 'surfaceFront': currentLayer = surfaceFrontLayer; break;
          case 'observation': currentLayer = observationLayer; break;
          case 'nowcast': currentLayer = NowcastLayer; break;
          case 'warning': currentLayer = warningLayer; break;
          default: return;
        }

        if (currentLayer && map.hasLayer(currentLayer)) {
          map.removeLayer(currentLayer);
        }

        // Must exit here if config is missing
        return;
      }

      let lastTimestamp;
      let isAnimating;
      let lastRequestedTimestamp;

      switch (layerKey) {
        case 'satellite': lastTimestamp = lastSatelliteTimestamp; isAnimating = isSatelliteAnimating; lastRequestedTimestamp = lastRequestedSatelliteTimestamp; break;
        case 'radar': lastTimestamp = lastRadarTimestamp; isAnimating = isRadarAnimating; lastRequestedTimestamp = lastRequestedRadarTimestamp; break;
        case 'isobar': lastTimestamp = lastIsobarTimestamp; isAnimating = isIsobarAnimating; lastRequestedTimestamp = lastRequestedIsobarTimestamp; break;
        case 'wind': lastTimestamp = lastWindTimestamp; isAnimating = isWindAnimating; lastRequestedTimestamp = lastRequestedWindTimestamp; break;
        case 'lightning': lastTimestamp = lastLightningTimestamp; isAnimating = isLightningAnimating; lastRequestedTimestamp = lastRequestedLightningTimestamp; break;
        case 'tropicalStorms': lastTimestamp = lastTropicalStormsTimestamp; isAnimating = isTropicalStormsAnimating; lastRequestedTimestamp = lastRequestedTropicalStormsTimestamp; break;
        case 'rotation': lastTimestamp = lastRotationTimestamp; isAnimating = isRotationAnimating; lastRequestedTimestamp = lastRequestedRotationTimestamp; break;
        case 'surfaceFront': lastTimestamp = lastSurfaceFrontTimestamp; isAnimating = isSurfaceFrontAnimating; lastRequestedTimestamp = lastRequestedSurfaceFrontTimestamp; break;
        case 'observation': lastTimestamp = lastObservationTimestamp; isAnimating = isObservationAnimating; lastRequestedTimestamp = lastRequestedObservationTimestamp; break;
        case 'nowcast': lastTimestamp = lastNowcastTimestamp; isAnimating = isNowcastAnimating; lastRequestedTimestamp = lastRequestedNowcastTimestamp; break;
        case 'warning': lastTimestamp = lastWarningTimestamp; isAnimating = isWarningAnimating; lastRequestedTimestamp = lastRequestedWarningTimestamp; break;
        default: return;
      }

      if (isAnimating) return;

      // Prevent redundant fetches for the same timestamp
      if (lastTimestamp && lastTimestamp === targetTimestamp) {
        // Optimization: Check if the layer type has changed, even if timestamp is the same
        let lastType;
        switch (layerKey) {
          case 'satellite': lastType = lastSatelliteType; break;
          case 'radar': lastType = lastRadarType; break;
          case 'isobar': lastType = lastIsobarType; break;
          case 'wind': lastType = lastWindType; break;
          case 'lightning': lastType = lastLightningType; break;
          case 'tropicalStorms': lastType = lastTropicalStormsType; break;
          case 'rotation': lastType = lastRotationType; break;
          case 'surfaceFront': lastType = lastSurfaceFrontType; break;
          case 'observation': lastType = lastObservationType; break;
          case 'nowcast': lastType = lastNowcastType; break;
          case 'warning': lastType = lastWarningType; break;
        }

        if (lastType === layerType) {
          return;
        }
      }

      // Set animating flag
      switch (layerKey) {
        case 'satellite': isSatelliteAnimating = true; lastRequestedSatelliteTimestamp = targetTimestamp; break;
        case 'radar': isRadarAnimating = true; lastRequestedRadarTimestamp = targetTimestamp; break;
        case 'isobar': isIsobarAnimating = true; lastRequestedIsobarTimestamp = targetTimestamp; break;
        case 'wind': isWindAnimating = true; lastRequestedWindTimestamp = targetTimestamp; break;
        case 'lightning': isLightningAnimating = true; lastRequestedLightningTimestamp = targetTimestamp; break;
        case 'tropicalStorms': isTropicalStormsAnimating = true; lastRequestedTropicalStormsTimestamp = targetTimestamp; break;
        case 'rotation': isRotationAnimating = true; lastRequestedRotationTimestamp = targetTimestamp; break;
        case 'surfaceFront': isSurfaceFrontAnimating = true; lastRequestedSurfaceFrontTimestamp = targetTimestamp; break;
        case 'observation': isObservationAnimating = true; lastRequestedObservationTimestamp = targetTimestamp; break;
        case 'nowcast': isNowcastAnimating = true; lastRequestedNowcastTimestamp = targetTimestamp; break;
        case 'warning': isWarningAnimating = true; lastRequestedWarningTimestamp = targetTimestamp; break;
      }

      const finalUrl = await fetchTileUrl(targetTimestamp, layerConfig);

      if (finalUrl) {
        await plotMainLayer(finalUrl, layerType, targetTimestamp, layerKey);
      } else {
        // Clear the layer if no URL is found
        let layerToClear;
        switch (layerKey) {
          case 'satellite': layerToClear = satelliteLayer; break;
          case 'radar': layerToClear = radarLayer; break;
          case 'isobar': layerToClear = isobarLayer; break;
          case 'wind': layerToClear = windLayer; break;
          case 'lightning': layerToClear = lightningLayer; break;
          case 'tropicalStorms': layerToClear = tropicalStormsLayer; break;
          case 'rotation': layerToClear = rotationLayer; break;
          case 'surfaceFront': layerToClear = surfaceFrontLayer; break;
          case 'observation': layerToClear = observationLayer; break;
          case 'nowcast': layerToClear = NowcastLayer; break;
          case 'warning': layerToClear = warningLayer; break;
        }

        if (layerToClear && map.hasLayer(layerToClear)) {
          map.removeLayer(layerToClear);
          // And set the global reference to null
          switch (layerKey) {
            case 'satellite': satelliteLayer = null; break;
            case 'radar': radarLayer = null; break;
            case 'isobar': isobarLayer = null; break;
            case 'wind': windLayer = null; break;
            case 'lightning': lightningLayer = null; break;
            case 'tropicalStorms': tropicalStormsLayer = null; break;
            case 'rotation': rotationLayer = null; break;
            case 'surfaceFront': surfaceFrontLayer = null; break;
            case 'observation': observationLayer = null; break;
            case 'nowcast': NowcastLayer = null; break;
            case 'warning': warningLayer = null; break;
          }
        }

        // Ensure animating flag is reset even on failure
        switch (layerKey) {
          case 'satellite': isSatelliteAnimating = false; break;
          case 'radar': isRadarAnimating = false; break;
          case 'isobar': isIsobarAnimating = false; break;
          case 'wind': isWindAnimating = false; break;
          case 'lightning': isLightningAnimating = false; break;
          case 'tropicalStorms': isTropicalStormsAnimating = false; break;
          case 'rotation': isRotationAnimating = false; break;
          case 'surfaceFront': isSurfaceFrontAnimating = false; break;
          case 'observation': isObservationAnimating = false; break;
          case 'nowcast': isNowcastAnimating = false; break;
          case 'warning': isWarningAnimating = false; break;
        }
      }
    }


    /**
     * Main function to coordinate updating the map layers.
     * @param {number} timestamp - The target timestamp from the slider/current time.
     */
    async function updateMapLayers(timestamp) {
      if (isPlotting) return;
      isPlotting = true;

      const PROCESSING_DELAY_MS = 5 * 60 * 1000;
      let targetTimestamp = timestamp;
      const timeSlider = document.getElementById('history-slider');
      if (timeSlider && timeSlider.value === timeSlider.max) {
        targetTimestamp = Date.now() - PROCESSING_DELAY_MS;
      }

      const getLayerType = (id) => {
        const el = document.getElementById(id);
        return el && !el.disabled ? el.value : null;
      };

      const radarType = getLayerType('radarLayer');
      const satelliteType = getLayerType('satelliteLayerSelect');
      const isobarType = getLayerType('isobarLayerSelect');
      const windType = getLayerType('windLayerSelect');
      const lightningType = getLayerType('lightningLayerSelect');
      const tropicalStormsType = getLayerType('tropicalStormsLayerSelect');
      const rotationType = getLayerType('rotationLayerSelect');
      const surfaceFrontType = getLayerType('surfaceFrontLayerSelect');
      const observationType = getLayerType('observationLayerSelect');
      const nowcastType = getLayerType('nowcastLayerSelect');
      const warningType = getLayerType('warningLayerSelect');

      if (radarType) await plotLayerIfNecessary(radarType, radarOptions, targetTimestamp, 'radar');
      if (satelliteType) await plotLayerIfNecessary(satelliteType, satelliteOptions, targetTimestamp, 'satellite');
      if (isobarType) await plotLayerIfNecessary(isobarType, isobarOptions, targetTimestamp, 'isobar');
      if (windType) await plotLayerIfNecessary(windType, windOptions, targetTimestamp, 'wind');
      if (lightningType) await plotLayerIfNecessary(lightningType, lightningOptions, targetTimestamp, 'lightning');
      if (tropicalStormsType) await plotLayerIfNecessary(tropicalStormsType, tropicalStormsOptions, targetTimestamp, 'tropicalStorms');
      if (rotationType) await plotLayerIfNecessary(rotationType, rotationOptions, targetTimestamp, 'rotation');
      if (surfaceFrontType) await plotLayerIfNecessary(surfaceFrontType, surfaceFrontOptions, targetTimestamp, 'surfaceFront');
      if (observationType) await plotLayerIfNecessary(observationType, observationOptions, targetTimestamp, 'observation');
      if (nowcastType) await plotLayerIfNecessary(nowcastType, nowcastOptions, targetTimestamp, 'nowcast');
      if (warningType) await plotLayerIfNecessary(warningType, warningOptions, targetTimestamp, 'warning');

      isPlotting = false;
      updateLegend();
    }


    /**
     * Generic logic to check state, fetch URLs, and call the plotting function.
     * @param {string} layerType - The specific layer key.
     * @param {object} optionsMap - The options map (radarOptions, satelliteOptions, isobarOptions, windOptions).
     * @param {number} targetTimestamp - The target timestamp.
     * @param {string} layerKey - 'satellite', 'radar', 'isobar', or 'wind'.
     */
    async function plotLayerIfNecessary(layerType, optionsMap, targetTimestamp, layerKey) {
      const layerConfig = optionsMap[layerType];

      if (!layerConfig) {
        console.error(`Layer configuration not found for type: ${layerType}`);
        // ... (Layer cleanup logic omitted for brevity, assuming it's correct from your snippet) ...
        return;
      }

      const interval = layerConfig.interval || 5 * 60 * 1000;

      const roundedDate = new Date(targetTimestamp);
      roundedDate.setMinutes(Math.floor(roundedDate.getMinutes() / (interval / 60 / 1000)) * (interval / 60 / 1000));
      roundedDate.setSeconds(0);
      roundedDate.setMilliseconds(0);
      const roundedTimestampMs = roundedDate.getTime();

      // Get current state variables based on layerKey
      let lastTimestamp, lastType, isAnimating;
      switch (layerKey) {
        case 'satellite': lastTimestamp = lastSatelliteTimestamp; lastType = lastSatelliteType; isAnimating = isSatelliteAnimating; break;
        case 'radar': lastTimestamp = lastRadarTimestamp; lastType = lastRadarType; isAnimating = isRadarAnimating; break;
        case 'isobar': lastTimestamp = lastIsobarTimestamp; lastType = lastIsobarType; isAnimating = isIsobarAnimating; break;
        case 'wind': lastTimestamp = lastWindTimestamp; lastType = lastWindType; isAnimating = isWindAnimating; break;
        case 'lightning': lastTimestamp = lastLightningTimestamp; lastType = lastLightningType; isAnimating = isLightningAnimating; break;
        case 'tropicalStorms': lastTimestamp = lastTropicalStormsTimestamp; lastType = lastTropicalStormsType; isAnimating = isTropicalStormsAnimating; break;
        case 'rotation': lastTimestamp = lastRotationTimestamp; lastType = lastRotationType; isAnimating = isRotationAnimating; break;
        case 'surfaceFront': lastTimestamp = lastSurfaceFrontTimestamp; lastType = lastSurfaceFrontType; isAnimating = isSurfaceFrontAnimating; break;
        case 'observation': lastTimestamp = lastObservationTimestamp; lastType = lastObservationType; isAnimating = isObservationAnimating; break;
        case 'nowcast': lastTimestamp = lastNowcastTimestamp; lastType = lastNowcastType; isAnimating = isNowcastAnimating; break;
        case 'warning': lastTimestamp = lastWarningTimestamp; lastType = lastWarningType; isAnimating = isWarningAnimating; break;
        default: return;
      }

      // Prevent unnecessary re-plotting (redundant, if timestamp/type haven't changed)
      // Only skip if timestamp hasn't changed (type change from dropdown always forces plot)
      if (lastTimestamp === roundedTimestampMs) {
        return;
      }

      // Prevent concurrent animations
      if (isAnimating) return;

      // Set animating flag and requested timestamp
      switch (layerKey) {
        case 'satellite': isSatelliteAnimating = true; lastRequestedSatelliteTimestamp = roundedTimestampMs; break;
        case 'radar': isRadarAnimating = true; lastRequestedRadarTimestamp = roundedTimestampMs; break;
        case 'isobar': isIsobarAnimating = true; lastRequestedIsobarTimestamp = roundedTimestampMs; break;
        case 'wind': isWindAnimating = true; lastRequestedWindTimestamp = roundedTimestampMs; break;
        case 'lightning': isLightningAnimating = true; lastRequestedLightningTimestamp = roundedTimestampMs; break;
        case 'tropicalStorms': isTropicalStormsAnimating = true; lastRequestedTropicalStormsTimestamp = roundedTimestampMs; break;
        case 'rotation': isRotationAnimating = true; lastRequestedRotationTimestamp = roundedTimestampMs; break;
        case 'surfaceFront': isSurfaceFrontAnimating = true; lastRequestedSurfaceFrontTimestamp = roundedTimestampMs; break;
        case 'observation': isObservationAnimating = true; lastRequestedObservationTimestamp = roundedTimestampMs; break;
        case 'nowcast': isNowcastAnimating = true; lastRequestedNowcastTimestamp = roundedTimestampMs; break;
        case 'warning': isWarningAnimating = true; lastRequestedWarningTimestamp = roundedTimestampMs; break;
      }

      try {
        let finalUrl = null;
        let finalTimestamp = roundedTimestampMs;

        // Optimized Fetch Logic (fetches up to 3 tiles back)
        const urls = await Promise.all([
          fetchTileUrl(roundedTimestampMs, layerConfig).catch(() => null),
          fetchTileUrl(roundedTimestampMs - interval, layerConfig).catch(() => null),
          fetchTileUrl(roundedTimestampMs - 2 * interval, layerConfig).catch(() => null)
        ]);

        const [currentUrl, previousUrl1, previousUrl2] = urls;

        // Find the most recent valid URL and update the effective timestamp
        if (currentUrl) {
          finalUrl = currentUrl;
          finalTimestamp = roundedTimestampMs;
        } else if (previousUrl1) {
          finalUrl = previousUrl1;
          finalTimestamp = roundedTimestampMs - interval;
        } else if (previousUrl2) {
          finalUrl = previousUrl2;
          finalTimestamp = roundedTimestampMs - 2 * interval;
        } else if (lastValidTileUrls[layerType]) {
          // Fallback to the last successfully plotted URL (no timestamp update)
          finalUrl = lastValidTileUrls[layerType];
          finalTimestamp = null;
        }

        if (finalUrl) {
          await plotMainLayer(finalUrl, layerType, finalTimestamp, layerKey);
        } else {
          // --- FIX: Ensure Layer Removal and State Reset on URL Failure ---
          let currentLayer;
          switch (layerKey) {
            case 'satellite': currentLayer = satelliteLayer; satelliteLayer = null; break;
            case 'radar': currentLayer = radarLayer; radarLayer = null; break;
            case 'isobar': currentLayer = isobarLayer; isobarLayer = null; break;
            case 'wind': currentLayer = windLayer; windLayer = null; break;
            case 'lightning': currentLayer = lightningLayer; lightningLayer = null; break;
            case 'tropicalStorms': currentLayer = tropicalStormsLayer; tropicalStormsLayer = null; break;
            case 'rotation': currentLayer = rotationLayer; rotationLayer = null; break;
            case 'surfaceFront': currentLayer = surfaceFrontLayer; surfaceFrontLayer = null; break;
            case 'observation': currentLayer = observationLayer; observationLayer = null; break;
            case 'nowcast': currentLayer = NowcastLayer; NowcastLayer = null; break;
            case 'warning': currentLayer = warningLayer; warningLayer = null; break;
          }

          if (currentLayer && map.hasLayer(currentLayer)) {
            map.removeLayer(currentLayer);
          }
        }

        if (!finalUrl) {
          console.warn(`No valid URL for ${layerKey} ${layerType} at ${new Date(targetTimestamp).toISOString()}`);
        }
      } catch (error) {
        console.error(`Error in plotLayerIfNecessary for ${layerType} (${layerKey}):`, error);
      } finally {
        // Always reset the animation flag, regardless of success or failure
        switch (layerKey) {
          case 'satellite': isSatelliteAnimating = false; break;
          case 'radar': isRadarAnimating = false; break;
          case 'isobar': isIsobarAnimating = false; break;
          case 'wind': isWindAnimating = false; break;
          case 'lightning': isLightningAnimating = false; break;
          case 'tropicalStorms': isTropicalStormsAnimating = false; break;
          case 'rotation': isRotationAnimating = false; break;
          case 'surfaceFront': isSurfaceFrontAnimating = false; break;
          case 'observation': isObservationAnimating = false; break;
          case 'nowcast': isNowcastAnimating = false; break;
          case 'warning': isWarningAnimating = false; break;
        }
      }
    }
    // ==========================================
    // 5. UTILITY AND EVENT HANDLERS
    // ==========================================
    // ==========================================
    // CLEAR FUNCTIONS
    // ==========================================
    function clearRadarLayers() { if (radarLayer && map.hasLayer(radarLayer)) map.removeLayer(radarLayer); radarLayer = null; lastRadarTimestamp = null; lastRadarType = null; }
    function clearSatelliteLayers() { if (satelliteLayer && map.hasLayer(satelliteLayer)) map.removeLayer(satelliteLayer); satelliteLayer = null; lastSatelliteTimestamp = null; lastSatelliteType = null; }
    function clearIsobarLayers() { if (isobarLayer && map.hasLayer(isobarLayer)) map.removeLayer(isobarLayer); isobarLayer = null; lastIsobarTimestamp = null; lastIsobarType = null; }
    function clearWindLayers() { if (windLayer && map.hasLayer(windLayer)) map.removeLayer(windLayer); windLayer = null; lastWindTimestamp = null; lastWindType = null; }
    function clearLightningLayers() { if (lightningLayer && map.hasLayer(lightningLayer)) map.removeLayer(lightningLayer); lightningLayer = null; lastLightningTimestamp = null; lastLightningType = null; }
    function clearTropicalStormsLayers() { if (tropicalStormsLayer && map.hasLayer(tropicalStormsLayer)) map.removeLayer(tropicalStormsLayer); tropicalStormsLayer = null; lastTropicalStormsTimestamp = null; lastTropicalStormsType = null; }
    function clearRotationLayers() { if (rotationLayer && map.hasLayer(rotationLayer)) map.removeLayer(rotationLayer); rotationLayer = null; lastRotationTimestamp = null; lastRotationType = null; }
    function clearSurfaceFrontLayers() { if (surfaceFrontLayer && map.hasLayer(surfaceFrontLayer)) map.removeLayer(surfaceFrontLayer); surfaceFrontLayer = null; lastSurfaceFrontTimestamp = null; lastSurfaceFrontType = null; }
    function clearObservationLayers() { if (observationLayer && map.hasLayer(observationLayer)) map.removeLayer(observationLayer); observationLayer = null; lastObservationTimestamp = null; lastObservationType = null; }
    function clearNowcastLayers() { if (NowcastLayer && map.hasLayer(NowcastLayer)) map.removeLayer(NowcastLayer); NowcastLayer = null; lastNowcastTimestamp = null; lastNowcastType = null; }
    function clearWarningLayers() { if (warningLayer && map.hasLayer(warningLayer)) map.removeLayer(warningLayer); warningLayer = null; lastWarningTimestamp = null; lastWarningType = null; }
    function updateLayerOpacities() {
      // Fetch all opacity values
      const opacities = {
        radar: parseFloat(document.getElementById('radarOpacity')?.value || 0.8),
        satellite: parseFloat(document.getElementById('satelliteOpacity')?.value || 0.8),
        isobar: parseFloat(document.getElementById('isobarOpacity')?.value || 0.8),
        wind: parseFloat(document.getElementById('windOpacity')?.value || 0.8),
        lightning: parseFloat(document.getElementById('lightningOpacity')?.value || 0.8),
        tropicalStorms: parseFloat(document.getElementById('tropicalStormsOpacity')?.value || 0.8),
        rotation: parseFloat(document.getElementById('rotationOpacity')?.value || 0.8),
        surfaceFront: parseFloat(document.getElementById('surfaceFrontOpacity')?.value || 0.8),
        observation: parseFloat(document.getElementById('observationOpacity')?.value || 0.8),
        nowcast: parseFloat(document.getElementById('nowcastOpacity')?.value || 0.8),
        warning: parseFloat(document.getElementById('warningOpacity')?.value || 0.8)
      };

      // Define all layers with their associated color (for vector-tile styling)
      const layerList = [
        { layer: radarLayer, opacity: opacities.radar, color: '#FF8C00', key: 'radar' },         // Orange for precipitation
        { layer: satelliteLayer, opacity: opacities.satellite, color: null, key: 'satellite' },     // Satellite usually image/tile, no vector color needed
        { layer: isobarLayer, opacity: opacities.isobar, color: '#FFFFFF', key: 'isobar' },        // White lines
        { layer: windLayer, opacity: opacities.wind, color: '#88E0FF', key: 'wind' },          // Light blue
        { layer: lightningLayer, opacity: opacities.lightning, color: '#FFFF00', key: 'lightning' },     // Yellow
        { layer: tropicalStormsLayer, opacity: opacities.tropicalStorms, color: '#FF00FF', key: 'tropicalStorms' },// Magenta
        { layer: rotationLayer, opacity: opacities.rotation, color: '#00FFFF', key: 'rotation' },      // Cyan
        { layer: surfaceFrontLayer, opacity: opacities.surfaceFront, color: '#FFFFFF', key: 'surfaceFront' },  // White (or customize)
        { layer: observationLayer, opacity: opacities.observation, color: '#00FF00', key: 'observation' },   // Green
        { layer: NowcastLayer, opacity: opacities.nowcast, color: '#FFA500', key: 'nowcast' },       // Orange
        { layer: warningLayer, opacity: opacities.warning, color: '#FF0000', key: 'warning' }        // Red
      ];

      layerList.forEach(({ layer, opacity, color, key }) => {
        if (!layer) return;

        // Special handling for satellite: it's usually a tile-layer or image, rarely vector
        if (key === 'satellite') {
          const satelliteType = document.getElementById('satelliteLayerSelect')?.value;
          const config = satelliteOptions[satelliteType];
          if (config?.type === 'tile-layer' || config?.type === 'image') {
            if (layer.setOpacity) {
              layer.setOpacity(opacity);
            } else if (layer.getElement) {
              const el = layer.getElement();
              if (el) el.style.opacity = opacity;
            }
          }
          return;
        }

        // Special handling for radar: may be vector-tile with complex styling

        const radarType = document.getElementById('radarLayer')?.value;
        const config = radarOptions[radarType];

        if (config?.type === 'vector-tile' && layer.setStyle && color) {
          // For vector radar, apply custom style with opacity
          const newStyles = createVectorLayerStyles(opacity, color);
          layer.setStyle(newStyles);
          return;
        }
        // Fall through to general opacity handling below


        // General case: vector-tile (setStyle) > standard setOpacity > image overlay (getElement)
        if (layer.setStyle && color) {
          // Vector tile layer ‚Äî update stroke/fill opacity using predefined color
          layer.setStyle(createVectorLayerStyles(opacity, color));
        } else if (layer.setOpacity) {
          // Standard tile or image overlay
          layer.setOpacity(opacity);
        } else if (layer.getElement) {
          // Fallback for image overlays
          const el = layer.getElement();
          if (el) el.style.opacity = opacity;
        }
      });

      // Update legend with current values
      updateLegend();
    }
    /**
     * Creates the style object required for L.vectorGrid.setStyle()
     * @param {number} opacity - The target opacity.
     * @param {string} color - The feature stroke color (e.g., '#FFFFFF' for Isobar, '#88E0FF' for Wind).
     */
    function createVectorLayerStyles(opacity, color) {
      const style = { stroke: true, weight: 2, opacity: opacity, fill: false, color: color };
      return {
        'default': style,
        'features': style // Assuming a generic 'features' layer name
      };
    }
    // Debounced function that actually calls the heavy updateMapLayers

    function getCurrentSliderTimestamp() {
      const historySlider = document.getElementById('history-slider');
      if (!historySlider) return Date.now();

      const rawValue = historySlider.value;
      const sliderMax = parseInt(historySlider.getAttribute('max') || 100, 10);
      const sliderValue = parseFloat(rawValue);

      const maxHistoryHours = 6;
      const maxHistoryMs = maxHistoryHours * 60 * 60 * 1000;
      const normalizedValue = (sliderMax - sliderValue) / sliderMax;
      return Date.now() - normalizedValue * maxHistoryMs;
    }


    function handleTimeSliderChange(event) {
      const historySlider = event.target;
      const timestamp = getCurrentSliderTimestamp();

      const timeDisplay = document.getElementById('history-time');
      if (timeDisplay) {
        timeDisplay.innerText = new Date(timestamp).toLocaleString('en-GB', {
          timeZone: 'Europe/London',
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }) + ' BST';
      }

      triggerMapUpdate(timestamp);
    }

    function radarLayerTypeHandler() {
      const select = document.getElementById('radarLayer');
      if (select?.disabled) {
        clearRadarLayers();
        return;
      }

      const newType = select.value;
      clearRadarLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, radarOptions, timestamp, 'radar');
    }

    function satelliteLayerTypeHandler() {
      const select = document.getElementById('satelliteLayerSelect');
      if (select?.disabled) {
        clearSatelliteLayers();
        return;
      }

      const newType = select.value;
      clearSatelliteLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, satelliteOptions, timestamp, 'satellite');
    }

    function isobarLayerTypeHandler() {
      const select = document.getElementById('isobarLayerSelect');
      if (select?.disabled) {
        clearIsobarLayers();
        return;
      }

      const newType = select.value;
      clearIsobarLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, isobarOptions, timestamp, 'isobar');
    }

    function windLayerTypeHandler() {
      const select = document.getElementById('windLayerSelect');
      if (select?.disabled) {
        clearWindLayers();
        return;
      }

      const newType = select.value;
      clearWindLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, windOptions, timestamp, 'wind');
    }

    function tropicalStormsLayerTypeHandler() {
      const select = document.getElementById('tropicalStormsLayerSelect');
      if (select?.disabled) {
        clearTropicalStormsLayers();
        return;
      }

      const newType = select.value;
      clearTropicalStormsLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, tropicalStormsOptions, timestamp, 'tropicalStorms');
    }

    function rotationLayerTypeHandler() {
      const select = document.getElementById('rotationLayerSelect');
      if (select?.disabled) {
        clearRotationLayers();
        return;
      }

      const newType = select.value;
      clearRotationLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, rotationOptions, timestamp, 'rotation');
    }

    function surfaceFrontLayerTypeHandler() {
      const select = document.getElementById('surfaceFrontLayerSelect');
      if (select?.disabled) {
        clearSurfaceFrontLayers();
        return;
      }

      const newType = select.value;
      clearSurfaceFrontLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, surfaceFrontOptions, timestamp, 'surfaceFront');
    }

    function lightningLayerTypeHandler() {
      const select = document.getElementById('lightningLayerSelect');
      if (select?.disabled) {
        clearLightningLayers();
        return;
      }

      const newType = select.value;
      clearLightningLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, lightningOptions, timestamp, 'lightning');
    }

    function observationLayerTypeHandler() {
      const select = document.getElementById('observationLayerSelect');
      if (select?.disabled) {
        clearObservationLayers();
        return;
      }

      const newType = select.value;
      clearObservationLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, observationOptions, timestamp, 'observation');
    }

    function warningLayerTypeHandler() {
      const select = document.getElementById('warningLayerSelect');
      if (select?.disabled) {
        clearWarningLayers();
        return;
      }

      const newType = select.value;
      clearWarningLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, warningOptions, timestamp, 'warning');
    }

    function nowcastLayerTypeHandler() {
      const select = document.getElementById('nowcastLayerSelect');
      if (select?.disabled) {
        clearNowcastLayers();
        return;
      }

      const newType = select.value;
      clearNowcastLayers();
      const timestamp = getCurrentSliderTimestamp();
      plotLayerIfNecessary(newType, nowcastOptions, timestamp, 'nowcast');
    }
    // --- INITIALIZATION AND EVENT ATTACHMENT ---
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.layer-control').forEach(control => {
        const checkbox = control.querySelector('.toggle-switch input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
          control.classList.add('off');
        }
      });
      // Initialize glow for all switch controls
      document.querySelectorAll('.switch-control').forEach(control => {
        const checkbox = control.querySelector('input[type="checkbox"]');
        if (checkbox) {
          const classes = [...control.classList];
          const uniqueClass = classes.find(cls => cls !== 'switch-control' && cls !== 'glow-on' && cls !== 'glow-off');
          if (uniqueClass) {
            updateSwitchGlow(checkbox, uniqueClass);
          }
        }
      });
      // Initialize dimming for Heatmap and Counter controls based on current checkbox state
      document.querySelectorAll('.heatmap-control, .counter-control').forEach(control => {
        const checkbox = control.querySelector('input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
          control.classList.add('off');
        }
      });
      document.querySelectorAll('.lightning-layer-control, .color-mode-control').forEach(control => {
        const checkbox = control.querySelector('input[type="checkbox"]');
        if (checkbox) {
          updateSwitchGlow(checkbox, control.classList[1]); // Use the second class as identifier
        }
      });
      const timeSlider = document.getElementById('history-slider');

      // Opacity sliders
      const radarOpacitySlider = document.getElementById('radarOpacity');
      const satelliteOpacitySlider = document.getElementById('satelliteOpacity');
      const isobarOpacitySlider = document.getElementById('isobarOpacity');
      const windOpacitySlider = document.getElementById('windOpacity');
      const lightningOpacitySlider = document.getElementById('lightningOpacity');
      const tropicalStormsOpacitySlider = document.getElementById('tropicalStormsOpacity');
      const rotationOpacitySlider = document.getElementById('rotationOpacity');
      const surfaceFrontOpacitySlider = document.getElementById('surfaceFrontOpacity');
      const observationOpacitySlider = document.getElementById('observationOpacity');
      const nowcastOpacitySlider = document.getElementById('nowcastOpacity');
      const warningOpacitySlider = document.getElementById('warningOpacity');

      // Layer select elements
      const radarSelect = document.getElementById('radarLayer');
      const satelliteSelect = document.getElementById('satelliteLayerSelect');
      const isobarSelect = document.getElementById('isobarLayerSelect');
      const windSelect = document.getElementById('windLayerSelect');
      const lightningSelect = document.getElementById('lightningLayerSelect');
      const tropicalStormsSelect = document.getElementById('tropicalStormsLayerSelect');
      const rotationSelect = document.getElementById('rotationLayerSelect');
      const surfaceFrontSelect = document.getElementById('surfaceFrontLayerSelect');
      const observationSelect = document.getElementById('observationLayerSelect');
      const nowcastSelect = document.getElementById('nowcastLayerSelect');
      const warningSelect = document.getElementById('warningLayerSelect');

      // Attach change handlers for layer dropdowns
      if (radarSelect) radarSelect.addEventListener('change', radarLayerTypeHandler);
      if (satelliteSelect) satelliteSelect.addEventListener('change', satelliteLayerTypeHandler);
      if (isobarSelect) isobarSelect.addEventListener('change', isobarLayerTypeHandler);
      if (windSelect) windSelect.addEventListener('change', windLayerTypeHandler);
      if (lightningSelect) lightningSelect.addEventListener('change', lightningLayerTypeHandler);
      if (tropicalStormsSelect) tropicalStormsSelect.addEventListener('change', tropicalStormsLayerTypeHandler);
      if (rotationSelect) rotationSelect.addEventListener('change', rotationLayerTypeHandler);
      if (surfaceFrontSelect) surfaceFrontSelect.addEventListener('change', surfaceFrontLayerTypeHandler);
      if (observationSelect) observationSelect.addEventListener('change', observationLayerTypeHandler);
      if (nowcastSelect) nowcastSelect.addEventListener('change', nowcastLayerTypeHandler);
      if (warningSelect) warningSelect.addEventListener('change', warningLayerTypeHandler);

      // Attach opacity sliders
      if (radarOpacitySlider) radarOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (satelliteOpacitySlider) satelliteOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (isobarOpacitySlider) isobarOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (windOpacitySlider) windOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (lightningOpacitySlider) lightningOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (tropicalStormsOpacitySlider) tropicalStormsOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (rotationOpacitySlider) rotationOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (surfaceFrontOpacitySlider) surfaceFrontOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (observationOpacitySlider) observationOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (nowcastOpacitySlider) nowcastOpacitySlider.addEventListener('input', updateLayerOpacities);
      if (warningOpacitySlider) warningOpacitySlider.addEventListener('input', updateLayerOpacities);

      // Time slider
      if (timeSlider) {
        timeSlider.addEventListener('input', handleTimeSliderChange);
      }

      // === CRITICAL: Force initial plot of all currently enabled layers ===
      updateLegend(); // Update opacity labels first

      const initialTimestamp = timeSlider ? getCurrentSliderTimestamp() : Date.now();

      // Force immediate execution (bypasses debounce delay)
      triggerMapUpdate(initialTimestamp, true);

      // Update the time display to match the initial timestamp
      const timeDisplay = document.getElementById('history-time');
      if (timeDisplay) {
        timeDisplay.innerText = new Date(initialTimestamp).toLocaleString('en-GB', {
          timeZone: 'Europe/London',
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }) + ' BST';
      }


      if (radarSelect && radarSelect.value === '') radarSelect.value = 'uk-precip-intensity';
      if (satelliteSelect && satelliteSelect.value === '') satelliteSelect.value = 'global-ir';
      if (isobarSelect && isobarSelect.value === '') isobarSelect.value = 'pressure_two';
      if (windSelect && windSelect.value === '') windSelect.value = 'wind-direction';
      if (surfaceFrontSelect && surfaceFrontSelect.value === '') surfaceFrontSelect.value = 'fcst-surface-fronts-isolines';
      if (nowcastSelect && nowcastSelect.value === '') nowcastSelect.value = 'sevwx-global-storm-corridors-plot';

      // Trigger handlers to apply defaults immediately
      radarLayerTypeHandler();
      satelliteLayerTypeHandler();
      isobarLayerTypeHandler();
      windLayerTypeHandler();
      surfaceFrontLayerTypeHandler();
      nowcastLayerTypeHandler();

    });



















    // Function to move legend between 2D and 3D map containers
    function updateLegendContainer() {
      const legendElement = document.querySelector('.legend');
      if (!legendElement) return;

      if (is3DMode) {
        // Move legend to 3D map container
        const map3DContainer = document.getElementById('map-3d');
        map3DContainer.appendChild(legendElement);
        legendElement.style.position = 'absolute';
        legendElement.style.top = '10px';
        legendElement.style.right = '10px';
        legendElement.style.zIndex = '1010';
      } else {
        // Move legend back to 2D map container
        const mapContainer = document.getElementById('map');
        mapContainer.appendChild(legendElement);
        legendElement.style.position = 'absolute';
        legendElement.style.top = '10px';
        legendElement.style.right = '10px';
        legendElement.style.zIndex = '1010';
      }

      // Ensure legend visibility matches toggle state
      legendElement.style.display = isLegendVisible ? 'block' : 'none';
    }

    // Update toggleLegend to sync visibility
    function toggleLegend() {
      isLegendVisible = !isLegendVisible;
      const legendElement = document.querySelector('.legend');
      if (legendElement) {
        legendElement.style.display = isLegendVisible ? 'block' : 'none';
      }
      updateLegendContainer(); // Ensure correct container
    }

    // Modify toggle3DMode to update legend container
    function toggle3DMode() {
      is3DMode = !is3DMode;
      document.body.classList.toggle('three-d-mode', is3DMode);
      if (is3DMode) {
        document.getElementById('map').style.opacity = '0';
        document.getElementById('map').style.pointerEvents = 'none';
        document.getElementById('map-3d').style.display = 'block';
        document.getElementById('map-3d').style.opacity = '1';
        map3D.resize();
        update3DView();
      } else {
        document.getElementById('map').style.opacity = '1';
        document.getElementById('map').style.pointerEvents = 'auto';
        document.getElementById('map-3d').style.display = 'none';
        document.getElementById('map-3d').style.opacity = '0';
        map.invalidateSize();
      }
      updateLegendContainer(); // Move legend to correct container
      updateZIndex();
      updateLegend();
    }
    function initializeRectangleExport() {
      // Add Export Rectangle Strikes button
      const exportButton = document.createElement('button');
      exportButton.textContent = 'Export Rectangle Strikes';
      exportButton.onclick = showRectangleExportModal;
      const expertControls = document.getElementById('expert-controls');
      if (expertControls && !expertControls.querySelector('button[onclick="showRectangleExportModal()"]')) {
        expertControls.appendChild(exportButton);
      }

      // Rectangle drawing for 2D mode
      map.on(L.Draw.Event.CREATED, function (e) {
        if (e.layerType === 'rectangle') {
          const layer = e.layer;
          const bounds = layer.getBounds();
          const coords = [
            [bounds.getSouthWest().lat, bounds.getSouthWest().lng],
            [bounds.getSouthEast().lat, bounds.getSouthEast().lng],
            [bounds.getNorthEast().lat, bounds.getNorthEast().lng],
            [bounds.getNorthWest().lat, bounds.getNorthWest().lng]
          ];
          lastDrawnRectangle = layer; // Store the rectangle layer
          drawnItems.addLayer(layer);
          console.log('Rectangle Coords:', coords);
          console.log('lastDrawnRectangle set:', lastDrawnRectangle);
          showTimeFilterModalForExport(coords);
        }
      });

      // Handle rectangle deletion
      map.on(L.Draw.Event.DELETED, function (e) {
        if (lastDrawnRectangle && !drawnItems.hasLayer(lastDrawnRectangle)) {
          console.log('lastDrawnRectangle cleared due to deletion');
          lastDrawnRectangle = null;
        }
      });

      // Initialize drawControl
      drawControl = new L.Control.Draw({
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            drawError: { color: '#b00b00', timeout: 1000 },
            shapeOptions: { color: risk_colors['Low risk'], weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          rectangle: {
            shapeOptions: { color: '#3b82f6', weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          polyline: false,
          circle: false,
          marker: false,
          circlemarker: false
        },
        edit: {
          featureGroup: drawnItems,
          remove: true
        }
      });
      map.addControl(drawControl);
    }

    function showRectangleExportModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
    <h3>Export Lightning Strikes</h3>
    <p>Choose how to define the rectangle area:</p>
    <button onclick="drawRectangleOnMap()">Draw on Map</button>
    <p>Or enter bounding coordinates:</p>
    <label>North (lat): <input type="text" id="north-coord" placeholder="e.g., 53.0"></label>
    <label>South (lat): <input type="text" id="south-coord" placeholder="e.g., 51.0"></label>
    <label>East (lng): <input type="text" id="east-coord" placeholder="e.g., 1.0"></label>
    <label>West (lng): <input type="text" id="west-coord" placeholder="e.g., -1.0"></label>
    <button onclick="validateCoordinates()">Next</button>
    <button onclick="closeModal()">Cancel</button>
  `;
      document.body.appendChild(modal);
      document.getElementById('overlay').style.display = 'block';
    }

    function drawRectangleOnMap() {
      closeModal();
      // Clear any existing rectangles
      if (lastDrawnRectangle) {
        drawnItems.removeLayer(lastDrawnRectangle);
        lastDrawnRectangle = null;
        console.log('Cleared existing rectangle');
      }
      if (drawControl && drawControl._toolbars.draw._modes.rectangle) {
        drawControl._toolbars.draw._modes.rectangle.handler.enable();
      } else {
        alert('Drawing is not available. Please ensure Expert Mode is enabled.');
      }
    }

    function validateCoordinates() {
      const north = parseFloat(document.getElementById('north-coord').value);
      const south = parseFloat(document.getElementById('south-coord').value);
      const east = parseFloat(document.getElementById('east-coord').value);
      const west = parseFloat(document.getElementById('west-coord').value);

      if (isNaN(north) || isNaN(south) || isNaN(east) || isNaN(west)) {
        alert('Please enter valid numeric coordinates.');
        return;
      }

      if (north <= south || east <= west) {
        alert('North must be greater than South, and East must be greater than West.');
        return;
      }

      const coords = [
        [south, west], // SW
        [south, east], // SE
        [north, east], // NE
        [north, west]  // NW
      ];
      console.log('Coordinate Input Coords:', coords);
      closeModal();
      showTimeFilterModalForExport(coords);
    }

    function showTimeFilterModalForExport(coords) {
      document.querySelectorAll('.modal').forEach(modal => modal.remove());

      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
    <h3>Time Filter & Color Options</h3>
    <label>Start Time: <input type="datetime-local" id="export-start-time"></label>
    <label>End Time: <input type="datetime-local" id="export-end-time"></label>
    <label>Color by Age: <input type="checkbox" id="export-color-mode" checked="checked"></label>
    <button id="export-png-button">Export PNG</button>
    <button onclick="closeModal()">Cancel</button>
  `;
      document.body.appendChild(modal);
      document.getElementById('overlay').style.display = 'block';

      const exportButton = document.getElementById('export-png-button');
      if (exportButton) {
        console.log('Export PNG button found, attaching listener');
        exportButton.addEventListener('click', () => {
          console.log('Export PNG button clicked, coords:', coords);
          const startInput = document.getElementById('export-start-time');
          const endInput = document.getElementById('export-end-time');
          console.log('Start Input Element:', startInput);
          console.log('End Input Element:', endInput);
          console.log('Start Time Value:', startInput?.value);
          console.log('End Time Value:', endInput?.value);
          exportStrikesToPNG(coords);
        });
      } else {
        console.error('Export PNG button not found');
        alert('Error: Export button not found. Please try again.');
      }

      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      if (startInput) {
        startInput.addEventListener('change', (e) => {
          console.log('Start Time Changed:', e.target.value);
        });
      }
      if (endInput) {
        endInput.addEventListener('change', (e) => {
          console.log('End Time Changed:', e.target.value);
        });
      }
    }

    function exportStrikesToPNG(coords) {
      console.log('exportStrikesToPNG called with coords:', coords);

      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      const startTimeInput = startInput?.value;
      const endTimeInput = endInput?.value;
      const colorMode = document.getElementById('export-color-mode')?.checked;

      console.log('Start Time Input:', startTimeInput);
      console.log('End Time Input:', endTimeInput);
      console.log('Color Mode:', colorMode);

      if (!startTimeInput || !endTimeInput) {
        console.error('Time inputs are empty:', startTimeInput, endTimeInput);
        alert('Please select both start and end times.');
        closeModal();
        return;
      }

      const startTime = new Date(startTimeInput);
      const endTime = new Date(endTimeInput);

      if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
        console.error('Invalid time inputs:', startTimeInput, endTimeInput);
        alert('Please select valid start and end times.');
        closeModal();
        return;
      }

      if (endTime <= startTime) {
        console.error('End time is not after start time:', startTime, endTime);
        alert('End time must be after start time.');
        closeModal();
        return;
      }

      if (!coords || !Array.isArray(coords) || coords.length !== 4 || coords.some(coord => !Array.isArray(coord) || coord.length !== 2)) {
        console.error('Invalid coords format:', coords);
        alert('Error: Invalid rectangle coordinates. Please try again.');
        closeModal();
        return;
      }

      let bounds;
      try {
        bounds = L.latLngBounds(coords);
      } catch (error) {
        console.error('Failed to create bounds:', error, coords);
        alert('Error: Invalid rectangle bounds. Please try again.');
        closeModal();
        return;
      }

      // Calculate pixel dimensions of the selected area
      let width, height;
      if (lastDrawnRectangle) {
        // For drawn rectangle, use pixel coordinates directly
        const rectangleBounds = lastDrawnRectangle.getBounds();
        const topLeft = map.latLngToContainerPoint(rectangleBounds.getNorthWest());
        const bottomRight = map.latLngToContainerPoint(rectangleBounds.getSouthEast());
        width = Math.abs(bottomRight.x - topLeft.x);
        height = Math.abs(bottomRight.y - topLeft.y);
      } else {
        // For manually entered coordinates, project bounds to pixel coordinates
        const topLeft = map.latLngToContainerPoint(bounds.getNorthWest());
        const bottomRight = map.latLngToContainerPoint(bounds.getSouthEast());
        width = Math.abs(bottomRight.x - topLeft.x);
        height = Math.abs(bottomRight.y - topLeft.y);
      }

      // Ensure dimensions are positive and reasonable
      if (width <= 0 || height <= 0 || width > 10000 || height > 10000) {
        console.error('Invalid canvas dimensions:', width, height);
        alert('Error: Invalid area dimensions. Please select a valid area.');
        closeModal();
        return;
      }

      // Round dimensions to integers for canvas
      width = Math.round(width);
      height = Math.round(height);
      console.log('Calculated pixel dimensions:', { width, height });

      // Create a canvas with the exact pixel dimensions
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Set background (transparent)
      ctx.fillStyle = 'rgba(255, 255, 255, 0)';
      ctx.fillRect(0, 0, width, height);

      // Filter strikes within the time range and bounds
      const filteredStrikes = strikeData.filter(s => {
        const strikeTime = new Date(s.time);
        const withinTime = strikeTime >= startTime && strikeTime <= endTime;
        const withinBounds = bounds.contains([s.coordinates[1], s.coordinates[0]]);
        return withinTime && withinBounds;
      });

      console.log('Filtered strikes:', filteredStrikes.length);

      // Map geographic coordinates to canvas coordinates
      filteredStrikes.forEach(s => {
        const lat = s.coordinates[1];
        const lng = s.coordinates[0];

        // Convert lat/lng to pixel coordinates relative to the bounds
        const point = map.latLngToContainerPoint([lat, lng]);
        const topLeft = map.latLngToContainerPoint(bounds.getNorthWest());

        // Translate to canvas coordinates (origin at top-left of canvas)
        const x = point.x - topLeft.x;
        const y = point.y - topLeft.y;

        // Calculate color based on age if enabled
        let color = 'black';
        if (colorMode) {
          const ageFraction = (endTime - new Date(s.time)) / ((endTime - startTime) || 1);
          color = getColorFromAge(ageFraction);
        }

        // Draw strike as a circle
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI); // 5-pixel radius
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Convert canvas to PNG and trigger download
      const dataUrl = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = `lightning_strikes_${startTime.toISOString()}_${endTime.toISOString()}.png`;
      link.click();

      console.log('PNG exported with dimensions:', width, 'x', height);

      // Remove the drawn rectangle if it exists
      if (lastDrawnRectangle) {
        drawnItems.removeLayer(lastDrawnRectangle);
        console.log('Removed lastDrawnRectangle from map');
        lastDrawnRectangle = null;
      }

      closeModal();
    }
    function closeModal() {
      document.querySelectorAll('.modal').forEach(modal => modal.remove());
      document.getElementById('overlay').style.display = 'none';
      if (drawControl && drawControl._toolbars.draw._modes.rectangle.handler) {
        drawControl._toolbars.draw._modes.rectangle.handler.disable();
      }
    }

    // Initialize rectangle export functionality
    initializeRectangleExport();
    // Initialize Leaflet.draw for 2D mode
    function initializeDrawControl() {
      // Initialize drawnItems if not already defined
      if (!drawnItems) {
        drawnItems = L.featureGroup().addTo(map);
      }

      // Remove existing drawControl if it exists to prevent conflicts
      if (drawControl) {
        map.removeControl(drawControl);
      }

      drawControl = new L.Control.Draw({
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            drawError: { color: '#b00b00', timeout: 1000 },
            shapeOptions: { color: risk_colors['Low risk'], weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          rectangle: {
            shapeOptions: { color: '#3b82f6', weight: 2, opacity: 0.8, fillOpacity: 0.3 }
          },
          polyline: false,
          circle: false,
          marker: false,
          circlemarker: false
        },
        edit: {
          featureGroup: drawnItems,
          remove: true
        }
      });
      map.addControl(drawControl);

      map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        if (e.layerType === 'polygon') {
          const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
          layer.feature = { type: 'Feature', properties: { name: riskLevel, source: 'leaflet' } };
          layer.setStyle({
            color: risk_colors[riskLevel],
            fillColor: risk_colors[riskLevel] === risk_colors['Severe risk'] ? 'transparent' : risk_colors[riskLevel],
            fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
            weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
          });
          layer._leaflet_id = layer._leaflet_id || `leaflet-${Date.now()}`;
          drawnItems.addLayer(layer);
          addPolygonPopup(layer);
          if (is3DMode) syncPolygonsTo3D();
          updateLegend();
          console.log('Created 2D polygon:', layer._leaflet_id, layer.toGeoJSON());
        } else if (e.layerType === 'rectangle') {
          const bounds = layer.getBounds();
          const coords = [
            [bounds.getSouthWest().lat, bounds.getSouthWest().lng],
            [bounds.getSouthEast().lat, bounds.getSouthEast().lng],
            [bounds.getNorthEast().lat, bounds.getNorthEast().lng],
            [bounds.getNorthWest().lat, bounds.getNorthWest().lng]
          ];
          drawnItems.addLayer(layer);
          showTimeFilterModalForExport(coords);
        }
      });

      map.on(L.Draw.Event.EDITED, function (e) {
        e.layers.eachLayer(layer => {
          if (layer && is3DMode) syncPolygonsTo3D();
          updatePolygonPopup(layer);
        });
        updateLegend();
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
        editingLayerId = null;
      });

      map.on(L.Draw.Event.DELETED, function (e) {
        if (is3DMode) syncPolygonsTo3D();
        updateLegend();
        editingLayerId = null;
      });

      // Add Export Rectangle Strikes button to expert-controls
      const exportButton = document.createElement('button');
      exportButton.textContent = 'Export Rectangle Strikes';
      exportButton.onclick = showRectangleExportModal;
      const expertControls = document.getElementById('expert-controls');
      if (expertControls && !expertControls.querySelector('button[onclick="showRectangleExportModal()"]')) {
        expertControls.appendChild(exportButton);
      }
    }

    function initializeDrawControl3D() {
      // No drawing in 3D mode
    }
    // Initialize Mapbox GL Draw for 3D mode
    function initializeDrawControl3D2() {
      drawControl3D = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
          polygon: true,
          trash: true
        },
        styles: [
          {
            id: 'gl-draw-polygon-fill-inactive',
            type: 'fill',
            paint: {
              'fill-color': '#5aac91',
              'fill-opacity': 0.3
            }
          },
          {
            id: 'gl-draw-polygon-stroke-inactive',
            type: 'line',
            paint: {
              'line-color': '#5aac91',
              'line-width': 2,

            }
          },
          {
            id: 'gl-draw-polygon-fill-active',
            type: 'fill',
            paint: {
              'fill-color': '#5aac91',
              'fill-opacity': 0.5
            }
          },
          {
            id: 'gl-draw-polygon-stroke-active',
            type: 'line',
            paint: {
              'line-color': '#5aac91',
              'line-width': 3
            }
          },
          {
            id: 'gl-draw-vertex-inactive',
            type: 'circle',
            paint: {
              'circle-radius': 5,
              'circle-color': '#fff',
              'circle-stroke-color': '#5aac91',
              'circle-stroke-width': 2,
              'circle-opacity': 0, // Set to 0 to hide inactive vertices
              'circle-stroke-opacity': 0
            }
          },
          {
            id: 'gl-draw-vertex-active',
            type: 'circle',
            paint: {
              'circle-radius': 7,
              'circle-color': '#5aac91'
            }
          }
        ]
      });
      map3D.addControl(drawControl3D, 'top-right');

      map3D.on('draw.create', function (e) {
        const geojson = e.features[0];
        const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
        geojson.properties = { name: riskLevel, source: 'mapbox' };
        const isSevere = riskLevel === 'Severe risk';
        const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
        map3D.addSource(layerId, { type: 'geojson', data: geojson });
        map3D.addLayer({
          id: layerId,
          type: 'fill',
          source: layerId,
          paint: {
            'fill-color': risk_colors[riskLevel],
            'fill-opacity': isSevere ? 0 : parseFloat(document.getElementById('polygon-opacity')?.value || 0.3)
          }
        });
        map3D.addLayer({
          id: `${layerId}-outline`,
          type: 'line',
          source: layerId,
          paint: {
            'line-color': risk_colors[riskLevel],
            'line-width': parseFloat(document.getElementById('polygon-weight')?.value || 2),
            'line-opacity': 1
          }
        });
        drawnItems3D.push({
          id: layerId,
          outlineId: `${layerId}-outline`,
          source: layerId
        });
        const leafletLayer = L.geoJSON(geojson, {
          style: {
            color: risk_colors[riskLevel],
            fillColor: isSevere ? 'transparent' : risk_colors[riskLevel],
            fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
            weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
          }
        });
        leafletLayer.feature = geojson;
        leafletLayer._leaflet_id = layerId;
        drawnItems.addLayer(leafletLayer);
        addPolygonPopup(leafletLayer);
        updateLegend();
        console.log('Created 3D polygon:', layerId, geojson);
      });

      map3D.on('draw.update', function (e) {
        const geojson = e.features[0];
        const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
        const leafletLayer = drawnItems.getLayer(layerId);
        if (leafletLayer) {
          leafletLayer.clearLayers();
          leafletLayer.addData(geojson);
          updatePolygonPopup(leafletLayer);
          if (is3DMode) syncPolygonsTo3D();
          updateLegend();
          console.log('Updated 3D polygon:', layerId, geojson);
        }
      });

      map3D.on('draw.delete', function (e) {
        e.features.forEach(feature => {
          const layerId = `drawn-polygon-${feature.id || Date.now()}`;
          const leafletLayer = drawnItems.getLayer(layerId);
          if (leafletLayer) {
            drawnItems.removeLayer(leafletLayer);
          }
          const item = drawnItems3D.find(d => d.id === layerId);
          if (item) {
            if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
            if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
            if (map3D.getSource(item.source)) map3D.removeSource(item.source);
            drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
          }
        });
        updateLegend();
        editingLayerId = null;
        console.log('Deleted 3D polygon(s)');
      });

      // Handle clicks on 3D map polygons to open Leaflet popups
      map3D.on('click', function (e) {
        if (isDrawingEnabled && drawControl3D.getMode() === 'draw_polygon') return; // Ignore clicks during active drawing
        const features = map3D.queryRenderedFeatures(e.point, {
          layers: drawnItems3D.map(item => item.id)
        });
        if (features.length > 0) {
          const layerId = features[0].layer.id;
          const leafletLayer = drawnItems.getLayer(layerId);
          if (leafletLayer && leafletLayer.getPopup()) {
            console.log('Clicked 3D polygon:', layerId);
            // Temporarily enable 2D map for popup rendering
            map.getContainer().style.opacity = '0';
            map.getContainer().style.height = '100%';
            map.getContainer().style.overflow = 'visible';
            leafletLayer.openPopup([e.lngLat.lat, e.lngLat.lng]);
            // Revert 2D map after popup interaction
            setTimeout(() => {
              map.getContainer().style.opacity = '0';
              map.getContainer().style.height = '0';
              map.getContainer().style.overflow = 'hidden';
            }, 100);
          } else {
            console.warn('No Leaflet layer or popup found for:', layerId);
          }
          // Prevent accidental edit mode activation
          if (drawControl3D.getMode() !== 'draw_polygon') {
            drawControl3D.changeMode('simple_select');
          }
        }
      });

    }

    // Toggle 3D mode
    function toggle3DMode() {
      is3DMode = !is3DMode;
      const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
      if (button) {
        button.textContent = is3DMode ? 'Switch to 2D' : 'Switch to 3D';
      }
      document.body.classList.toggle('three-d-mode', is3DMode);
      if (is3DMode) {
        map3D.resize();
        syncPolygonsTo3D();
        if (isDrawingEnabled) {
          isDrawingEnabled = false;
          const drawButton = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
          if (drawButton) {
            drawButton.textContent = 'Enable Drawing';
          }
          console.log('Drawing disabled when switching to 3D mode');
        }
      } else {
        map.getContainer().style.display = 'block';
        map.getContainer().style.opacity = '1';
        map.getContainer().style.height = 'auto';
        map.getContainer().style.overflow = 'visible';
        clear3DPolygons();
        map3D.getContainer().style.opacity = '0';
      }
      updateLegend();
      console.log('Toggled to', is3DMode ? '3D' : '2D', 'mode, synced polygons');
    }

    // Toggle drawing mode
    function toggleDrawing() {
      if (is3DMode) {
        // Show modal prompting to switch to 2D mode
        document.getElementById('3d-draw-modal').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        return;
      }

      isDrawingEnabled = !isDrawingEnabled;
      const button = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
      if (button) {
        button.textContent = isDrawingEnabled ? 'Disable Drawing' : 'Enable Drawing';
      }
      if (isDrawingEnabled) {
        drawControl._toolbars.draw._modes.polygon.handler.enable();
      } else {
        drawControl._toolbars.draw._modes.polygon.handler.disable();
        // Disable any active edit mode to prevent vertex interaction
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
        editingLayerId = null;
      }
      console.log('Drawing', isDrawingEnabled ? 'enabled' : 'disabled', 'in 2D mode');
    }
    function switchTo2DForDrawing() {
      is3DMode = false;
      document.body.classList.remove('three-d-mode');
      map.getContainer().style.display = 'block';
      map.getContainer().style.opacity = '1';
      map.getContainer().style.height = 'auto';
      map.getContainer().style.overflow = 'visible';
      map3D.getContainer().style.opacity = '0';
      clear3DPolygons();
      const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
      if (button) {
        button.textContent = 'Switch to 3D';
      }
      close3DDrawModal();
      toggleDrawing(); // Enable drawing after switching to 2D
      console.log('Switched to 2D mode for drawing');
    }

    function close3DDrawModal() {
      document.getElementById('3d-draw-modal').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }
    // Sync 2D polygons to 3D
    function syncPolygonsTo3D() {
      clear3DPolygons();
      console.log('Syncing polygons to 3D, drawnItems layers:', drawnItems.getLayers().length);
      drawnItems.eachLayer(layer => {
        if (!layer || !document.getElementById('drawn-polygons-toggle')?.checked) {
          console.log('Skipping layer:', layer?._leaflet_id, 'toggle:', document.getElementById('drawn-polygons-toggle')?.checked);
          return;
        }
        const geojson = layer.toGeoJSON();
        geojson.properties = {
          name: layer.feature?.properties?.name || 'Low risk',
          source: layer.feature?.properties?.source || 'leaflet'
        };
        const isSevere = geojson.properties.name === 'Severe risk';
        const layerId = layer._leaflet_id || `drawn-polygon-${Date.now()}`;
        if (!layer._leaflet_id) {
          layer._leaflet_id = layerId;
        }
        console.log('Syncing layer:', layerId, 'GeoJSON:', geojson);
        try {
          map3D.addSource(layerId, { type: 'geojson', data: geojson });
          map3D.addLayer({
            id: layerId,
            type: 'fill',
            source: layerId,
            paint: {
              'fill-color': layer.options.color || '#5aac91',
              'fill-opacity': isSevere ? 0 : (layer.options.fillOpacity || 0.3)
            }
          });
          map3D.addLayer({
            id: `${layerId}-outline`,
            type: 'line',
            source: layerId,
            paint: {
              'line-color': layer.options.color || '#5aac91',
              'line-width': layer.options.weight || 2,
              'line-opacity': 1
            }
          });
          drawnItems3D.push({
            id: layerId,
            outlineId: `${layerId}-outline`,
            source: layerId
          });
        } catch (error) {
          console.error('Error syncing layer:', layerId, error);
        }
      });
      map3D.resize();
      console.log('Synced', drawnItems3D.length, 'polygons to 3D');
    }

    // Clear 3D polygons
    function clear3DPolygons() {
      console.log('Clearing 3D polygons:', drawnItems3D.length);
      drawnItems3D.forEach(item => {
        if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
        if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
        if (map3D.getSource(item.source)) map3D.removeSource(item.source);
      });
      drawnItems3D = [];
    }

    // Add or update popup for polygon customization
    function addPolygonPopup(layer) {
      if (!layer || !layer._leaflet_id) {
        console.error('Invalid layer or missing _leaflet_id:', layer);
        return;
      }
      const popupContent = document.createElement('div');
      popupContent.className = 'polygon-popup';
      const riskLevel = layer.feature?.properties?.name || 'Low risk';
      const isEditing = editingLayerId === layer._leaflet_id;
      popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
      const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
      const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
      const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
      const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

      if (riskSelect) {
        riskSelect.replaceWith(riskSelect.cloneNode(true));
        const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
        newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
      }
      if (colorInput) {
        colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
      }
      if (editButton) {
        editButton.onclick = () => {
          if (editingLayerId === layer._leaflet_id) {
            cancelPolygonEdit(layer._leaflet_id);
          } else {
            startEditPolygon(layer._leaflet_id);
          }
        };
      }
      if (applyButton) {
        applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
      }
      if (deleteButton) {
        deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
      }

      layer.bindPopup(popupContent);
      console.log('Added popup for layer:', layer._leaflet_id);
    }

    // Update existing popup content without rebinding
    function updatePolygonPopup(layer) {
      if (!layer || !layer._leaflet_id || !layer.getPopup()) {
        console.error('Cannot update popup for layer:', layer);
        return;
      }
      const popupContent = layer.getPopup().getContent();
      const riskLevel = layer.feature?.properties?.name || 'Low risk';
      const isEditing = editingLayerId === layer._leaflet_id;
      popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
      const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
      const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
      const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
      const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

      if (riskSelect) {
        riskSelect.replaceWith(riskSelect.cloneNode(true));
        const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
        newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
      }
      if (colorInput) {
        colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
      }
      if (editButton) {
        editButton.onclick = () => {
          if (editingLayerId === layer._leaflet_id) {
            cancelPolygonEdit(layer._leaflet_id);
          } else {
            startEditPolygon(layer._leaflet_id);
          }
        };
      }
      if (applyButton) {
        applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
      }
      if (deleteButton) {
        deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
      }
      console.log('Updated popup for layer:', layer._leaflet_id);
    }

    // Update polygon risk level
    function updatePolygonRisk(select, layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      const risk = select.value;
      layer.feature = layer.feature || { type: 'Feature', properties: {} };
      layer.feature.properties.name = risk;
      const isSevere = risk === 'Severe risk';
      layer.setStyle({
        color: risk_colors[risk],
        fillColor: isSevere ? 'transparent' : risk_colors[risk],
        fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
        weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      updatePolygonPopup(layer);
      console.log('Updated risk level for layer:', layerId, 'to', risk);
    }

    // Update polygon color
    function updatePolygonColor(input, layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      const color = input.value;
      layer.setStyle({
        color,
        fillColor: layer.feature?.properties?.name === 'Severe risk' ? 'transparent' : color
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      updatePolygonPopup(layer);
      console.log('Updated color for layer:', layerId, 'to', color);
    }

    // Start editing polygon shape
    function startEditPolygon(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('direct_select', { featureId: layerId.replace('drawn-polygon-', '') });
          editingLayerId = layerId;
          updatePolygonPopup(layer);
          layer.openPopup();
        } else {
          console.error('3D draw control not initialized');
        }
      } else {
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.enable();
          if (layer.editing) {
            layer.editing.enable();
          } else {
            console.warn('Layer editing not supported for this layer:', layer);
          }
          editingLayerId = layerId;
          updatePolygonPopup(layer);
          layer.openPopup();
        } else {
          console.error('Edit toolbar not initialized');
        }
      }
      console.log('Started editing layer:', layerId);
    }

    // Save edited polygon shape
    function savePolygonEdit(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('simple_select');
          const geojson = layer.toGeoJSON();
          const sourceId = layerId;
          if (map3D.getSource(sourceId)) {
            map3D.getSource(sourceId).setData(geojson);
          }
        }
      } else {
        if (layer.editing) {
          layer.editing.disable();
        }
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.save();
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      editingLayerId = null;
      updatePolygonPopup(layer);
      layer.openPopup();
      console.log('Saved edits for layer:', layerId);
    }

    // Cancel editing polygon shape
    function cancelPolygonEdit(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        if (drawControl3D) {
          drawControl3D.changeMode('simple_select');
        }
      } else {
        if (layer.editing) {
          layer.editing.disable();
        }
        if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
          drawControl._toolbars.edit._modes.edit.handler.revertLayers();
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      editingLayerId = null;
      updatePolygonPopup(layer);
      layer.openPopup();
      console.log('Canceled edits for layer:', layerId);
    }

    // Delete polygon
    function deletePolygon(layerId) {
      const layer = drawnItems.getLayer(layerId);
      if (!layer) {
        console.error(`Layer with ID ${layerId} not found`);
        return;
      }
      drawnItems.removeLayer(layer);
      if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
        const item = drawnItems3D.find(d => d.id === layerId);
        if (item) {
          if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
          if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
          if (map3D.getSource(item.source)) map3D.removeSource(item.source);
          drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
        }
      }
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      editingLayerId = null;
      console.log('Deleted layer:', layerId);
    }

    // Update all polygons' opacity
    function updateAllPolygonsOpacity() {
      const opacity = parseFloat(document.getElementById('polygon-opacity')?.value || 0.3);
      drawnItems.eachLayer(layer => {
        if (layer) {
          layer.setStyle({ fillOpacity: layer.feature?.properties?.name === 'Severe risk' ? 0 : opacity });
        }
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      console.log('Updated opacity for all polygons:', opacity);
    }

    // Update all polygons' outline weight
    function updateAllPolygonsWeight() {
      const weight = parseFloat(document.getElementById('polygon-weight')?.value || 2);
      drawnItems.eachLayer(layer => {
        if (layer) {
          layer.setStyle({ weight });
        }
      });
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      console.log('Updated weight for all polygons:', weight);
    }

    // Export drawn polygons to KML
    function exportToKML() {
      const kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>Drawn Polygons</name>`;
      let kmlBody = '';
      drawnItems.eachLayer(layer => {
        if (!layer || !layer.toGeoJSON || !layer.options?.color) return;
        const geojson = layer.toGeoJSON();
        const coordinates = geojson.geometry.coordinates[0]?.map(coord => `${coord[0]},${coord[1]},0`).join(' ') || '';
        const risk = layer.feature?.properties?.name || 'Low risk';
        kmlBody += `
        <Placemark>
          <name>${risk}</name>
          <Style>
            <LineStyle>
              <color>ff${layer.options.color.replace('#', '')}</color>
              <width>${layer.options.weight || 2}</width>
            </LineStyle>
            <PolyStyle>
              <color>${risk === 'Severe risk' ? '00' : '7f'}${layer.options.color.replace('#', '')}</color>
            </PolyStyle>
          </Style>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>${coordinates}</coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>`;
      });
      const kmlFooter = `
</Document>
</kml>`;
      const kmlContent = kmlHeader + kmlBody + kmlFooter;
      const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawn_polygons.kml';
      a.click();
      URL.revokeObjectURL(url);
      console.log('Exported polygons to KML');
    }







    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');

      const isDark = document.body.classList.contains('dark-mode');
      const mapStyleSelect = document.getElementById('map-style');

      if (isDark) {
        // Switch to a good dark base map
        mapStyleSelect.value = 'mapbox-streets-satellite'; // or 'mapbox-dark' or 'maptiler-dark'
        switchBaseMap('mapbox-streets-satellite');

        // Update button text
        event.target.textContent = '‚òÄÔ∏è Light Mode';
      } else {
        // Switch to a good light base map
        mapStyleSelect.value = 'mapbox-outdoors'; // or 'mapbox-light' or 'maptiler-light'
        switchBaseMap('mapbox-outdoors');

        // Update button text
        event.target.textContent = 'üåô Dark Mode';
      }
    }

    function toggleControls() {
      const controlPanel = document.getElementById('control-panel');
      controlPanel.classList.toggle('open');
    }
    function updateTerrainExaggeration() {
      if (is3DMode) {
        const exaggeration = parseFloat(document.getElementById('terrain-exaggeration-slider').value);
        map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        map3D.resize();
      }
    }
    function showUserLocation() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          // Remove existing marker if present
          if (userLocationMarker) {
            if (is3DMode) {
              userLocationMarker.remove();
            } else {
              map.removeLayer(userLocationMarker);
            }
            userLocationMarker = null;
          }
          // Add new marker
          if (is3DMode) {
            const el = document.createElement('div');
            el.className = 'user-location-marker';
            userLocationMarker = new mapboxgl.Marker(el)
              .setLngLat([longitude, latitude])
              .addTo(map3D);
            map3D.jumpTo({ center: [longitude, latitude], zoom: 10 });
            map3D.resize();
          } else {
            userLocationMarker = L.circleMarker([latitude, longitude], {
              radius: 6,
              color: '#3b82f6',
              fillColor: '#3b82f6',
              fillOpacity: 1,
              className: 'user-location-marker'
            }).addTo(map);
            map.setView([latitude, longitude], 10);
            map.invalidateSize();
          }
        },
        (error) => {
          alert('Unable to retrieve location: ' + error.message);
        }
      );
    }
    function toggleSound() {
      soundEnabled = document.getElementById('sound-toggle').checked;
    }

    function toggleLightningEffect() {
      lightningEffectEnabled = document.getElementById('lightning-effect-toggle').checked;
    }

    function playThunderSound() {
      if (!soundEnabled) return;
      const now = Date.now();
      if (now - lastSoundTime < SOUND_COOLDOWN) return;
      thunderAudio.currentTime = 0;
      thunderAudio.play().catch(error => console.error('Error playing sound:', error));
      lastSoundTime = now;
    }

    function addLightningFlash2D(lat, lng) {
      if (!lightningEffectEnabled || !map || !map.getPanes().overlayPane) return;

      // Ensure map size is valid
      map.invalidateSize();

      // Convert [latitude, longitude] to container coordinates
      const point = map.latLngToContainerPoint([lat, lng]);
      if (!point || isNaN(point.x) || isNaN(point.y)) {
        console.warn(`Invalid container point for lat=${lat}, lng=${lng}:`, point);
        return;
      }

      // Calculate base size based on zoom level to maintain consistent appearance
      const zoom = map.getZoom();
      const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

      const flash = document.createElement('div');
      flash.className = 'lightning-flash-2d';
      flash.style.width = `${baseSize}px`;
      flash.style.height = `${baseSize}px`;
      flash.style.left = `${point.x - baseSize / 2}px`; // Center the flash
      flash.style.top = `${point.y - baseSize / 2}px`; // Center the flash
      flash.style.zIndex = '1000';
      flash.style.transformOrigin = 'center'; // Ensure scaling is centered
      map.getPanes().overlayPane.appendChild(flash);
      setTimeout(() => flash.remove(), 2500);
    }

    function addLightningFlash3D(lng, lat) {
      if (!lightningEffectEnabled || !map3D) return;

      // Ensure map is resized
      map3D.resize();

      // Calculate size based on zoom level
      const zoom = map3D.getZoom();
      const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

      const el = document.createElement('div');
      el.className = 'lightning-flash-3d';
      el.style.width = `${baseSize}px`;
      el.style.height = `${baseSize}px`;
      el.style.transform = 'translate(-50%, -50%)'; // Center the flash
      el.style.transformOrigin = 'center'; // Ensure scaling is centered
      const marker = new mapboxgl.Marker({
        element: el,
        anchor: 'center'
      })
        .setLngLat([lng, lat])
        .addTo(map3D);
      setTimeout(() => marker.remove(), 2500);
    }

    function toggle3DMode() {
      is3DMode = document.getElementById('3d-mode-toggle').checked;
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');
      mapDiv.style.display = is3DMode ? 'none' : 'block';
      map3DDiv.style.display = is3DMode ? 'block' : 'none';
      document.getElementById('heatmap-3d-toggle').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('heatmap-frequency-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('heatmap-height-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
      document.getElementById('terrain-exaggeration-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';

      if (userLocationMarker) {
        if (is3DMode) {
          if (map.hasLayer(userLocationMarker)) map.removeLayer(userLocationMarker);
        } else {
          if (userLocationMarker.remove) userLocationMarker.remove();
        }
        userLocationMarker = null;
      }

      if (is3DMode) {
        map3D.jumpTo({ center: [-4.5, 53.5], zoom: 5 });
        map3D.resize();
        update3DView();
        toggleKMLLayer();
        togglePNGLayer();
        syncPolygonsTo3D();
        updateOverlay(currentFiltered);
        toggleNowcast();
        updateLegend();
        updateTerrainExaggeration();
      } else {
        map.invalidateSize();
        map.addLayer(drawnItems);
        clear3DPolygons();
        updateHistory();
        updateLegend();
      }
    }


    function update3DView() {
      // Clear existing layers
      strikeLayer3D.forEach(marker => marker.remove());
      strikeLayer3D = [];
      if (map3D.getLayer('heatmap-3d')) map3D.removeLayer('heatmap-3d');
      if (map3D.getSource('heatmap-3d')) map3D.removeSource('heatmap-3d');
      if (map3D.getLayer('heatmap-2d')) map3D.removeLayer('heatmap-2d');
      if (map3D.getSource('heatmap-2d')) map3D.removeSource('heatmap-2d');
      if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
      if (map3D.getSource('png-source')) map3D.removeSource('png-source');
      if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
      if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
      if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
      nowcastLayer3D.forEach(layer => {
        if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
        if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
      });
      nowcastLayer3D = [];
      map3D.resize();
      const currentBounds = map3D.getBounds();
      const newStrikes = new Set();

      // Get user-defined lifespan and slider position
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value) || 3;
      const slider = document.getElementById('history-slider');
      let sliderValue = parseInt(slider.value);
      const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;

      // Determine time range based on filter mode
      let startTime, endTime;
      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        const filterStart = new Date(customFilterStart);
        const filterEnd = new Date(customFilterEnd);
        if (isNaN(filterStart) || isNaN(filterEnd)) {
          console.error('Invalid custom filter dates');
          return;
        }
        const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
        const sliderMax = Math.max(totalMinutes, lifespanHours * 60);
        sliderValue = Math.min(sliderValue, sliderMax);
        slider.max = sliderMax;
        slider.min = 0;
        slider.value = sliderValue;
        endTime = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
        startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
      } else {
        const now = new Date();
        sliderValue = sliderValue || maxMinutes;
        slider.max = maxMinutes;
        slider.min = 0;
        endTime = new Date(now.getTime() - (maxMinutes - sliderValue) * 60 * 1000);
        startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
      }

      // Update animation times
      animationStart = startTime;
      animationEnd = endTime;

      // Filter strikes within the lifespan
      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(endTime.getTime() - maxMinutes * 60 * 1000) && s.time <= endTime;
        }
        return s.time >= startTime && s.time <= endTime;
      });

      // Add PNG layer
      if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
        map3D.addSource('png-source', {
          type: 'image',
          url: pngImage,
          coordinates: [
            [pngBounds[0][1], pngBounds[1][0]],
            [pngBounds[1][1], pngBounds[1][0]],
            [pngBounds[1][1], pngBounds[0][0]],
            [pngBounds[0][1], pngBounds[0][0]]
          ]
        });
        map3D.addLayer({
          id: 'png-layer',
          type: 'raster',
          source: 'png-source',
          paint: {
            'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
          }
        });
      }

      // Add KML layer
      if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
        map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
        map3D.addLayer({
          id: 'kml-layer',
          type: 'fill',
          source: 'kml-source',
          paint: {
            'fill-color': [
              'match',
              ['get', 'name'],
              'Low risk', risk_colors['Low risk'],
              'Slight risk', risk_colors['Slight risk'],
              'Enhanced risk', risk_colors['Enhanced risk'],
              'Moderate risk', risk_colors['Moderate risk'],
              'High risk', risk_colors['High risk'],
              'transparent'
            ],
            'fill-opacity': [
              'match',
              ['get', 'name'],
              'Low risk', 0.3,
              'Slight risk', 0.3,
              'Enhanced risk', 0.3,
              'Moderate risk', 0.3,
              'High risk', 0.3,
              0
            ]
          }
        });
        map3D.addLayer({
          id: 'kml-layer-outline',
          type: 'line',
          source: 'kml-source',
          paint: {
            'line-color': [
              'match',
              ['get', 'name'],
              'Low risk', risk_colors['Low risk'],
              'Slight risk', risk_colors['Slight risk'],
              'Enhanced risk', risk_colors['Enhanced risk'],
              'Moderate risk', risk_colors['Moderate risk'],
              'High risk', risk_colors['High risk'],
              risk_colors['Severe risk']
            ],
            'line-width': 2,
            'line-opacity': 1
          }
        });
      }

      // Add nowcast layers
      minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);
      if (document.getElementById('nowcast-toggle').checked) {
        currentNowcasts = calculateLightningNowcast(currentFiltered);
        currentNowcasts.forEach((cluster, index) => {
          if (cluster.confidenceScore >= minNowcastConfidence) {
            const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
              cluster.confidenceScore > 0.8 ? 'red' :
                cluster.confidenceScore > 0.7 ? 'orange' : 'green';
            const radiusKm = cluster.confidenceScore * 5 + 5;
            const coneRadiusKm = cluster.confidenceScore * 30 + 30;
            const radiusDeg = radiusKm / 111;

            // Add nowcast circle
            map3D.addSource(`nowcast-circle-${index}`, {
              type: 'geojson',
              data: {
                type: 'Feature',
                geometry: {
                  type: 'Point',
                  coordinates: [cluster.baseLon, cluster.baseLat]
                },
                properties: { radius: radiusDeg }
              }
            });
            map3D.addLayer({
              id: `nowcast-circle-${index}`,
              type: 'circle',
              source: `nowcast-circle-${index}`,
              paint: {
                'circle-radius': [
                  'interpolate',
                  ['linear'],
                  ['zoom'],
                  5, (radiusKm * 1000) / 1000,
                  10, (radiusKm * 1000) / 250
                ],
                'circle-color': confidenceColor,
                'circle-opacity': 0.5,
                'circle-stroke-color': confidenceColor,
                'circle-stroke-width': 2,
                'circle-stroke-opacity': 0.8
              }
            });
            nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

            // Add nowcast cone
            const cone = turf.sector(
              [cluster.baseLon, cluster.baseLat],
              coneRadiusKm,
              cluster.directionDeg - 15,
              cluster.directionDeg + 15,
              { units: 'kilometers' }
            );
            map3D.addSource(`nowcast-cone-${index}`, {
              type: 'geojson',
              data: cone
            });
            map3D.addLayer({
              id: `nowcast-cone-${index}`,
              type: 'fill',
              source: `nowcast-cone-${index}`,
              paint: {
                'fill-color': confidenceColor,
                'fill-opacity': 0.5
              }
            });
            nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
          }
        });
      }

      // Add lightning layer
      if (document.getElementById('lightning-layer-toggle').checked) {
        currentFiltered.forEach(s => {
          const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
          newStrikes.add(strikeKey);
          const isNewStrike = !lastRenderedStrikes.has(strikeKey);
          const inBounds = currentBounds.contains([s.coordinates[0], s.coordinates[1]]);
          const ageFraction = (endTime - s.time) / (lifespanHours * 3600 * 1000);

          const el = document.createElement('div');
          el.className = 'marker';
          el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
          el.style.width = '10px';
          el.style.height = '10px';
          el.style.borderRadius = '50%';
          const marker = new mapboxgl.Marker(el)
            .setLngLat([s.coordinates[0], s.coordinates[1]])
            .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
            .addTo(map3D);
          strikeLayer3D.push(marker);
          if (isNewStrike && inBounds) {
            playThunderSound();
            addLightningFlash3D(s.coordinates[0], s.coordinates[1]);
          }
        });
      }

      lastRenderedStrikes = newStrikes;

      // Render 2D and 3D heatmaps
      const heatmap2DEnabled = document.getElementById('heatmap-toggle').checked;
      const heatmap3DEnabled = document.getElementById('heatmap-3d-toggle').checked;
      const blur = parseInt(document.getElementById('blur-slider').value);

      if (heatmap2DEnabled) {
        const heatmapData = {
          type: 'FeatureCollection',
          features: currentFiltered.map(s => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [s.coordinates[0], s.coordinates[1]]
            },
            properties: { intensity: 1 }
          }))
        };
        map3D.addSource('heatmap-2d', {
          type: 'geojson',
          data: heatmapData
        });
        map3D.addLayer({
          id: 'heatmap-2d',
          type: 'heatmap',
          source: 'heatmap-2d',
          paint: {
            'heatmap-weight': ['get', 'intensity'],
            'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 1, 9, 3],
            'heatmap-color': [
              'interpolate',
              ['linear'],
              ['heatmap-density'],
              0, 'rgba(0, 18, 25, 0)',
              0.1, '#001219',
              0.2, '#0A9396',
              0.3, '#94D2BD',
              0.4, '#E9D8A6',
              0.5, '#c89578',
              0.6, '#EE9B00',
              0.7, '#CA6702',
              0.8, '#BB3E03',
              0.9, '#AE2012',
              1, '#9B2226'
            ],
            'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, blur, 9, blur * 2],
            'heatmap-opacity': ['interpolate', ['linear'], ['zoom'], 7, 1, 9, 0.7]
          }
        });
      }

      if (heatmap3DEnabled) {
        const frequency = parseInt(document.getElementById('heatmap-frequency-slider').value);
        const maxHeight = parseInt(document.getElementById('heatmap-height-slider').value);
        const gridData = generateHeatmapGrid(currentFiltered, frequency);
        map3D.addSource('heatmap-3d', {
          type: 'geojson',
          data: gridData
        });
        map3D.addLayer({
          id: 'heatmap-3d',
          type: 'fill-extrusion',
          source: 'heatmap-3d',
          paint: {
            'fill-extrusion-color': [
              'interpolate',
              ['linear'],
              ['get', 'intensity'],
              0, '#001219',
              0.1, '#001219',
              0.2, '#0A9396',
              0.3, '#94D2BD',
              0.4, '#E9D8A6',
              0.5, '#c89578',
              0.6, '#EE9B00',
              0.7, '#CA6702',
              0.8, '#BB3E03',
              0.9, '#AE2012',
              1, '#9B2226'
            ],
            'fill-extrusion-height': ['*', ['get', 'intensity'], maxHeight],
            'fill-extrusion-base': 0,
            'fill-extrusion-opacity': 0.7
          }
        });
      }

      updateOverlay(currentFiltered);
      updateLegend();
    }
    function generateHeatmapGrid(data, frequency) {
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;
      const latStep = (maxLat - minLat) / frequency;
      const lngStep = (maxLng - minLng) / frequency;
      const grid = [];

      for (let i = 0; i < frequency; i++) {
        for (let j = 0; j < frequency; j++) {
          const count = data.reduce((sum, s) => {
            const lat = s.coordinates[1];
            const lng = s.coordinates[0];
            const cellLatMin = minLat + i * latStep;
            const cellLatMax = cellLatMin + latStep;
            const cellLngMin = minLng + j * lngStep;
            const cellLngMax = cellLngMin + lngStep;
            return sum + (lat >= cellLatMin && lat < cellLatMax && lng >= cellLngMin && lng < cellLngMax ? 1 : 0);
          }, 0);
          if (count > 0) {
            const intensity = Math.min(count / 10, 1);
            grid.push({
              type: 'Feature',
              properties: { intensity },
              geometry: {
                type: 'Polygon',
                coordinates: [[
                  [minLng + j * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + i * latStep]
                ]]
              }
            });
          }
        }
      }

      return {
        type: 'FeatureCollection',
        features: grid
      };
    }

    function toggleExpertMode() {
      const expertControls = document.getElementById('expert-controls');
      const isExpertMode = document.getElementById('expert-mode').checked;
      expertControls.style.display = isExpertMode ? 'grid' : 'none';
      if (isExpertMode) {
        // Add KML and PNG layers if they exist and checkboxes are checked
        toggleKMLLayer();
        togglePNGLayer();
      } else {
        // Remove KML and PNG layers when Expert Mode is disabled
        if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
        if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
        if (is3DMode) {
          if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
          if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
          if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
          if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        }
      }
      updateZIndex();
      updateLegend();
    }

    function showTutorial() {
      document.getElementById('tutorial-modal').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
    }

    function closeTutorial() {
      document.getElementById('tutorial-modal').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }

    function updateHistorySliderMax() {
      if (lastFilterMode === 'slider') {
        const maxHours = parseInt(document.getElementById('max-history-hours').value) || 6;
        document.getElementById('history-slider').max = maxHours * 60;
        document.getElementById('history-slider').value = maxHours * 60;
        updateHistory();
      }
    }

    function formatTimeAgo(minutesBack) {
      if (minutesBack === 0) return 'Now';
      const hours = Math.floor(minutesBack / 60);
      const minutes = minutesBack % 60;
      let result = '';
      if (hours > 0) result += `${hours}h `;
      if (minutes > 0 || hours === 0) result += `${minutes}m`;
      return result.trim() + ' ago';
    }

    function updateHistory() {
      isAdjustingHistory = true;
      const slider = document.getElementById('history-slider');
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      let start, end, sliderMax, sliderValue, minutesBack;

      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        const filterStart = new Date(customFilterStart);
        const filterEnd = new Date(customFilterEnd);

        if (isNaN(filterStart) || isNaN(filterEnd)) {
          console.error('Invalid custom date/time format.');
          isAdjustingHistory = false;
          return;
        }

        const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
        sliderMax = Math.max(totalMinutes, lifespanHours * 60);
        sliderValue = parseInt(slider.value) || sliderMax;
        minutesBack = sliderMax - sliderValue;

        end = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = sliderMax;
        slider.min = 0;
        slider.value = sliderValue;
        if (!is3DMode) {
          map.invalidateSize();
        }
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      } else {
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;
        sliderMax = maxMinutes;
        sliderValue = parseInt(slider.value) || maxMinutes;
        minutesBack = maxMinutes - sliderValue;

        const now = new Date();
        end = new Date(now.getTime() - minutesBack * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = maxMinutes;
        slider.min = 0;
        slider.value = sliderValue;

        //document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        //document.getElementById('end-time').value = end.toISOString().slice(0, 16);
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
        document.getElementById('remove-filter').style.display = 'none';
      }

      animationStart = start;
      animationEnd = end;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ?
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      updateZIndex();
      updateLegend();
      updateMapLayers(end.getTime());

      if (is3DMode) update3DView();

      setTimeout(() => { isAdjustingHistory = false; }, 1000);
    }

    function removeTimeFilter() {
      lastFilterMode = 'slider';
      customFilterStart = null;
      customFilterEnd = null;
      document.getElementById('remove-filter').style.display = 'none';
      document.getElementById('auto-latest').checked = true;
      toggleAutoLatest();
    }

    function setRefreshInterval() {
      if (refreshTimer) clearInterval(refreshTimer);
      const interval = parseFloat(document.getElementById('refresh-interval').value);
      if (interval > 0) {
        refreshTimer = setInterval(fetchData, interval * 60 * 1000);
      }
    }

    function toggleAutoLatest() {
      if (document.getElementById('auto-latest').checked) {
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const now = new Date();
        const start = new Date(now.getTime() - lifespanHours * 3600 * 1000);
        document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        document.getElementById('end-time').value = now.toISOString().slice(0, 16);
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 6) * 60;
        document.getElementById('history-slider').value = maxMinutes;
        document.getElementById('history-label').innerText = 'Now';
        lastFilterMode = 'slider';
        customFilterStart = null;
        customFilterEnd = null;
        document.getElementById('remove-filter').style.display = 'none';
        updateHistory();
      }
    }

    function updateClock() {
      const now = new Date();
      document.getElementById('current-time').innerText = `Current time: ${now.toLocaleString()}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    function parseDateFromFilename(filename) {
      const regex = /(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})__(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})|(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})\s+-\s+(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})/;
      const match = filename.match(regex);
      if (!match) return null;

      let startDate, endDate;
      if (match[1]) {
        startDate = new Date(`${match[3]}-${match[2]}-${match[1]}T${match[4]}:${match[5]}:00Z`);
        endDate = new Date(`${match[8]}-${match[7]}-${match[6]}T${match[9]}:${match[10]}:00Z`);
      } else {
        startDate = new Date(`${match[13]}-${match[12]}-${match[11]}T${match[14]}:${match[15]}:00Z`);
        endDate = new Date(`${match[18]}-${match[17]}-${match[16]}T${match[19]}:${match[20]}:00Z`);
      }

      return { startDate, endDate };
    }

    function showTimeFilterModal(file, type) {
      pendingFile = file;
      pendingFileType = type;
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'block';
      overlay.style.display = 'block';
    }

    function confirmAutoTimeFilter(confirm) {
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'none';
      overlay.style.display = 'none';

      if (!pendingFile || !pendingFileType) return;

      if (confirm && document.getElementById('auto-time-filter').checked) {
        const dates = parseDateFromFilename(pendingFile.name);
        if (dates && !isNaN(dates.startDate) && !isNaN(dates.endDate)) {
          document.getElementById('start-time').value = dates.startDate.toISOString().slice(0, 16);
          document.getElementById('end-time').value = dates.endDate.toISOString().slice(0, 16);
          lastFilterMode = 'inputs';
          applyFilter();
        }
      }

      if (pendingFileType === 'kml') importKML({ files: [pendingFile] });
      else if (pendingFileType === 'png') importPNG({ files: [pendingFile] });

      pendingFile = null;
      pendingFileType = null;
    }

    async function fetchData() {
      const githubUrl1 = 'https://raw.githubusercontent.com/HandryOutlook/lightning_data_new/refs/heads/main/lightning_data.json';
      const githubUrl2 = 'https://raw.githubusercontent.com/HandryOutlook/lightning_data_new/refs/heads/main/lightning_data_2025_autumn.json';
      const metOfficeBaseUrl = 'https://data.consumer-digital.api.metoffice.gov.uk/v1/lightning';

      try {
        // Fetch the main Met Office URL to get chunks and strikes
        const mainResponse = await fetch(metOfficeBaseUrl).then(res => res.json()).catch(() => null);
        if (!mainResponse) {
          console.error('Failed to fetch main Met Office URL');
          throw new Error('No data from main Met Office URL');
        }

        // Extract strikes from the base URL
        const baseStrikes = mainResponse?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];

        // Extract chunks and generate chunk URLs
        const chunkUrls = mainResponse?.chunks?.map(chunk =>
          `${metOfficeBaseUrl}?last-minutes=1&chunk=${chunk.chunk}`
        ) || [];
        if (!mainResponse.chunks) {
          console.warn('No chunks data found in main Met Office URL response');
        }

        // Fetch both GitHub URLs and all chunk URLs in parallel
        const fetchPromises = [
          fetch(githubUrl1).then(res => res.json()).catch(() => null),
          fetch(githubUrl2).then(res => res.json()).catch(() => null),
          ...chunkUrls.map(url => fetch(url).then(res => res.json()).catch(() => null))
        ];

        const responses = await Promise.all(fetchPromises);

        // Process GitHub strikes from both URLs
        const githubStrikes1 = responses[0]?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];
        const githubStrikes2 = responses[1]?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];

        // Combine strikes from all Met Office chunk responses (skip the first two responses, which are GitHub)
        const chunkStrikes = responses.slice(2).flatMap(response =>
          response?.lightning_strikes?.map(s => ({
            ...s,
            time: new Date(s.strike_time)
          })) || []
        );

        // Combine all strikes (both GitHub URLs, base URL, and chunk URLs)
        const allStrikes = [...githubStrikes1, ...githubStrikes2, ...baseStrikes, ...chunkStrikes];

        // Deduplicate strikes
        const seen = new Map();
        strikeData = allStrikes.filter(s => {
          const key = `${s.strike_time}_${s.coordinates[0]}_${s.coordinates[1]}`;
          if (!seen.has(key)) {
            seen.set(key, true);
            return true;
          }
          return false;
        });

        // Update last update time in the UI
        lastUpdateTime = new Date();
        document.getElementById('last-update').innerText = `Last update: ${lastUpdateTime.toLocaleString()}`;

        // Apply filters based on the last filter mode
        if (lastFilterMode === 'slider') {
          updateHistory(); // Calls updateNowcast()
        } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
          applyFilter(); // Calls updateNowcast()
        }
      } catch (error) {
        console.error('Error fetching lightning data:', error);
        strikeData = [];
        if (lastFilterMode === 'slider') {
          updateHistory();
        } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
          applyFilter();
        }
      }
    }

    function getColorFromAge(ageFraction) {

      if (ageFraction < 0.2) return '#ffd700'; // Newest
      if (ageFraction < 0.4) return '#ff69b4';
      if (ageFraction < 0.6) return '#ff00ff';
      if (ageFraction < 0.8) return '#800080';
      return '#4b0082'; // Oldest
    }

    function updateLegend() {
      const legendDiv = document.querySelector('.legend');
      legendDiv.innerHTML = '';
      const colorMode = document.getElementById('color-mode').checked;
      const heatmap2DEnabled = document.getElementById('heatmap-toggle').checked;
      const heatmap3DEnabled = is3DMode && document.getElementById('heatmap-3d-toggle').checked;
      const lightningEnabled = document.getElementById('lightning-layer-toggle').checked;
      const kmlEnabled = document.getElementById('kml-layer-toggle')?.checked;
      const pngEnabled = document.getElementById('png-layer-toggle')?.checked;
      const nowcastEnabled = document.getElementById('nowcast-toggle').checked;

      // Fix: Get radar type from select value and check if enabled
      const radarSelect = document.getElementById('radarLayer');
      const radarEnabled = radarSelect && radarSelect.value !== 'none';
      const radarType = radarSelect ? radarSelect.value : null;

      if (lightningEnabled) {
        legendDiv.innerHTML += '<h4>Lightning Strikes</h4>';
        if (colorMode) {
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: #ffd700"></div>Newest</div>
        <div><div class="color-box" style="background: #ff69b4"></div></div>
        <div><div class="color-box" style="background: #ff00ff"></div></div>
        <div><div class="color-box" style="background: #800080"></div></div>
        <div><div class="color-box" style="background: #4b0082"></div>Oldest</div>
      `;
        } else {
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: black"></div>Strikes</div>
      `;
        }
      }

      if (heatmap2DEnabled) {
        legendDiv.innerHTML += `
      <h4>2D Heatmap</h4>
      <div style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #c89578, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226); margin-top: 4px" class="gradient-bar"></div>
      <div style="display: flex; justify-content: space-between; margin-top: 4px">
        <span>Low</span><span>High</span>
      </div>
    `;
      }

      if (heatmap3DEnabled) {
        legendDiv.innerHTML += `
      <h4>3D Heatmap</h4>
      <div style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #c89578, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226); margin-top: 4px" class="gradient-bar"></div>
      <div style="display: flex; justify-content: space-between; margin-top: 4px">
        <span>Low</span><span>High</span>
      </div>
    `;
      }

      if (kmlEnabled && kmlLayer) {
        legendDiv.innerHTML += '<h4>Risk Levels</h4>';
        Object.entries(risk_colors).forEach(([name, color]) => {
          const isSevere = name === 'Severe risk';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: ${isSevere ? 'none' : color}; border: 2px solid ${color};"></div>${name}</div>
      `;
        });
      }

      if (nowcastEnabled) {
        legendDiv.innerHTML += '<h4>Nowcast Confidence </h4>';
        legendDiv.innerHTML += `
      <div style="display: flex; align-items: center;">
          <div class="color-gradient" style="
              width: 100px; 
              height: 20px; 
              background: linear-gradient(to right, #FF8C00, #CC0000); 
              opacity: 1.0; 
              border: 1px solid #333;
          "></div>
          
    `;
      }

      // Fix: Proper radar legend structure with all conditions inside radarEnabled check
      if (radarEnabled && radarType) {
        if (radarType === 'uk-precip-intensity-pixelated') {
          legendDiv.innerHTML += '<h4>Rainfall Intensity</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: #b30000"></div>>32mm/h</div>
        <div><div class="color-box" style="background: #fe0000"></div>16-32mm/h</div>
        <div><div class="color-box" style="background: #fe9800"></div>8-16mm/h</div>
        <div><div class="color-box" style="background: #00a300"></div>2-4mm/h</div>
        <div><div class="color-box" style="background: #0cbcfe"></div>1-2mm/h</div>
        <div><div class="color-box" style="background: #3265fe"></div>0.5-1mm/h</div>
        <div><div class="color-box" style="background: #0000fe"></div><0.5mm/h</div>
      `;
        } else if (radarType === 'uk-precip-type') {
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Freezing Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(252, 133, 145)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 88, 103)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>7 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(34, 145, 176)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(8, 98, 138)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Rain and Snow (Sleet)</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets and Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
      `;

        } else if (radarType === 'europe-precip-type') {
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Freezing Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 217, 221)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(244, 187, 193)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 159, 167)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(252, 133, 145)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(250, 88, 103)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 73, 82)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(245, 51, 59)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(212, 14, 23)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 15, 23)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(129, 5, 8)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>7 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(166, 219, 228)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(102, 188, 208)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(45, 155, 180)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(34, 145, 176)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(8, 98, 138)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(6, 72, 102)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(4, 51, 72)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(3, 36, 51)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Rain and Snow (Sleet)</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(72, 36, 118)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(64, 31, 104)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(56, 23, 90)"></div>200 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(204, 196, 223)"></div>0.3 mm/h</div>
      `;
          legendDiv.innerHTML += '<h4>Precipitation: Snow Pellets and Hail</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(182, 172, 209)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(164, 149, 195)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(147, 128, 182)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(170, 110, 131)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(118, 93, 160)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(104, 76, 150)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(91, 59, 140)"></div>5 mm/h</div>
      `;
        } else {
          // Default for other radar types (e.g., smooth Europe radar)
          legendDiv.innerHTML += '<h4>Precipitation: Rain</h4>';
          legendDiv.innerHTML += `
        <div><div class="color-box" style="background: transparent"></div>0.125 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.2 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.3 mm/h</div>
        <div><div class="color-box" style="background: rgb(134, 203, 107)"></div>0.4 mm/h</div>
        <div><div class="color-box" style="background: rgb(108, 185, 78)"></div>0.5 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.6 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.7 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>0.8 mm/h</div>
        <div><div class="color-box" style="background: rgb(89, 167, 61)"></div>1 mm/h</div>
        <div><div class="color-box" style="background: rgb(79, 152, 57)"></div>1.25 mm/h</div>
        <div><div class="color-box" style="background: rgb(50, 113, 48)"></div>2 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>3 mm/h</div>
        <div><div class="color-box" style="background: rgb(41, 88, 37)"></div>4 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>5 mm/h</div>
        <div><div class="color-box" style="background: rgb(231, 232, 79)"></div>8 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>10 mm/h</div>
        <div><div class="color-box" style="background: rgb(246, 176, 32)"></div>15 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>20 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>25 mm/h</div>
        <div><div class="color-box" style="background: rgb(240, 40, 31)"></div>30 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>35 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>40 mm/h</div>
        <div><div class="color-box" style="background: rgb(179, 31, 36)"></div>50 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>65 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>75 mm/h</div>
        <div><div class="color-box" style="background: rgb(192, 76, 162)"></div>100 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>150 mm/h</div>
        <div><div class="color-box" style="background: rgb(137, 60, 158)"></div>200 mm/h</div>
      `;
        }
      }

      // Show or hide based on isLegendVisible and content
      legendDiv.style.display = (isLegendVisible && legendDiv.innerHTML) ? 'block' : 'none';

      if (is3DMode) {
        let map3DLegend = document.getElementById('map3d-legend');
        if (!map3DLegend) {
          map3DLegend = document.createElement('div');
          map3DLegend.id = 'map3d-legend';
          map3DLegend.className = 'legend';
          map3DLegend.style.position = 'absolute';
          map3DLegend.style.top = '100px';
          map3DLegend.style.right = '10px';
          map3DLegend.style.zIndex = '1002';
          document.getElementById('map-3d').appendChild(map3DLegend);
        }
        map3DLegend.innerHTML = legendDiv.innerHTML;
        map3DLegend.style.display = (isLegendVisible && legendDiv.innerHTML) ? 'block' : 'none';
      } else {
        const map3DLegend = document.getElementById('map3d-legend');
        if (map3DLegend) map3DLegend.remove();
      }
    }

    function toggleLegend() {
      isLegendVisible = !isLegendVisible;
      updateLegend(); // Update visibility based on new state
    }

    function applyFilter() {
      isFilterApplied = true;
      lastFilterMode = 'inputs';
      const start = new Date(document.getElementById('start-time').value);
      const end = new Date(document.getElementById('end-time').value);
      if (isNaN(start) || isNaN(end)) {
        console.error('Invalid date/time format.');
        alert('Invalid date/time format.');
        return;
      }

      customFilterStart = start;
      customFilterEnd = end;

      const totalMinutes = (end - start) / (60 * 1000);
      const slider = document.getElementById('history-slider');
      slider.max = Math.max(totalMinutes, parseFloat(document.getElementById('lightning-lifespan').value) * 60);
      slider.value = totalMinutes;
      slider.min = 0;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      // Sort strikes by time (oldest first) to ensure newer strikes are plotted on top
      currentFiltered.sort((a, b) => a.time.getTime() - b.time.getTime());

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ?
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      document.getElementById('time-range').innerText = `Filter applied: ${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('history-label').innerText = formatTimeAgo(0);
      document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('remove-filter').style.display = 'block';
      updateZIndex();
      updateLegend();
      if (is3DMode) update3DView();
    }
    /**
 * Converts a hex color string (e.g., "#FF8C00") to an RGB array [R, G, B].
 * Assumes a valid 6-digit hex code with optional '#' prefix.
 */
    function hexToRgb(hex) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0]; // Return black on failure
    }

    /**
     * Converts an RGB array [R, G, B] to a 6-digit hex color string.
     */
    function rgbToHex(r, g, b) {
      const toHex = (c) => {
        const hex = Math.round(c).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }
    /**
     * Linearly interpolates between two hex colors based on a confidence score.
     * * @param {string} colorLow - Hex color for the lowest confidence (e.g., #FF8C00).
     * @param {string} colorHigh - Hex color for the highest confidence (e.g., #CC0000).
     * @param {number} confidenceScore - Value between 0.0 and 1.0.
     * @returns {string} The interpolated hex color string.
     */
    function interpolateColor(colorLow, colorHigh, confidenceScore) {
      // 1. Clamp the score between 0 and 1
      const t = Math.max(0, Math.min(1, confidenceScore));

      // 2. Convert hex to RGB arrays
      const rgbLow = hexToRgb(colorLow);
      const rgbHigh = hexToRgb(colorHigh);

      // 3. Linear interpolation for R, G, and B components
      const R_low = rgbLow[0];
      const G_low = rgbLow[1];
      const B_low = rgbLow[2];

      const R_high = rgbHigh[0];
      const G_high = rgbHigh[1];
      const B_high = rgbHigh[2];

      const R = R_low + (R_high - R_low) * t;
      const G = G_low + (G_high - G_low) * t;
      const B = B_low + (B_high - B_low) * t;

      // 4. Convert the interpolated RGB back to a Hex code
      return rgbToHex(R, G, B);
    }
    const LOW_CONFIDENCE_COLOR = '#FF8C00'; // Dark Orange
    const HIGH_CONFIDENCE_COLOR = '#CC0000'; // Deep Red
    // In your loop when drawing a nowcast polygon:


    // Render the polygon with finalFillColor and finalOpacity
    function updateStrikeColors() {
      const colorMode = document.getElementById('color-mode').checked;
      const end = new Date(document.getElementById('end-time').value);
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      strikeCircles.forEach(({ circle, strike }) => {
        let color;
        if (colorMode) {
          const ageFraction = (end - strike.time) / (lifespanHours * 3600 * 1000);
          color = getColorFromAge(ageFraction);
        } else {
          color = 'black';
        }
        circle.setStyle({ color, fillColor: color });
      });
      if (is3DMode) update3DView();
      updateLegend();
    }

    function toggleViewMode() {
      stopAnimation();
      const button = document.getElementById('view-mode');
      showAllStrikes = !showAllStrikes;
      button.innerText = showAllStrikes ? 'Disable all strikes' : 'Enable all strikes';

      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        applyFilter();
      } else {
        updateHistory();
      }
    }

    function updateHeatmap(filtered) {
      if (is3DMode) {
        update3DView();
      } else {
        const data = filtered.map(s => [s.coordinates[1], s.coordinates[0], 1]);
        const blur = parseInt(document.getElementById('blur-slider').value);
        if (heatmapLayer) map.removeLayer(heatmapLayer);

        heatmapLayer = L.heatLayer(data, {
          radius: blur,
          blur: 15,
          maxZoom: 10,
          minZoom: 10,
          gradient: { 0.0: '#001219', 0.1: '#001219', 0.2: '#0A9396', 0.3: '#94D2BD', 0.4: '#E9D8A6', 0.5: '#c89578', 0.6: '#EE9B00', 0.7: '#CA6702', 0.8: '#BB3E03', 0.9: '#AE2012', 1.0: '#9B2226' }
        });

        if (document.getElementById('heatmap-toggle').checked) {
          heatmapLayer.addTo(map);
          heatmapLayer._canvas.style.zIndex = 70;
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleHeatmap() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('heatmap-toggle').checked) {
          if (heatmapLayer) {
            heatmapLayer.addTo(map);
            heatmapLayer._canvas.style.zIndex = 70;
          }
        } else {
          if (heatmapLayer) map.removeLayer(heatmapLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleLightningLayer() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('lightning-layer-toggle').checked) {
          if (!map.hasLayer(strikeLayer)) {
            map.addLayer(strikeLayer);
          }
        } else {
          map.removeLayer(strikeLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleKMLLayer() {
      const toggle = document.getElementById('kml-layer-toggle').checked;
      if (is3DMode) {
        // Remove existing layers and source if they exist
        if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
        if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
        if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');

        if (toggle && kmlGeoJSON) {
          // Add new source and layers only if toggle is enabled and kmlGeoJSON exists
          map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
          map3D.addLayer({
            id: 'kml-layer',
            type: 'fill',
            source: 'kml-source',
            paint: {
              'fill-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                'transparent' // Transparent for Severe risk or unknown
              ],
              'fill-opacity': [
                'match',
                ['get', 'name'],
                'Low risk', 0.3,
                'Slight risk', 0.3,
                'Enhanced risk', 0.3,
                'Moderate risk', 0.3,
                'High risk', 0.3,
                0 // No fill for Severe risk or unknown
              ]
            }
          });
          map3D.addLayer({
            id: 'kml-layer-outline',
            type: 'line',
            source: 'kml-source',
            paint: {
              'line-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                risk_colors['Severe risk'] // Black outline for Severe risk or unknown
              ],
              'line-width': 2,
              'line-opacity': 1
            }
          });
          map3D.resize();
        }
      } else {
        if (toggle && kmlLayer && !map.hasLayer(kmlLayer)) {
          map.addLayer(kmlLayer);
          kmlLayer.setZIndex(60);
        } else if (kmlLayer) {
          map.removeLayer(kmlLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function togglePNGLayer() {
      const toggle = document.getElementById('png-layer-toggle').checked;
      if (is3DMode) {
        if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
        if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        if (toggle && pngImage && pngBounds) {
          map3D.addSource('png-source', {
            type: 'image',
            url: pngImage,
            coordinates: [
              [pngBounds[0][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[0][0]],
              [pngBounds[0][1], pngBounds[0][0]]
            ]
          });
          map3D.addLayer({
            id: 'png-layer',
            type: 'raster',
            source: 'png-source',
            paint: {
              'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
            }
          });
        }
      } else {
        if (toggle && pngLayer && !map.hasLayer(pngLayer)) {
          map.addLayer(pngLayer);
          pngLayer.setZIndex(40);
        } else if (pngLayer) {
          map.removeLayer(pngLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }


    function updateZIndex() {
      const expertMode = document.getElementById('expert-mode').checked;
      const lightningZ = expertMode ? parseInt(document.getElementById('lightning-zindex').value) || 1000 : 1000;
      const heatmapZ = expertMode ? parseInt(document.getElementById('heatmap-zindex').value) || 70 : 70;
      const kmlZ = expertMode ? parseInt(document.getElementById('kml-zindex').value) || 60 : 60;
      const pngZ = expertMode ? parseInt(document.getElementById('png-zindex').value) || 40 : 40;
      const numbersZ = expertMode ? parseInt(document.getElementById('numbers-zindex').value) || 1200 : 1200;
      const nowcastZ = Math.max(kmlZ, pngZ) + 10; // Ensure nowcast is above KML and PNG, but below lightning

      // Remove all layers to re-add them in the correct order
      if (nowcastLayer && map.hasLayer(nowcastLayer)) map.removeLayer(nowcastLayer);
      if (strikeLayer && map.hasLayer(strikeLayer)) map.removeLayer(strikeLayer);
      if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
      if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
      if (heatmapLayer && map.hasLayer(heatmapLayer)) map.removeLayer(heatmapLayer);
      if (numberOverlay && map.hasLayer(numberOverlay)) map.removeLayer(numberOverlay);

      // Add layers back in desired order: heatmap, png, kml, nowcast, lightning, numbers
      if (heatmapLayer && document.getElementById('heatmap-toggle').checked) {
        heatmapLayer._canvas.style.zIndex = heatmapZ;
        map.addLayer(heatmapLayer);
      }
      if (pngLayer && document.getElementById('png-layer-toggle').checked) {
        pngLayer.setZIndex(pngZ);
        map.addLayer(pngLayer);
      }
      if (kmlLayer && document.getElementById('kml-layer-toggle').checked) {
        kmlLayer.setZIndex(kmlZ);
        map.addLayer(kmlLayer);
      }
      if (nowcastLayer && document.getElementById('nowcast-toggle').checked) {
        nowcastLayer.eachLayer(layer => {
          if (layer.setZIndex) layer.setZIndex(nowcastZ);
        });
        nowcastLayer.setZIndex(nowcastZ);
        map.addLayer(nowcastLayer);
      }
      if (strikeLayer && document.getElementById('lightning-layer-toggle').checked) {
        strikeLayer.setZIndex(lightningZ);
        map.addLayer(strikeLayer);
      }
      if (numberOverlay && document.getElementById('number-overlay-toggle').checked) {
        numberOverlay.setZIndex(numbersZ);
        map.addLayer(numberOverlay);
      }

      // In 3D mode, ensure correct layer order by re-adding layers
      if (is3DMode) {
        // Remove existing 3D layers
        if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
        if (map3D.getSource('png-source')) map3D.removeSource('png-source');
        if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
        if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
        if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
        nowcastLayer3D.forEach(layer => {
          if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
          if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
        });
        strikeLayer3D.forEach(marker => marker.remove());
        strikeLayer3D = [];

        // Re-add PNG layer
        if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
          map3D.addSource('png-source', {
            type: 'image',
            url: pngImage,
            coordinates: [
              [pngBounds[0][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[1][0]],
              [pngBounds[1][1], pngBounds[0][0]],
              [pngBounds[0][1], pngBounds[0][0]]
            ]
          });
          map3D.addLayer({
            id: 'png-layer',
            type: 'raster',
            source: 'png-source',
            paint: {
              'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
            }
          });
        }

        // Re-add KML layer
        if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
          map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
          map3D.addLayer({
            id: 'kml-layer',
            type: 'fill',
            source: 'kml-source',
            paint: {
              'fill-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                'transparent'
              ],
              'fill-opacity': [
                'match',
                ['get', 'name'],
                'Low risk', 0.3,
                'Slight risk', 0.3,
                'Enhanced risk', 0.3,
                'Moderate risk', 0.3,
                'High risk', 0.3,
                0
              ]
            }
          });
          map3D.addLayer({
            id: 'kml-layer-outline',
            type: 'line',
            source: 'kml-source',
            paint: {
              'line-color': [
                'match',
                ['get', 'name'],
                'Low risk', risk_colors['Low risk'],
                'Slight risk', risk_colors['Slight risk'],
                'Enhanced risk', risk_colors['Enhanced risk'],
                'Moderate risk', risk_colors['Moderate risk'],
                'High risk', risk_colors['High risk'],
                risk_colors['Severe risk']
              ],
              'line-width': 2,
              'line-opacity': 1
            }
          });
        }

        // Re-add nowcast layers
        if (document.getElementById('nowcast-toggle').checked) {
          currentNowcasts.forEach((cluster, index) => {
            if (cluster.confidenceScore >= minNowcastConfidence) {
              const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                cluster.confidenceScore > 0.8 ? 'red' :
                  cluster.confidenceScore > 0.7 ? 'orange' : 'green';
              const radiusKm = cluster.confidenceScore * 5 + 5;
              const coneRadiusKm = cluster.confidenceScore * 30 + 30;
              const radiusDeg = radiusKm / 111;

              map3D.addSource(`nowcast-circle-${index}`, {
                type: 'geojson',
                data: {
                  type: 'Feature',
                  geometry: {
                    type: 'Point',
                    coordinates: [cluster.baseLon, cluster.baseLat]
                  },
                  properties: { radius: radiusDeg }
                }
              });
              map3D.addLayer({
                id: `nowcast-circle-${index}`,
                type: 'circle',
                source: `nowcast-circle-${index}`,
                paint: {
                  'circle-radius': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    5, (radiusKm * 1000) / 1000,
                    10, (radiusKm * 1000) / 250
                  ],
                  'circle-color': confidenceColor,
                  'circle-opacity': 0.5,
                  'circle-stroke-color': confidenceColor,
                  'circle-stroke-width': 2,
                  'circle-stroke-opacity': 0.8
                }
              });
              nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

              const at = turf.sector(
                [cluster.baseLon, cluster.baseLat],
                coneRadiusKm,
                cluster.directionDeg - 15,
                cluster.directionDeg + 15,
                { units: 'kilometers' }
              );
              map3D.addSource(`nowcast-cone-${index}`, {
                type: 'geojson',
                data: cone
              });
              map3D.addLayer({
                id: `nowcast-cone-${index}`,
                type: 'fill',
                source: `nowcast-cone-${index}`,
                paint: {
                  'fill-color': confidenceColor,
                  'fill-opacity': 0.5
                }
              });
              nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
            }
          });
        }

        // Re-add lightning layer
        if (document.getElementById('lightning-layer-toggle').checked) {
          currentFiltered.forEach(s => {
            const ageFraction = (animationEnd - s.time) / (parseFloat(document.getElementById('lightning-lifespan').value) * 3600 * 1000);
            const el = document.createElement('div');
            el.className = 'marker';
            el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
            el.style.width = '10px';
            el.style.height = '10px';
            el.style.borderRadius = '50%';
            const marker = new mapboxgl.Marker(el)
              .setLngLat([s.coordinates[0], s.coordinates[1]])
              .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
              .addTo(map3D);
            strikeLayer3D.push(marker);
          });
        }
      }
    }

    function updateOverlay(filtered) {
      if (numberOverlay) {
        map.removeLayer(numberOverlay);
        numberOverlay = null;
      }
      numberOverlay3D.forEach(marker => marker.remove());
      numberOverlay3D = [];

      if (!document.getElementById('number-overlay-toggle').checked) return;

      const density = parseInt(document.getElementById('density-slider').value);
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;

      const latStep = (maxLat - minLat) / density;
      const lngStep = (maxLng - minLng) / density;
      const grid = new Map();

      for (let i = 0; i < density; i++) {
        for (let j = 0; j < density; j++) grid.set(`${i}_${j}`, 0);
      }

      filtered.forEach(s => {
        const lat = s.coordinates[1];
        const lng = s.coordinates[0];
        if (lat >= minLat && lat <= maxLat && lng >= minLng && lng <= maxLng) {
          const i = Math.floor((lat - minLat) / latStep);
          const j = Math.floor((lng - minLng) / lngStep);
          const key = `${i}_${j}`;
          if (grid.has(key)) grid.set(key, grid.get(key) + 1);
        }
      });

      if (is3DMode) {
        grid.forEach((count, key) => {
          if (count === 0) return;
          const [i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const el = document.createElement('div');
          el.innerHTML = `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`;
          const marker = new mapboxgl.Marker(el)
            .setLngLat([cellLng, cellLat])
            .addTo(map3D);
          numberOverlay3D.push(marker);
        });
      } else {
        numberOverlay = L.layerGroup();
        grid.forEach((count, key) => {
          if (count === 0) return;
          const [i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const text = L.divIcon({
            html: `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`,
            className: ''
          });
          const marker = L.marker([cellLat, cellLng], { icon: text });
          numberOverlay.addLayer(marker);
        });
        numberOverlay.addTo(map);
        numberOverlay.setZIndex(parseInt(document.getElementById('numbers-zindex').value) || 1200);
      }
      updateZIndex();
    }

    function switchBaseMap(style) {
      Object.values(baseLayers).forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      baseLayers[style].addTo(map);
      updateZIndex();
      map.invalidateSize();
    }

    function playAnimation() {
      if (isPlaying) return;
      isPlaying = true;
      const slider = document.getElementById('history-slider');
      let currentValue = parseFloat(slider.value);
      const maxValue = parseFloat(slider.max);
      const speed = parseFloat(document.getElementById('speed-slider').value); // Minutes per second
      let lastFrameTime = performance.now();

      function animate(currentTime) {
        if (!isPlaying) return;

        const deltaTime = (currentTime - lastFrameTime) / 1000; // Time since last frame in seconds
        lastFrameTime = currentTime;

        // Increment slider value: speed (min/sec) * deltaTime (sec) = minutes to advance
        currentValue += speed * deltaTime;

        if (currentValue >= maxValue) {
          currentValue = maxValue;
          slider.value = currentValue;
          updateHistory();
          stopAnimation();
          return;
        }

        slider.value = currentValue;
        updateHistory();

        animationInterval = requestAnimationFrame(animate);
      }

      animationInterval = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      if (animationInterval) {
        cancelAnimationFrame(animationInterval);
        animationInterval = null;
      }
      isPlaying = false;
    }

    function toggleFullScreen() {
      const container = document.body;
      isFullScreen = !isFullScreen;
      if (isFullScreen) {
        container.classList.add('fullscreen');
        if (document.requestFullscreen) {
          container.requestFullscreen();
        } else if (document.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        } else if (document.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
      } else {
        container.classList.remove('fullscreen');
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
      if (is3DMode) {
        map3D.resize();
      } else {
        map.invalidateSize();
      }
    }

    function updateSpeedSlider() {
      const slider = document.getElementById('speed-slider');
      const textbox = document.getElementById('playback-minutes');
      let value = parseFloat(textbox.value) || 1;
      value = Math.max(1, Math.min(100, value)); // Clamp between 0.01 and 10
      slider.value = value;
      textbox.value = value.toFixed(2);
      if (isPlaying) {
        stopAnimation();
        playAnimation();
      }
    }

    function updateSpeedTextbox() {
      const slider = document.getElementById('speed-slider');
      const textbox = document.getElementById('playback-minutes');
      const value = parseFloat(slider.value);
      textbox.value = value.toFixed(2); // Ensure two decimal places
      if (isPlaying) {
        stopAnimation();
        playAnimation();
      }
    }

    function updatePNGOpacity() {
      const opacity = parseFloat(document.getElementById('png-opacity-slider').value);
      if (is3DMode && map3D.getLayer('png-layer')) {
        map3D.setPaintProperty('png-layer', 'raster-opacity', opacity);
      } else if (pngLayer && map.hasLayer(pngLayer)) {
        pngLayer.setOpacity(opacity);
      }
    }

    function importKML(input) {
      if (!input.files || !input.files[0]) return alert('No KML file selected.');
      const file = input.files[0];
      if (document.getElementById('auto-time-filter').checked && !pendingFile) {
        showTimeFilterModal(file, 'kml');
        return;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const parser = new DOMParser();
          const kml = parser.parseFromString(e.target.result, 'text/xml');
          kmlGeoJSON = toGeoJSON.kml(kml);
          if (kmlLayer) map.removeLayer(kmlLayer);
          kmlLayer = L.geoJSON(kmlGeoJSON, {
            style: function (feature) {
              const name = feature.properties.name || '';
              const isSevere = name === 'Severe risk';
              return risk_colors[name] ? {
                color: risk_colors[name],
                fillColor: isSevere ? 'transparent' : risk_colors[name],
                fillOpacity: isSevere ? 0 : 0.3,
                weight: 2
              } : { color: 'black', fillOpacity: 0 };
            },
            onEachFeature: (f, l) => {
              if (f.properties.name) l.bindPopup(f.properties.name);
            }
          });
          if (document.getElementById('expert-mode').checked) {
            if (document.getElementById('kml-layer-toggle').checked && !is3DMode) {
              kmlLayer.addTo(map);
              kmlLayer.setZIndex(1500);
            }
            if (is3DMode) toggleKMLLayer();
          }
          updateZIndex();
          updateLegend();
        } catch (error) {
          console.error('Error parsing KML:', error);
          alert('Failed to parse KML file.');
        }
      };
      reader.readAsText(file);
    }

    function importPNG(input) {
      if (!input.files || !input.files[0]) return alert('No PNG file selected.');
      const file = input.files[0];
      if (document.getElementById('auto-time-filter').checked && !pendingFile) {
        showTimeFilterModal(file, 'png');
        return;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          pngImage = e.target.result;
          let bounds = region_bounds['UK'];
          for (const [region, regionBounds] of Object.entries(region_bounds)) {
            if (file.name.toLowerCase().includes(region.toLowerCase())) {
              bounds = regionBounds;
              break;
            }
          }
          pngBounds = bounds;
          if (pngLayer) map.removeLayer(pngLayer);
          pngLayer = L.imageOverlay(pngImage, bounds, {
            opacity: parseFloat(document.getElementById('png-opacity-slider').value)
          });
          // Only add layer if Expert Mode is enabled
          if (document.getElementById('expert-mode').checked) {
            if (document.getElementById('png-layer-toggle').checked && !is3DMode) {
              pngLayer.addTo(map);
              pngLayer.setZIndex(1400);
            }
            if (is3DMode) togglePNGLayer();
          }
          updateZIndex();
          updateLegend();
        } catch (error) {
          console.error('Error loading PNG:', error);
          alert('Failed to load PNG file.');
        }
      };
      reader.readAsDataURL(file);
    }
    /**
 * Toggles the display of lightning nowcasts on the 2D map (Leaflet)
 * and draws current clusters as convex hulls, and future projections as
 * expanding, time-stepped polygons, similar to the provided image.
 */
    // NOTE: Assuming all required helper functions (calculatePotentialImpact, getImpactHtml, etc.) 
    // are defined and available in the global scope.

    function toggleNowcast() {

      const minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);

      // 1. Clean up existing layers: CLEAR BOTH OLD cone layer AND NEW polygon layer
      if (typeof nowcastLayer !== 'undefined') {
        nowcastLayer.clearLayers();
      }
      if (typeof polygonNowcastLayer !== 'undefined') {
        polygonNowcastLayer.clearLayers();
      }

      if (document.getElementById('nowcast-toggle').checked && !is3DMode) {

        // Recalculate based on current data
        currentNowcasts = calculateLightningNowcast(currentFiltered);

        currentNowcasts.forEach((cluster) => {
          const confidence = cluster.confidenceScore;

          if (confidence >= minNowcastConfidence) {

            // --- DYNAMIC COLOR AND OPACITY CALCULATION ---
            const confidenceColor = interpolateColor(LOW_CONFIDENCE_COLOR, HIGH_CONFIDENCE_COLOR, confidence);
            const baseOpacity = Math.max(0.2, confidence * 0.8 + 0.2);
            // --- END DYNAMIC CALCULATION ---

            // --- IMPACT CALCULATION & STYLING LOGIC ---
            const potentialImpact = calculatePotentialImpact(cluster.clusterSize, confidence);
            const impactHtml = getImpactHtml(potentialImpact);

            // Determine custom styling based on impact level
            let customStrokeColor = 'red'; // Default border color for hull
            let customStrokeWeight = 2;       // Default border weight for hull
            let forecastStrokeWeight = 1;     // Default border weight for forecasts

            if (potentialImpact.includes('LEVEL 5 - EXTREME') || potentialImpact.includes('LEVEL 4 - HIGH')) {
              // Apply special styling for high-risk alerts
              customStrokeColor = '#8A2BE2'; // BlueViolet/Purple
              customStrokeWeight = 8;        // Thick outline for the hull
              forecastStrokeWeight = 4;      // Thicker outline for the forecast polygons
            }
            // ------------------------------------------

            if (typeof polygonNowcastLayer !== 'undefined') {

              // --- A1. DRAW FUTURE POLYGONS FIRST (BOTTOM LAYERS) ---
              if (cluster.nowcastPolygons && cluster.nowcastPolygons.length > 0) {
                cluster.nowcastPolygons.sort((a, b) => b.timeMinutes - a.timeMinutes);

                cluster.nowcastPolygons.forEach(forecast => {
                  const latLngs = forecast.polygon.map(p => [p[1], p[0]]);

                  const timeDecayFactor = 1.0 - (forecast.timeMinutes / 80);
                  const finalStrokeOpacity = baseOpacity * timeDecayFactor;
                  const finalFillOpacity = baseOpacity * timeDecayFactor * 0.3;

                  L.polygon(latLngs, {
                    // Use conditional weight/color for forecast stroke
                    color: customStrokeColor !== 'black' ? customStrokeColor : confidenceColor,
                    weight: forecastStrokeWeight,
                    opacity: finalStrokeOpacity,
                    fillColor: confidenceColor,
                    fillOpacity: finalFillOpacity,
                    dashArray: '5, 5'
                  }).bindPopup(`
                                <div style="font-size: 14px;">
                                    <h4>üß≠ ${forecast.timeMinutes}-Minute Projection</h4>
                                    <hr style="margin: 4px 0;">
                                    <b>Potential Impact:</b> ${impactHtml}<br>
                                    <b>Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                    <b>Projected Speed:</b> ${cluster.speedKmH.toFixed(1)} km/h<br>
                                    <b>Projected Direction:</b> ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                                </div>
                            `).addTo(polygonNowcastLayer);
                });
              }

              // --- A2. DRAW CURRENT HULL LAST (TOP LAYER - Z-INDEX) ---
              if (cluster.hullGeometry) {

                L.geoJSON(cluster.hullGeometry, {
                  style: {
                    fillColor: confidenceColor,
                    fillOpacity: Math.min(baseOpacity, 0.7),
                    // Apply conditional stroke color and weight
                    color: customStrokeColor,
                    weight: customStrokeWeight,
                    opacity: 0.9
                  }
                }).bindPopup(`
                            <div style="font-size: 14px;">
                                <h4>üå©Ô∏è Current Storm Cell (Hull)</h4>
                                <hr style="margin: 4px 0;">
                                <b>Cell Size:</b> ${cluster.clusterSize} strikes<br>
                                <b>Potential Impact:</b> ${impactHtml}<br>
                                <b>Nowcast Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                <b>Storm Motion:</b> ${cluster.speedKmH.toFixed(1)} km/h @ ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                            </div>
                        `).addTo(polygonNowcastLayer);
              }
            }
          }
        });
      }

      // 2. Toggle layer visibility on the map
      const isChecked = document.getElementById('nowcast-toggle').checked;

      if (typeof polygonNowcastLayer !== 'undefined') {
        if (isChecked && !map.hasLayer(polygonNowcastLayer)) {
          map.addLayer(polygonNowcastLayer);
        } else if (!isChecked && map.hasLayer(polygonNowcastLayer)) {
          map.removeLayer(polygonNowcastLayer);
        }
      }

      if (typeof nowcastLayer !== 'undefined') {
        if (isChecked && !map.hasLayer(nowcastLayer)) {
          map.addLayer(nowcastLayer);
        } else if (!isChecked && map.hasLayer(nowcastLayer)) {
          map.removeLayer(nowcastLayer);
        }
      }

      // Update legend after drawing/clearing
      if (typeof updateLegend === 'function') updateLegend();
    }
    // Note: toggleAllNowcasts() remains unchanged as it just calls drawMergedNowcast()

    /**
     * Renders BOTH the New Polygons and the Old Cones in a single pass.
     */

    // --- MISSING HELPERS FOR POLYGON MATH ---

    function ransacRegression(bins, iterations, threshold, decayConstant) {
      let bestModel = { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };
      let maxInliers = 0;

      for (let i = 0; i < iterations; i++) {
        const sample = randomSample(bins, 2);
        if (sample.length < 2) continue;
        const model = fitLinearModel(sample, decayConstant);

        const inliers = bins.filter(b => {
          const t = (b.time - sample[0].time) / 1000;
          const predLat = model.interceptLat + model.slopeLat * t;
          const predLon = model.interceptLon + model.slopeLon * t;
          return Math.abs(b.lat - predLat) < threshold && Math.abs(b.lon - predLon) < threshold;
        });

        if (inliers.length > maxInliers) {
          maxInliers = inliers.length;
          bestModel = fitLinearModel(inliers.length >= 2 ? inliers : sample, decayConstant);
        }
      }
      return bestModel;
    }

    function getPolygonCentroid(polygon) {
      let sumLon = 0, sumLat = 0;
      for (const p of polygon) { sumLon += p[0]; sumLat += p[1]; }
      return [sumLon / polygon.length, sumLat / polygon.length];
    }

    function translatePolygon(polygon, directionDeg, distanceKm) {
      return polygon.map(point => {
        // Simple approximation or use turf.destination for accuracy
        const dest = turf.destination(turf.point(point), distanceKm, directionDeg, { units: 'kilometers' });
        return dest.geometry.coordinates;
      });
    }

    function scalePolygon(polygon, factor, centroid) {
      if (factor === 1.0) return polygon;
      const [clon, clat] = centroid;
      return polygon.map(point => {
        const [plon, plat] = point;
        const dLon = plon - clon;
        const dLat = plat - clat;
        return [clon + dLon * factor, clat + dLat * factor];
      });
    }

    /**
     * ----------------------------------------------------------------------------------
     * --- GEOSPATIAL HELPER FUNCTIONS ---
     * ----------------------------------------------------------------------------------
     */




    /**
     * Calculates the initial bearing (forward azimuth) between two points (in degrees).
     */

    /**
     * Calculates the Circular Standard Deviation of a list of angles (in degrees).
     * Used to quantify directional consistency (based on Von Mises Distribution).
     */
    function calculateCircularStdDev(angles) {
      if (angles.length < 2) return 90;

      const degToRad = Math.PI / 180;
      let sumSin = 0;
      let sumCos = 0;

      for (const angle of angles) {
        sumSin += Math.sin(angle * degToRad);
        sumCos += Math.cos(angle * degToRad);
      }

      const meanSin = sumSin / angles.length;
      const meanCos = sumCos / angles.length;

      const R_sq = meanSin * meanSin + meanCos * meanCos;
      const V = 1 - Math.sqrt(R_sq); // Circular Variance
      const sigma_c_rad = Math.sqrt(-2 * Math.log(Math.max(1e-9, 1 - V))); // Clamp to prevent log(0)

      // Return in degrees, capped at 90 (max possible deviation for random walk)
      return Math.min(90, sigma_c_rad * 180 / Math.PI);
    }

    /**
     * ----------------------------------------------------------------------------------
     * --- REGRESSION AND RANSAC HELPER FUNCTIONS ---
     * ----------------------------------------------------------------------------------
     */

    function randomSample(array, n) {
      const result = [];
      const indices = Array.from({ length: array.length }, (_, i) => i);
      for (let i = 0; i < n && indices.length > 0; i++) {
        const idx = Math.floor(Math.random() * indices.length);
        result.push(array[indices.splice(idx, 1)[0]]);
      }
      return result;
    }

    /**
     * Fits a weighted linear model and calculates the R2 and residual error.
     */
    function fitLinearModel(bins, decayConstant) {
      let sumT = 0, sumLat = 0, sumLon = 0, sumTLat = 0, sumTLon = 0, sumT2 = 0, sumWeight = 0;
      const baseTime = bins[0].time;
      const maxTime = Math.max(...bins.map(b => b.time));
      const minTime = Math.min(...bins.map(b => b.time));

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;

        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const temporalWeight = 1.0 - (ageRatio * decayConstant);
        const strikeCountWeight = Math.log1p(b.count || 1);
        const weight = temporalWeight * strikeCountWeight;

        sumT += t * weight; sumLat += b.lat * weight; sumLon += b.lon * weight;
        sumTLat += t * b.lat * weight; sumTLon += t * b.lon * weight;
        sumT2 += t * t * weight; sumWeight += weight;
      });

      if (sumWeight === 0) return { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };

      const denominator = sumT2 * sumWeight - sumT * sumT;
      const slopeLat = denominator !== 0 ? (sumTLat * sumWeight - sumT * sumLat) / denominator : 0;
      const slopeLon = denominator !== 0 ? (sumTLon * sumWeight - sumT * sumLon) / denominator : 0;
      const interceptLat = (sumLat - slopeLat * sumT) / sumWeight;
      const interceptLon = (sumLon - slopeLon * sumT) / sumWeight;

      let ssTotLat = 0, ssResLat = 0;
      let ssTotLon = 0, ssResLon = 0;
      const meanLat = sumLat / sumWeight;
      const meanLon = sumLon / sumWeight;
      let weightedResidualSum = 0;

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;

        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const temporalWeight = 1.0 - (ageRatio * decayConstant);
        const strikeCountWeight = Math.log1p(b.count || 1);
        const weight = temporalWeight * strikeCountWeight;

        const predLat = interceptLat + slopeLat * t;
        const predLon = interceptLon + slopeLon * t;

        // Sum of Squares Total (for R2)
        ssTotLat += weight * Math.pow(b.lat - meanLat, 2);
        ssTotLon += weight * Math.pow(b.lon - meanLon, 2);

        // Sum of Squares Residual (for R2)
        ssResLat += weight * Math.pow(b.lat - predLat, 2);
        ssResLon += weight * Math.pow(b.lon - predLon, 2);

        // Weighted Residual Sum (for Weighted Standard Error)
        const residualDistanceKm = calculateDistance([b.lon, b.lat], [predLon, predLat]);
        weightedResidualSum += residualDistanceKm * weight;
      });

      // R2 is the average R2 of Lat and Lon components
      const r2_lat = ssTotLat > 0 ? 1 - ssResLat / ssTotLat : 0;
      const r2_lon = ssTotLon > 0 ? 1 - ssResLon / ssTotLon : 0;
      const r2 = (r2_lat + r2_lon) / 2;

      // Weighted Residual Error (Average Weighted Distance of inliers to the line)
      const weightedResidualErrorKm = sumWeight > 0 ? weightedResidualSum / sumWeight : 100;

      return { slopeLat, slopeLon, interceptLat, interceptLon, r2, weightedResidualErrorKm };
    }



    /**
     * ----------------------------------------------------------------------------------
     * --- CLUSTERING FUNCTION (New Dedicated) ---
     * ----------------------------------------------------------------------------------
     */

    /**
     * ==================================================================================
     * MAIN NOWCAST LOGIC
     * ==================================================================================
     */

    /**
     * Calculates lightning nowcast vectors, confidence, and geometry (Hulls/Polygons).
     * All major constants are dynamically adjusted based on the volume and recency of the lightning data.
     * The confidence calculation is optimized for stability in developing storms.
     * * @param {Array<Object>} lightningData - Time-filtered lightning strikes.
     * @returns {Array<Object>} - Array of calculated storm cluster objects.
     */
    function calculateLightningNowcast(lightningData) {
      if (!lightningData || lightningData.length === 0) return [];

      // --- 0. DYNAMIC PARAMETER CALCULATION & FILTERING ---
      const referenceTime = typeof animationEnd !== 'undefined' && animationEnd ? new Date(animationEnd) : new Date();

      const initialMaxTimeRange = 5 * 3600 * 1000;
      const recentLightning = lightningData.filter(s => (referenceTime.getTime() - s.time.getTime()) <= initialMaxTimeRange);
      const recentLightningLength = recentLightning.length;

      recentLightning.sort((a, b) => a.time.getTime() - b.time.getTime());

      // --- BASE PARAMETER DEFINITION (Dynamic) ---

      const maxDensityTarget = 2000;
      const densityRatio = Math.min(1.0, recentLightningLength / maxDensityTarget); // 0.0 to 1.0

      // --- BALANCED SOFT TIME WINDOW (Gentle nerf, no hard feelings) ---

      // Base dynamic range: high activity ‚Üí shorter window (more precise), low ‚Üí longer
      let baseMaxHours = 4.0 - (2.0 * densityRatio);
      // ‚Üí High density (ratio‚âà1): ~2 hours  
      // ‚Üí Low density (ratio‚âà0): ~4 hours  

      // Gentle penalty only when extremely sparse
      let timePenalty = 1.0;
      if (densityRatio < 0.4) {
        // Smooth quadratic shrink only in very quiet conditions
        timePenalty = 0.6 + 0.4 * Math.pow(densityRatio / 0.4, 1.5);
        // At densityRatio = 0.4 ‚Üí penalty = 1.0 (no shrink)
        // At densityRatio = 0.2 ‚Üí penalty ‚âà 0.75 (25% shrink)
        // At densityRatio = 0.0 ‚Üí penalty ‚âà 0.6 (only 40% shrink ‚Üí still ~2.4 hours)
      }

      // Optional: Light boost from recent strike rate (helps preserve active but spread-out storms)
      const recentHours = 3;
      const recentStrikes = recentLightning.filter(s =>
        (referenceTime.getTime() - s.time.getTime()) <= recentHours * 3600 * 1000
      );
      const strikeRatePerHour = recentStrikes.length / recentHours;

      // If at least moderate ongoing activity, reduce penalty
      if (strikeRatePerHour > 8) {
        timePenalty = Math.max(timePenalty, 0.85);  // Never shrink below 85% if semi-active
      }

      let maxTimeRange = baseMaxHours * 3600 * 1000 * timePenalty;

      // --- Also gently tighten spatial clustering when quiet ---
      let maxDistance = Math.max(15, Math.min(40, 35 - 15 * (1 - densityRatio)));
      // Quiet ‚Üí slightly smaller clusters, but never tiny

      let minClusterSize = Math.max(4, Math.floor(5 + 4 * densityRatio));
      // Low density needs slightly more strikes to qualify ‚Üí avoids noise clusters

      let maxInactivityMs = Math.max(10 * 60 * 1000, 25 * 60 * 1000 * (1.0 - densityRatio * 0.4));
      // Keeps decaying clusters alive a bit longer during lulls

      let maxTemporalSeparation = Math.max(10 * 60 * 1000, 30 * 60 * 1000 * (1.0 - densityRatio * 0.6));

      let ransacIterations = Math.min(250, 100 + Math.floor(recentLightningLength / 2));
      let baseDecayConstant = 0.5 + (0.1 * densityRatio);
      let binSize = 5 * 60 * 1000;
      let jumpAnalysisWindow = 10 * 60 * 1000;

      // NEW CONSTANT: Enforce a speed cap, especially useful for highly stable, slow-moving cells
      const maxSpeedCapKmH = 80;

      const finalLightning = recentLightning.filter(s => (referenceTime.getTime() - s.time.getTime()) <= maxTimeRange);

      // --- 1. CLUSTERING ---
      const clusters = clusterLightningStrikes(finalLightning, { minClusterSize, maxDistance, maxTemporalSeparation });

      // --- PASS 1: RAW VECTORS & CONFIDENCE (Updated for Intensity & Stability) ---
      const rawClusterInfos = [];
      const minBinCountForHighConfidence = 5;

      clusters.forEach((cluster) => {
        const strikeTimes = cluster.map(s => s.time.getTime());
        const minTime = Math.min(...strikeTimes);
        const maxTime = Math.max(...strikeTimes);
        const lastStrikeTime = new Date(maxTime);
        const timeSinceLastStrike = referenceTime.getTime() - lastStrikeTime.getTime();
        const clusterTimeSpanHours = (maxTime - minTime) / (3600 * 1000);

        if (timeSinceLastStrike > maxInactivityMs) return;

        // Binning
        const bins = [];
        for (let t = minTime; t < maxTime; t += binSize) {
          const binStrikes = cluster.filter(s => s.time.getTime() >= t && s.time.getTime() < t + binSize);
          if (binStrikes.length > 0) {
            let sumLat = 0, sumLon = 0, sumWeight = 0;
            binStrikes.forEach(s => {
              const ageRatio = (maxTime - s.time.getTime()) / (maxTime - minTime);
              const weight = 1.0 - (ageRatio * baseDecayConstant);
              sumLat += s.coordinates[1] * weight; sumLon += s.coordinates[0] * weight; sumWeight += weight;
            });
            bins.push({
              time: (t + t + binSize) / 2, lat: sumLat / sumWeight, lon: sumLon / sumWeight, count: binStrikes.length
            });
          }
        }
        if (bins.length === 0) return;

        // Dynamic RANSAC Threshold (as before)
        let ransacThreshold = Math.max(0.03, Math.min(0.1, 0.05 + (clusterTimeSpanHours * 0.02)));


        // RANSAC Regression
        let speedKmH = 0, directionDeg = 0, regressionScore = 0, weightedResidualErrorKm = 100;
        if (bins.length >= 2) {
          const ransacModel = ransacRegression(bins, ransacIterations, ransacThreshold, baseDecayConstant);
          regressionScore = ransacModel.r2;
          weightedResidualErrorKm = ransacModel.weightedResidualErrorKm;
          const latFactor = Math.cos(bins[0].lat * Math.PI / 180);
          const speedLatKmH = ransacModel.slopeLat * 111 * 3600;
          const speedLonKmH = ransacModel.slopeLon * 111 * latFactor * 3600;
          speedKmH = Math.sqrt(speedLatKmH * speedLatKmH + speedLonKmH * speedLonKmH);
          directionDeg = (Math.atan2(speedLonKmH, speedLatKmH) * 180 / Math.PI + 360) % 360;
        } else {
          regressionScore = 0.1;
        }

        // Apply max speed cap to raw calculation
        speedKmH = Math.min(speedKmH, maxSpeedCapKmH);

        // Directional Consistency
        const bearings = [];
        for (let i = 1; i < bins.length; i++) bearings.push(calculateBearing([bins[i - 1].lon, bins[i - 1].lat], [bins[i].lon, bins[i].lat]));
        const circularStdDevDeg = calculateCircularStdDev(bearings);
        const directionalConsistencyScore = 1.0 - (circularStdDevDeg / 90.0);

        // Lightning Jump
        const timeCutoff = referenceTime.getTime() - jumpAnalysisWindow;
        const latestCount = cluster.filter(s => s.time.getTime() >= timeCutoff).length;
        const middleCount = cluster.filter(s => s.time.getTime() < timeCutoff && s.time.getTime() >= timeCutoff - jumpAnalysisWindow).length;
        const lightningJumpDetected = (latestCount > 2.5 * middleCount && latestCount >= 6);
        const lightningJumpBonus = lightningJumpDetected ? 0.35 : 0;

        // Confidence Calculation
        const ratio = Math.min(timeSinceLastStrike / maxInactivityMs, 1.0);
        const decayFactor = Math.pow(1.0 - ratio, 2);
        const clusterSizeScore = Math.min(cluster.length / 50, 1);

        // **UPDATED** Intensity-Adjusted Bin Stability Multiplier
        const binStabilityBoost = 1.0 + (0.1 * clusterSizeScore); // Max 1.1 boost for intense storms
        const binConfidenceMultiplier = Math.min(1.0, (bins.length / minBinCountForHighConfidence) * binStabilityBoost);

        // **UPDATED** Increased weight for stability metrics
        let baseConfidence = (clusterSizeScore * 0.15 +          // Slightly reduced direct cluster size weight
          (speedKmH / maxSpeedCapKmH) * 0.05 +                // Capped speed contribution
          regressionScore * 0.30 +                            // Increased weight for linear fit (stability)
          directionalConsistencyScore * 0.35 +                // Increased weight for consistent direction (stability)
          (bins.length / minBinCountForHighConfidence) * 0.10); // Increased weight for history length

        baseConfidence *= decayFactor;
        baseConfidence *= binConfidenceMultiplier;

        let confidenceScore = Math.min(1.0, baseConfidence + lightningJumpBonus);

        rawClusterInfos.push({
          cluster, baseLat: bins[bins.length - 1].lat, baseLon: bins[bins.length - 1].lon,
          speedKmH, directionDeg, regressionScore, directionalConsistencyScore, weightedResidualErrorKm,
          confidenceScore, clusterSize: cluster.length, lightningJump: lightningJumpDetected, decaying: decayFactor < 0.5,
        });
      });

      // --- PASS 2: SMOOTHING & GEOMETRY GENERATION ---
      const clusterInfos = [];
      const projectionTimeHours = 1.0;
      const maxSmoothingDistanceKm = 50;

      rawClusterInfos.forEach((currentCluster) => {
        // A. Temporal Smoothing
        let moderatedSpeedKmH = currentCluster.speedKmH;
        let moderatedDirectionDeg = currentCluster.cluster.length < minClusterSize ? 0 : currentCluster.directionDeg;

        if (typeof previousNowcasts !== 'undefined' && previousNowcasts.length > 0) {

          // Dynamic Smoothing Factor (as before)
          const dynamicSmoothingFactor = 0.8 - (currentCluster.directionalConsistencyScore * 0.6);

          let nearestPrevNowcast = null;
          let minDistance = Infinity;
          const currentPoint = turf.point([currentCluster.baseLon, currentCluster.baseLat]);

          previousNowcasts.forEach(prevCluster => {
            const prevPoint = turf.point([prevCluster.baseLon, prevCluster.baseLat]);
            const distance = turf.distance(currentPoint, prevPoint, { units: 'kilometers' });

            if (distance < minDistance) {
              minDistance = distance;
              nearestPrevNowcast = prevCluster;
            }
          });

          if (nearestPrevNowcast && minDistance <= maxSmoothingDistanceKm) {
            const distanceRatio = minDistance / maxSmoothingDistanceKm;
            const distanceWeight = 1.0 - distanceRatio;

            const finalWeight = dynamicSmoothingFactor * nearestPrevNowcast.confidenceScore * distanceWeight;
            const inverseWeight = 1.0 - finalWeight;

            const currentU = currentCluster.speedKmH * Math.sin(currentCluster.directionDeg * Math.PI / 180);
            const currentV = currentCluster.speedKmH * Math.cos(currentCluster.directionDeg * Math.PI / 180);
            const prevU = nearestPrevNowcast.speedKmH * Math.sin(nearestPrevNowcast.directionDeg * Math.PI / 180);
            const prevV = nearestPrevNowcast.speedKmH * Math.cos(nearestPrevNowcast.directionDeg * Math.PI / 180);

            const smoothedU = (currentU * inverseWeight) + (prevU * finalWeight);
            const smoothedV = (currentV * inverseWeight) + (prevV * finalWeight);

            moderatedSpeedKmH = Math.sqrt(smoothedU * smoothedU + smoothedV * smoothedV);
            moderatedDirectionDeg = (Math.atan2(smoothedU, smoothedV) * 180 / Math.PI + 360) % 360;

            // Final check: Apply speed cap after smoothing
            moderatedSpeedKmH = Math.min(moderatedSpeedKmH, maxSpeedCapKmH);
          }
        }

        // B. Convex Hull (Current Shape Geometry)
        let hullGeometry = null;
        if (typeof turf !== 'undefined' && currentCluster.cluster.length >= minClusterSize) {
          const points = turf.featureCollection(currentCluster.cluster.map(s => turf.point([s.coordinates[0], s.coordinates[1]])));
          hullGeometry = turf.convex(points);
        }

        // C. FUTURE POLYGON PROJECTION 
        const nowcastPolygons = [];
        if (hullGeometry && hullGeometry.geometry && hullGeometry.geometry.coordinates) {
          const hullCoords = hullGeometry.geometry.coordinates[0];
          const projectionTimesMin = [15, 30, 45, 60];

          for (const tMin of projectionTimesMin) {
            const distanceKm = moderatedSpeedKmH * (tMin / 60);

            const projectedHull = translatePolygon(hullCoords, moderatedDirectionDeg, distanceKm);

            let scaleFactor = 1.0;
            if (currentCluster.lightningJump) scaleFactor = 1.0 + 0.1 * (tMin / 15);
            else if (currentCluster.decaying) scaleFactor = 1.0 - 0.15 * (tMin / 15);
            scaleFactor = Math.max(0.1, scaleFactor);

            const projectedCentroid = getPolygonCentroid(projectedHull);
            const finalHull = scalePolygon(projectedHull, scaleFactor, projectedCentroid);

            nowcastPolygons.push({ timeMinutes: tMin, polygon: finalHull });
          }
        }

        // D. Uncertainty Ellipse
        const directionalErrorDeg = (1.0 - currentCluster.directionalConsistencyScore) * 90;
        const circularStdDevRad = directionalErrorDeg * Math.PI / 180;
        const projectionDistanceKm = moderatedSpeedKmH * projectionTimeHours;
        const semiMinorKm = Math.min(75, Math.max(10, projectionDistanceKm * Math.sin(circularStdDevRad) * 0.7));
        const semiMajorKm = Math.min(150, Math.max(20, projectionDistanceKm + (currentCluster.weightedResidualErrorKm * 3)));

        if (currentCluster.confidenceScore > 0.1) {
          clusterInfos.push({
            baseLat: currentCluster.baseLat, baseLon: currentCluster.baseLon,
            speedKmH: moderatedSpeedKmH,
            directionDeg: moderatedDirectionDeg,
            confidenceScore: currentCluster.confidenceScore, clusterSize: currentCluster.clusterSize,
            hullGeometry: hullGeometry,
            nowcastPolygons: nowcastPolygons,
            uncertaintyEllipse: { semiMajorKm, semiMinorKm, rotationDeg: moderatedDirectionDeg }
          });
        }
      });

      if (typeof previousNowcasts !== 'undefined') {
        previousNowcasts = clusterInfos;
      }

      return clusterInfos;
    }
    /**
     * ==================================================================================
     * HELPER FUNCTIONS (CLUSTERING & MATH)
     * ==================================================================================
     */

    function clusterLightningStrikes(lightningData, params) {
      if (!lightningData || lightningData.length === 0) return [];

      const { minClusterSize, maxDistance, maxTemporalSeparation } = params;
      const localDensityWindowMs = 5 * 60 * 1000;
      const densityDistanceKm = 50;

      const clusters = [];
      const used = new Set();

      for (let i = 0; i < lightningData.length; i++) {
        if (used.has(i)) continue;

        const currentCluster = [];
        const queue = [i];
        used.add(i);

        while (queue.length > 0) {
          const idx = queue.shift();
          const strike = lightningData[idx];
          currentCluster.push(strike);

          const localDensityCount = lightningData.filter(s =>
            (strike.time.getTime() - s.time.getTime()) <= localDensityWindowMs &&
            calculateDistance(strike.coordinates, s.coordinates) <= densityDistanceKm
          ).length;

          const densityFactor = Math.max(0.5, 1.0 - (localDensityCount / 50) * 0.5);
          const dynamicMaxDistance = maxDistance * densityFactor;

          for (let j = 0; j < lightningData.length; j++) {
            if (used.has(j)) continue;
            const neighbor = lightningData[j];
            const dist = calculateDistance(strike.coordinates, neighbor.coordinates);
            const timeDiff = Math.abs(strike.time.getTime() - neighbor.time.getTime());

            if (dist <= dynamicMaxDistance && timeDiff <= maxTemporalSeparation) {
              used.add(j);
              queue.push(j);
            }
          }
        }
        if (currentCluster.length >= minClusterSize) {
          clusters.push(currentCluster);
        }
      }
      return clusters;
    }

    function calculateDistance(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function calculateBearing(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }



    function randomSample(array, n) {
      const result = [];
      const indices = Array.from({ length: array.length }, (_, i) => i);
      for (let i = 0; i < n && indices.length > 0; i++) {
        const idx = Math.floor(Math.random() * indices.length);
        result.push(array[indices.splice(idx, 1)[0]]);
      }
      return result;
    }

    function fitLinearModel(bins, decayConstant) {
      let sumT = 0, sumLat = 0, sumLon = 0, sumTLat = 0, sumTLon = 0, sumT2 = 0, sumWeight = 0;
      const baseTime = bins[0].time;
      const maxTime = Math.max(...bins.map(b => b.time));
      const minTime = Math.min(...bins.map(b => b.time));

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const weight = (1.0 - (ageRatio * decayConstant)) * Math.log1p(b.count || 1);
        sumT += t * weight; sumLat += b.lat * weight; sumLon += b.lon * weight;
        sumTLat += t * b.lat * weight; sumTLon += t * b.lon * weight;
        sumT2 += t * t * weight; sumWeight += weight;
      });

      if (sumWeight === 0) return { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };

      const denominator = sumT2 * sumWeight - sumT * sumT;
      const slopeLat = denominator !== 0 ? (sumTLat * sumWeight - sumT * sumLat) / denominator : 0;
      const slopeLon = denominator !== 0 ? (sumTLon * sumWeight - sumT * sumLon) / denominator : 0;
      const interceptLat = (sumLat - slopeLat * sumT) / sumWeight;
      const interceptLon = (sumLon - slopeLon * sumT) / sumWeight;

      let ssTotLat = 0, ssResLat = 0, ssTotLon = 0, ssResLon = 0, weightedResidualSum = 0;
      const meanLat = sumLat / sumWeight;
      const meanLon = sumLon / sumWeight;

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const ageRatio = (maxTime - minTime) > 0 ? (maxTime - b.time) / (maxTime - minTime) : 0;
        const weight = (1.0 - (ageRatio * decayConstant)) * Math.log1p(b.count || 1);

        const predLat = interceptLat + slopeLat * t;
        const predLon = interceptLon + slopeLon * t;

        ssTotLat += weight * Math.pow(b.lat - meanLat, 2);
        ssTotLon += weight * Math.pow(b.lon - meanLon, 2);
        ssResLat += weight * Math.pow(b.lat - predLat, 2);
        ssResLon += weight * Math.pow(b.lon - predLon, 2);

        weightedResidualSum += calculateDistance([b.lon, b.lat], [predLon, predLat]) * weight;
      });

      const r2 = ((ssTotLat > 0 ? 1 - ssResLat / ssTotLat : 0) + (ssTotLon > 0 ? 1 - ssResLon / ssTotLon : 0)) / 2;
      const weightedResidualErrorKm = weightedResidualSum / sumWeight;

      return { slopeLat, slopeLon, interceptLat, interceptLon, r2, weightedResidualErrorKm };
    }

    function ransacRegression(bins, iterations, threshold, decayConstant) {
      let bestModel = { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0, weightedResidualErrorKm: 100 };
      let maxInliers = 0;

      for (let i = 0; i < iterations; i++) {
        const sample = randomSample(bins, 2);
        if (sample.length < 2) continue;
        const model = fitLinearModel(sample, decayConstant);
        const inliers = bins.filter(b => {
          const t = (b.time - sample[0].time) / 1000;
          const predLat = model.interceptLat + model.slopeLat * t;
          const predLon = model.interceptLon + model.slopeLon * t;
          return Math.abs(b.lat - predLat) < threshold && Math.abs(b.lon - predLon) < threshold;
        });
        if (inliers.length > maxInliers) {
          maxInliers = inliers.length;
          bestModel = fitLinearModel(inliers.length >= 2 ? inliers : sample, decayConstant);
        }
      }
      return bestModel;
    }

    /**
     * Calculates a professional, diagnostic risk rating and description based on storm intensity 
     * and prediction confidence. Uses a Level 1 to Level 5 scale.
     */
    function calculatePotentialImpact(clusterSize, confidence) {

      const highConfidence = confidence > 0.8;
      const moderateConfidence = confidence > 0.5;

      // --- Level 5: Extreme Risk (Focus on Size > 3000) ---

      // Catches the most massive cells
      if (clusterSize >= 6000) return `LEVEL 5 - EXTREME: Cell size over 6,000 strikes. Sustained, widespread activity.`;

      // Massive cell with high predictability
      if (clusterSize > 3000 && highConfidence) return `LEVEL 5 - EXTREME: Massive cell with high forecast confidence. Prepare for widespread impact.`;

      // Large cell with strong evidence of consistent, extreme intensity
      if (clusterSize > 1000 && confidence > 0.9) return `LEVEL 5 - EXTREME: Cell highly concentrated (over 1,000 strikes). High predictability.`;


      // --- Level 4: High Risk (Focus on Size 300 - 3000) ---

      // Very large cell, regardless of confidence
      if (clusterSize > 3000) return `LEVEL 4 - HIGH: Very large cell (over 3,000 strikes). High potential for significant coverage.`;

      // Significant size with good predictability
      if (clusterSize > 300 && highConfidence) return `LEVEL 4 - HIGH: Significant cell size with strong directional confidence.`;

      // Large cell, moderate predictability
      if (clusterSize > 1000 && moderateConfidence) return `LEVEL 4 - HIGH: Large area of activity (over 1,000 strikes). Moderate predictability.`;


      // --- Level 3: Moderate Risk (Focus on Size 80 - 300) ---

      // Moderate size with excellent predictability
      if (clusterSize > 80 && highConfidence) return `LEVEL 3 - MODERATE: Concentrated strike cluster with high forecast confidence.`;

      // Medium-large size, moderate predictability
      if (clusterSize > 200 && moderateConfidence) return `LEVEL 3 - MODERATE: Medium-large cell. Maintain situational awareness.`;

      // Large size, low predictability (still requires attention)
      if (clusterSize > 500 && confidence > 0.3) return `LEVEL 3 - MODERATE: Large but disorganized cell. Monitor for consolidation.`;


      // --- Level 2: Minor Risk (Focus on Size 15 - 80) ---

      // Small clusters that are still predictable
      if (clusterSize > 15 && moderateConfidence) return `LEVEL 2 - MINOR: Defined activity cluster. Low potential for local impact.`;

      // General tracking of scattered cells
      if (clusterSize > 5) return `LEVEL 2 - MINOR: Isolated, sparse strike activity tracked.`;


      // --- Level 1: Negligible Risk ---
      return `LEVEL 1 - NEGLIGIBLE: Insignificant activity. Negligible risk.`;
    }
    /**
     * Helper function to convert degrees to cardinal/intercardinal direction.
     */
    function getDirection(degrees) {
      if (degrees > 337.5 || degrees <= 22.5) return "N";
      if (degrees > 22.5 && degrees <= 67.5) return "NE";
      if (degrees > 67.5 && degrees <= 112.5) return "E";
      if (degrees > 112.5 && degrees <= 157.5) return "SE";
      if (degrees > 157.5 && degrees <= 202.5) return "S";
      if (degrees > 202.5 && degrees <= 247.5) return "SW";
      if (degrees > 247.5 && degrees <= 292.5) return "W";
      if (degrees > 292.5 && degrees <= 337.5) return "NW";
      return "";
    }
    // NOTE: Ensure these helper functions are defined in your script scope:
    // getDirection, interpolateColor, LOW_CONFIDENCE_COLOR_HEX, HIGH_CONFIDENCE_COLOR_HEX, calculatePotentialImpact

    // Utility to generate styled HTML for the impact level
    function getImpactHtml(impact) {
      let color;
      let weight = 'normal';

      // Determine color based on the numerical Level
      if (impact.includes('LEVEL 5 - EXTREME')) {
        color = '#FF0000'; // Bright Red
        weight = 'bolder';
      } else if (impact.includes('LEVEL 4 - HIGH')) {
        color = '#FF4500'; // Orange-Red
        weight = 'bold';
      } else if (impact.includes('LEVEL 3 - MODERATE')) {
        color = '#FF8C00'; // Dark Orange
        weight = 'bold';
      } else if (impact.includes('LEVEL 2 - MINOR')) {
        color = '#DAA520'; // Goldenrod/Yellowish
      } else { // LEVEL 1 - NEGLIGIBLE
        color = '#32CD32'; // Green
      }

      // Convert to uppercase for high visibility in the popup
      const formattedImpact = impact.toUpperCase();

      return `<span style="color: ${color}; font-weight: ${weight};">${formattedImpact}</span>`;
    }

    function updateNowcast(filtered) {
      // 1. CLEAR ALL LAYERS (Both 2D and 3D)
      if (typeof polygonNowcastLayer !== 'undefined') {
        polygonNowcastLayer.clearLayers();
      }
      if (typeof nowcastLayer !== 'undefined') {
        nowcastLayer.clearLayers();
      }
      if (typeof nowcastLayer3D !== 'undefined') {
        nowcastLayer3D.forEach(layer => {
          if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
          if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
        });
        nowcastLayer3D = [];
      }

      // 2. CHECK TOGGLE
      if (!document.getElementById('nowcast-toggle').checked) return;

      // 3. CALCULATE NOWCAST WITH FILTERED DATA
      const minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value) || 0.5;
      currentNowcasts = calculateLightningNowcast(filtered);

      // 4. DRAWING LOOP
      currentNowcasts.forEach((cluster, index) => {
        const confidence = cluster.confidenceScore;

        // Skip low confidence
        if (confidence < minNowcastConfidence) return;

        // ============================================================
        // DYNAMIC COLOR & OPACITY CALCULATION
        // HIGH CONFIDENCE => HIGH OPACITY (LOW TRANSPARENCY)
        // ============================================================
        // NOTE: Assuming LOW_CONFIDENCE_COLOR_HEX/HIGH_CONFIDENCE_COLOR_HEX constants are available
        const confidenceColor = interpolateColor(LOW_CONFIDENCE_COLOR, HIGH_CONFIDENCE_COLOR, confidence);

        // Base opacity: Min 0.2 opacity at CS 0.0, Max 1.0 opacity at CS 1.0 (for uncapped use)
        const baseOpacity = Math.max(0.2, confidence * 0.8 + 0.2);
        // ============================================================

        // --- IMPACT CALCULATION & STYLING LOGIC ---
        const potentialImpact = calculatePotentialImpact(cluster.clusterSize, confidence);
        const impactHtml = getImpactHtml(potentialImpact);

        // Determine custom styling based on impact level (Level 4/5 = Purple/Thick)
        let customStrokeColor = 'red'; // Default border color for hull
        let customStrokeWeight = 2;       // Default border weight for hull
        let forecastStrokeWeight = 1;     // Default border weight for forecasts

        if (potentialImpact.includes('LEVEL 5 - EXTREME') || potentialImpact.includes('LEVEL 4 - HIGH')) {
          // Apply special styling for high-risk alerts: Purple and thicker
          customStrokeColor = '#8A2BE2'; // BlueViolet/Purple
          customStrokeWeight = 8;        // Thick outline for the hull
          forecastStrokeWeight = 4;      // Thicker outline for the forecast polygons
        }
        // ------------------------------------------

        // ============================================================
        // 2D MODE (Leaflet)
        // ============================================================
        if (!is3DMode) {

          if (typeof polygonNowcastLayer !== 'undefined') {

            // --- A1. DRAW FUTURE POLYGONS FIRST (BOTTOM LAYERS) ---
            if (cluster.nowcastPolygons && cluster.nowcastPolygons.length > 0) {
              cluster.nowcastPolygons.sort((a, b) => b.timeMinutes - a.timeMinutes);

              cluster.nowcastPolygons.forEach(forecast => {
                const latLngs = forecast.polygon.map(p => [p[1], p[0]]);

                const timeDecayFactor = 1.0 - (forecast.timeMinutes / 80);
                const finalStrokeOpacity = baseOpacity * timeDecayFactor;
                const finalFillOpacity = baseOpacity * timeDecayFactor * 0.3;

                L.polygon(latLngs, {
                  // Use conditional weight/color for forecast stroke
                  color: customStrokeColor !== 'black' ? customStrokeColor : confidenceColor,
                  weight: forecastStrokeWeight,
                  opacity: finalStrokeOpacity,
                  fillColor: confidenceColor,
                  fillOpacity: finalFillOpacity,
                  dashArray: '5, 5'
                }).bindPopup(`
                            <div style="font-size: 14px;">
                                <h4>üß≠ ${forecast.timeMinutes}-Minute Projection</h4>
                                <hr style="margin: 4px 0;">
                                <b>Potential Impact:</b> ${impactHtml}<br>
                                <b>Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                                <b>Projected Speed:</b> ${cluster.speedKmH.toFixed(1)} km/h<br>
                                <b>Projected Direction:</b> ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                            </div>
                        `).addTo(polygonNowcastLayer);
              });
            }

            // --- A2. DRAW CURRENT HULL LAST (TOP LAYER - Z-INDEX) ---
            if (cluster.hullGeometry) {
              L.geoJSON(cluster.hullGeometry, {
                style: {
                  fillColor: confidenceColor,
                  // FIX: Hull opacity is capped at 0.7 
                  fillOpacity: Math.min(baseOpacity, 0.7), // Reverted cap to 0.7
                  // Apply conditional stroke color and weight
                  color: customStrokeColor,
                  weight: customStrokeWeight,
                  opacity: 0.9 // Stroke opacity remains high
                }
              }).bindPopup(`
                        <div style="font-size: 14px;">
                            <h4>üå©Ô∏è Current Storm Cell (Hull)</h4>
                            <hr style="margin: 4px 0;">
                            <b>Cell Size:</b> ${cluster.clusterSize} strikes<br>
                            <b>Potential Impact:</b> ${impactHtml}<br>
                            <b>Nowcast Confidence:</b> ${(confidence * 100).toFixed(0)}% (${confidence.toFixed(2)})<br>
                            <b>Storm Motion:</b> ${cluster.speedKmH.toFixed(1)} km/h @ ${cluster.directionDeg.toFixed(1)}¬∞ (${getDirection(cluster.directionDeg)})<br>
                        </div>
                    `).addTo(polygonNowcastLayer);
            }
          }


        }

        // ============================================================
        // 3D MODE (Mapbox GL JS) 
        // ============================================================
        else {
          const radiusKm = confidence * 5 + 5;
          const coneRadiusKm = confidence * 30 + 30;
          const radiusDeg = radiusKm / 111;

          // Render Cluster Circle
          const circleId = `nowcast-circle-${index}`;
          map3D.addSource(circleId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [cluster.baseLon, cluster.baseLat] },
              properties: { radius: radiusDeg }
            }
          });
          map3D.addLayer({
            id: circleId,
            type: 'circle',
            source: circleId,
            paint: {
              'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, (radiusKm * 1000) / 1000, 10, (radiusKm * 1000) / 250],
              'circle-color': confidenceColor,
              'circle-opacity': baseOpacity, // Dynamic opacity
              'circle-stroke-width': customStrokeWeight, // Use custom weight for emphasis
              'circle-stroke-color': customStrokeColor // Use custom color for emphasis
            }
          });
          nowcastLayer3D.push({ id: circleId, source: circleId });

          // Render Cone Sector (Cone Sector uses color and fill opacity)
          if (typeof turf !== 'undefined') {
            const cone = turf.sector(
              [cluster.baseLon, cluster.baseLat],
              coneRadiusKm,
              cluster.directionDeg - 15,
              cluster.directionDeg + 15,
              { units: 'kilometers' }
            );
            const coneId = `nowcast-cone-${index}`;
            map3D.addSource(coneId, { type: 'geojson', data: cone });
            map3D.addLayer({
              id: coneId,
              type: 'fill',
              source: coneId,
              paint: {
                'fill-color': confidenceColor,
                'fill-opacity': baseOpacity * 0.5 // Dynamic fill opacity
              }
            });
            nowcastLayer3D.push({ id: coneId, source: coneId });
          }
        }
      });

      // Ensure layers are added to map if visible
      if (!is3DMode) {
        if (typeof polygonNowcastLayer !== 'undefined' && !map.hasLayer(polygonNowcastLayer)) {
          map.addLayer(polygonNowcastLayer);
        }
        if (typeof nowcastLayer !== 'undefined' && !map.hasLayer(nowcastLayer)) {
          map.addLayer(nowcastLayer);
        }
      }

      if (typeof updateLegend === 'function') updateLegend();
    }
    function calculateDistance(coords1, coords2) {
      const [lon1, lat1] = coords1;
      const [lon2, lat2] = coords2;
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function initializeDragAndDrop() {
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        mapDiv.addEventListener(evt, handleDragDrop, false);
        map3DDiv.addEventListener(evt, handleDragDrop, false);
      });
    }

    function handleDragDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      if (e.type === 'dragenter' || e.type === 'dragover') {
        mapDiv.classList.add('dropzone');
        map3DDiv.classList.add('dropzone');
      } else if (e.type === 'dragleave') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
      } else if (e.type === 'drop') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
        const file = e.dataTransfer.files[0];
        if (!file) return;
        if (file.name.endsWith('.kml')) {
          document.getElementById('kml-file').files = e.dataTransfer.files;
          importKML(document.getElementById('kml-file'));
        } else if (file.name.endsWith('.png')) {
          document.getElementById('png-file').files = e.dataTransfer.files;
          importPNG(document.getElementById('png-file'));
        }
      }
    }

    map.on('moveend', () => {
      if (!is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        const currentBounds = map.getBounds();
        currentFiltered.forEach(s => {
          const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
          const isNewStrike = !lastRenderedStrikes.has(strikeKey);
          const inBounds = currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
          if (isNewStrike && inBounds) {
            playThunderSound();
            addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
          }
        });
      }
    });

    map3D.on('moveend', () => {
      if (is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        update3DView();
      }
    });
    initializeDrawControl();
    initializeDragAndDrop();
    fetchData();
    setRefreshInterval();
    document.addEventListener('DOMContentLoaded', () => {
      // Only add title group on desktop (screen width ‚â•769px)
      if (window.innerWidth >= 769) {
        const topBar = document.getElementById('top-bar');

        const titleGroup = document.createElement('div');
        titleGroup.id = 'title-group';
        titleGroup.innerHTML = `
      <img id="app-logo" 
           src="https://raw.githubusercontent.com/Handry-Outlook/Convective-Outlook/refs/heads/main/Handry_outlook_icon_pride_small.png" 
           alt="RadarLoop ‚ö°‚õàÔ∏è">
      <h2 id="app-title">RadarLoop ‚ö°‚õàÔ∏è</h2>
    `;

        // Insert in the middle (after draw-toolbar, before right-controls)
        const rightControls = topBar.querySelector('.right-controls');
        topBar.insertBefore(titleGroup, rightControls);
      }

      // Optional: Re-check on resize (e.g., rotating tablet)
      window.addEventListener('resize', () => {
        const titleGroup = document.getElementById('title-group');
        if (window.innerWidth >= 769) {
          if (!titleGroup) {
            // Add it if now desktop
            location.reload(); // Simple way ‚Äî or re-run the injection code
          }
        } else {
          if (titleGroup) {
            titleGroup.remove();
          }
        }
      });
    });
  </script>
  <script>
